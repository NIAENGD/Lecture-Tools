<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title data-i18n="document.title">Lecture Tools</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --background: #f5f6f8;
        --text: #1f2933;
        --muted: #475569;
        --panel-bg: #ffffff;
        --panel-border: #d2d6dc;
        --panel-shadow: 0 1px 2px rgba(15, 23, 42, 0.04);
        --accent: #2563eb;
        --accent-contrast: #ffffff;
        --accent-muted: #e2e8f0;
        --danger: #dc2626;
        --danger-contrast: #ffffff;
        --placeholder: #64748b;
        --status-info-bg: #e0f2fe;
        --status-info-text: #0369a1;
        --status-error-bg: #fee2e2;
        --status-error-text: #b91c1c;
        --status-success-bg: #dcfce7;
        --status-success-text: #166534;
        --status-progress-track: rgba(15, 23, 42, 0.16);
      }

      body[data-theme='light'] {
        color-scheme: light;
      }

      body[data-theme='dark'] {
        color-scheme: dark;
        --background: #0f172a;
        --text: #f8fafc;
        --muted: #94a3b8;
        --panel-bg: #1e293b;
        --panel-border: #334155;
        --panel-shadow: 0 1px 2px rgba(2, 6, 23, 0.5);
        --accent: #38bdf8;
        --accent-contrast: #0f172a;
        --accent-muted: rgba(56, 189, 248, 0.18);
        --danger: #f87171;
        --danger-contrast: #0f172a;
        --placeholder: #94a3b8;
        --status-info-bg: rgba(14, 165, 233, 0.2);
        --status-info-text: #bae6fd;
        --status-error-bg: rgba(248, 113, 113, 0.24);
        --status-error-text: #fecaca;
        --status-success-bg: rgba(74, 222, 128, 0.22);
        --status-success-text: #bbf7d0;
        --status-progress-track: rgba(255, 255, 255, 0.25);
      }

      body[data-theme='system'] {
        color-scheme: light;
      }

      @media (prefers-color-scheme: dark) {
        body[data-theme='system'] {
          color-scheme: dark;
          --background: #0f172a;
          --text: #f8fafc;
          --muted: #94a3b8;
          --panel-bg: #1e293b;
          --panel-border: #334155;
          --panel-shadow: 0 1px 2px rgba(2, 6, 23, 0.5);
          --accent: #38bdf8;
          --accent-contrast: #0f172a;
          --accent-muted: rgba(56, 189, 248, 0.18);
          --danger: #f87171;
          --danger-contrast: #0f172a;
          --placeholder: #94a3b8;
          --status-info-bg: rgba(14, 165, 233, 0.2);
          --status-info-text: #bae6fd;
          --status-error-bg: rgba(248, 113, 113, 0.24);
          --status-error-text: #fecaca;
          --status-success-bg: rgba(74, 222, 128, 0.22);
          --status-success-text: #bbf7d0;
          --status-progress-track: rgba(255, 255, 255, 0.25);
        }
      }

      * {
        box-sizing: border-box;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .hidden {
        display: none !important;
      }

      body {
        margin: 0;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
        font-size: 15px;
        background: var(--background);
        color: var(--text);
        transition: background 0.2s ease, color 0.2s ease;
      }

      body.dialog-open {
        overflow: hidden;
      }

      main.layout {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px;
        display: flex;
        gap: 24px;
        align-items: flex-start;
      }

      .sidebar {
        width: 320px;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .panel {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 18px 20px;
        box-shadow: var(--panel-shadow);
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .dialog {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        z-index: 1000;
      }

      .dialog.hidden {
        display: none !important;
      }

      .dialog-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(2px);
      }

      .dialog-window {
        position: relative;
        z-index: 1;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        padding: 24px;
        width: min(420px, 100%);
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25), var(--panel-shadow);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .storage-page {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .storage-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 16px;
      }

      .storage-header h2 {
        margin: 0;
      }

      .storage-path {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .storage-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .storage-actions button {
        border-radius: 999px;
        border: 1px solid var(--panel-border);
        background: transparent;
        color: var(--muted);
        padding: 6px 14px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease,
          filter 0.2s ease;
      }

      .storage-actions button:hover {
        border-color: var(--accent);
        color: var(--text);
        background: var(--accent-muted);
      }

      .storage-actions button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-contrast);
      }

      .storage-actions button.primary:hover {
        filter: brightness(0.95);
      }

      .storage-actions button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: var(--danger-contrast);
      }

      .storage-actions button.danger:hover {
        filter: brightness(0.95);
      }

      .storage-actions button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        filter: none;
      }

      .storage-usage {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 12px;
        background: var(--background);
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        padding: 12px 16px;
      }

      .storage-usage-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .storage-usage-label {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .storage-usage-value {
        font-size: 1.1rem;
        font-weight: 600;
      }

      .storage-empty,
      .storage-loading {
        text-align: center;
        padding: 32px 16px;
        color: var(--muted);
        border-radius: 10px;
        border: 1px dashed var(--panel-border);
      }

      .storage-loading {
        border-style: solid;
        border-color: transparent;
      }

      .storage-purge-summary {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .storage-class-wrapper {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .storage-class-list,
      .storage-module-list,
      .storage-lecture-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .storage-module-list,
      .storage-lecture-list {
        gap: 10px;
      }

      .storage-class-card,
      .storage-module-card,
      .storage-lecture-item {
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        background: var(--background);
        padding: 14px 16px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .storage-module-card,
      .storage-lecture-item {
        border-radius: 8px;
      }

      .storage-lecture-item {
        padding: 12px 14px;
      }

      .storage-class-header,
      .storage-module-header,
      .storage-lecture-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }

      .storage-class-title,
      .storage-module-title {
        margin: 0;
        font-size: 1.05rem;
      }

      .storage-lecture-title {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }

      .storage-class-meta,
      .storage-module-meta,
      .storage-lecture-meta {
        margin: 0;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .storage-class-size,
      .storage-module-size,
      .storage-lecture-size {
        font-weight: 600;
        white-space: nowrap;
      }

      .storage-lecture-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .storage-lecture-eligible {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        background: var(--status-success-bg);
        color: var(--status-success-text);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 0.8rem;
        font-weight: 600;
        align-self: flex-start;
      }

      .dialog-title {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
      }

      .dialog-message {
        margin: 0;
        font-size: 0.95rem;
        color: var(--muted);
        white-space: pre-wrap;
      }

      .dialog-input-wrapper {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .dialog-input {
        width: 100%;
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 10px 12px;
        font-size: 0.95rem;
        background: var(--background);
        color: var(--text);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .dialog-input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
      }

      .dialog-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }

      .dialog-button {
        border: 1px solid transparent;
        border-radius: 999px;
        padding: 8px 16px;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease,
          filter 0.2s ease;
      }

      .dialog-button:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      }

      .dialog-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      .dialog-button.secondary {
        background: transparent;
        border-color: var(--panel-border);
        color: var(--muted);
      }

      .dialog-button.secondary:hover {
        border-color: var(--accent);
        color: var(--text);
      }

      .dialog-button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-contrast);
      }

      .dialog-button.primary:hover {
        filter: brightness(0.95);
      }

      .dialog-button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: var(--danger-contrast);
      }

      .dialog-button.danger:hover {
        filter: brightness(0.92);
      }

      .panel-heading {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
        color: var(--muted);
      }

      .panel-heading label {
        margin: 0;
        color: inherit;
      }

      .top-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 16px 20px 0;
        border-bottom: 1px solid var(--panel-border);
        background: var(--panel-bg);
        border-radius: 8px 8px 0 0;
      }

      .top-bar-left,
      .top-bar-right {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .top-bar button {
        border-radius: 999px;
        border: 1px solid transparent;
        background: var(--accent-muted);
        color: var(--text);
        padding: 6px 14px;
        font-weight: 600;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }

      .top-bar button[data-view]:hover {
        background: var(--accent);
        color: var(--accent-contrast);
        border-color: var(--accent);
      }

      .top-bar button.active {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-contrast);
      }

      .top-bar button.ghost {
        background: transparent;
        border-color: var(--panel-border);
        color: var(--muted);
      }

      .top-bar button.ghost:hover {
        border-color: var(--accent);
        color: var(--text);
      }

      .top-bar button.ghost.active {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-contrast);
      }

      .content-panel {
        padding: 0;
        overflow: hidden;
      }

      .content-panel .view {
        padding: 20px;
      }

      .view {
        display: none;
      }

      .view.active {
        display: block;
      }

      .edit-banner {
        background: var(--status-info-bg);
        color: var(--status-info-text);
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 0.9rem;
        margin-bottom: 12px;
      }

      h1 {
        font-size: 1.6rem;
        margin: 0 0 8px;
      }

      h2 {
        font-size: 1.2rem;
        margin: 0 0 12px;
      }

      h3 {
        font-size: 1rem;
        margin: 16px 0 8px;
      }

      p {
        margin: 0 0 12px;
        line-height: 1.5;
      }

      label {
        font-weight: 600;
        display: block;
        margin-bottom: 4px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      input[type='text'],
      input[type='search'],
      input[type='number'],
      textarea,
      select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 6px;
        border: 1px solid var(--panel-border);
        font-family: inherit;
        font-size: 0.95rem;
        background: var(--panel-bg);
        color: var(--text);
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      textarea {
        resize: vertical;
        min-height: 96px;
      }

      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
      }

      button {
        border: 1px solid var(--accent);
        background: var(--accent);
        color: var(--accent-contrast);
        border-radius: 6px;
        padding: 8px 14px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }

      button:hover {
        opacity: 0.92;
      }

      button.secondary {
        background: transparent;
        color: var(--accent);
      }

      button.secondary:hover {
        background: rgba(37, 99, 235, 0.12);
      }

      button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: var(--danger-contrast);
      }

      button.danger:hover {
        opacity: 0.9;
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .pill {
        border-radius: 999px;
      }

      .status-bar {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        max-width: 1200px;
        margin: 0 auto;
        padding: 10px 14px;
        border-radius: 6px;
        font-size: 0.9rem;
        display: none;
      }

      .status-message {
        margin: 0;
        word-break: break-word;
      }

      .status-progress {
        margin-top: 8px;
        display: none;
      }

      .status-progress[hidden] {
        display: none;
      }

      .status-progress:not([hidden]) {
        display: block;
      }

      .status-progress-track {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: var(--status-progress-track);
        overflow: hidden;
      }

      .status-progress-fill {
        width: 0%;
        height: 100%;
        background: currentColor;
        opacity: 0.85;
        transition: width 0.25s ease-out;
      }

      .status-progress-text {
        display: block;
        margin-top: 4px;
        font-size: 0.75rem;
        text-align: right;
        opacity: 0.85;
      }

      .status-bar[data-variant='error'] {
        background: var(--status-error-bg);
        color: var(--status-error-text);
        border-color: var(--status-error-bg);
      }

      .status-bar[data-variant='success'] {
        background: var(--status-success-bg);
        color: var(--status-success-text);
        border-color: var(--status-success-bg);
      }

      .status-bar[data-variant='info'] {
        background: var(--status-info-bg);
        color: var(--status-info-text);
        border-color: var(--status-info-bg);
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
      }

      .stats-grid div {
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 10px;
        background: var(--background);
      }

      .stats-grid dt {
        margin: 0;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--muted);
      }

      .stats-grid dd {
        margin: 4px 0 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text);
      }

      .curriculum {
        margin-top: 12px;
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        padding: 16px;
        background: var(--panel-bg);
        max-height: calc(100vh - 260px);
        overflow-y: auto;
        font-size: 0.95rem;
      }

      .curriculum.placeholder {
        color: var(--placeholder);
        font-style: italic;
      }

      .curriculum-toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }

      .curriculum-toolbar h3 {
        margin: 0;
        font-size: 1rem;
        color: var(--muted);
      }

      .curriculum-toolbar-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .syllabus {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .syllabus details {
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        background: var(--background);
        overflow: hidden;
      }

      .syllabus summary {
        list-style: none;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        cursor: pointer;
        font-weight: 600;
        position: relative;
      }

      .syllabus summary::-webkit-details-marker {
        display: none;
      }

      .syllabus summary::before {
        content: '';
        width: 10px;
        height: 10px;
        border-right: 2px solid var(--muted);
        border-bottom: 2px solid var(--muted);
        transform: rotate(-45deg);
        transition: transform 0.2s ease;
        flex-shrink: 0;
      }

      details[open] > summary::before {
        transform: rotate(45deg);
      }

      .syllabus-summary-text {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
        min-width: 0;
      }

      .syllabus-title {
        font-size: 1rem;
      }

      .syllabus-meta {
        color: var(--muted);
        font-size: 0.85rem;
      }

      .syllabus-actions {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .syllabus-content {
        padding: 0 16px 16px 36px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .syllabus-modules {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .syllabus-module summary {
        font-weight: 500;
        padding: 10px 14px;
      }

      .syllabus-module .syllabus-content {
        padding: 0 16px 16px 28px;
      }

      .syllabus-lectures {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .syllabus-lectures.empty {
        min-height: 36px;
      }

      .syllabus-lecture {
        display: flex;
        align-items: center;
        gap: 8px;
        position: relative;
      }

      .syllabus-lecture.dragging {
        opacity: 0.55;
      }

      .syllabus-lectures.drop-target {
        background: rgba(37, 99, 235, 0.08);
        border-radius: 8px;
        padding: 6px;
      }

      .syllabus-lecture.drop-before::before,
      .syllabus-lecture.drop-after::after {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent);
        border-radius: 999px;
      }

      .syllabus-lecture.drop-before::before {
        top: -4px;
      }

      .syllabus-lecture.drop-after::after {
        bottom: -4px;
      }

      .lecture-button {
        flex: 1;
        text-align: left;
        padding: 8px 12px;
        border: 1px solid transparent;
        border-radius: 8px;
        background: transparent;
        cursor: pointer;
        font-size: 0.95rem;
        color: inherit;
        transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
      }

      .lecture-button:hover,
      .lecture-button:focus {
        border-color: var(--panel-border);
        background: var(--accent-muted);
        outline: none;
      }

      .lecture-button.active {
        border-color: var(--accent);
        background: rgba(37, 99, 235, 0.12);
        color: var(--accent);
      }

      button.text-button {
        background: transparent;
        border: none;
        color: var(--accent);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      button.text-button:hover {
        background: var(--accent-muted);
      }

      button.text-button.danger {
        color: var(--danger);
      }

      button.text-button.danger:hover {
        background: rgba(220, 38, 38, 0.12);
      }

      .placeholder {
        color: var(--placeholder);
        font-style: italic;
      }

      .field {
        margin-bottom: 12px;
      }

      .form-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 12px;
      }

      .asset-list {
        list-style: none;
        margin: 12px 0 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .asset-item {
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 10px 12px;
        background: var(--background);
      }

      .asset-header {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .asset-status {
        font-size: 0.9rem;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .asset-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      .asset-actions a {
        color: var(--accent);
        text-decoration: none;
        font-size: 0.9rem;
        font-weight: 600;
      }

      .asset-actions a[aria-disabled='true'] {
        pointer-events: none;
        color: var(--muted);
      }

      .file-input {
        position: relative;
        overflow: hidden;
        display: inline-flex;
        align-items: center;
        border-radius: 6px;
        border: 1px dashed var(--panel-border);
        padding: 0;
        cursor: pointer;
        color: var(--accent);
        background: transparent;
      }

      .file-input span {
        display: inline-block;
        padding: 6px 10px;
        font-size: 0.9rem;
        font-weight: 600;
      }

      .file-input:hover {
        border-color: var(--accent);
      }

      .file-input input[type='file'] {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }

      .actions-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: flex-end;
        margin-top: 12px;
      }

      .actions-row label.inline {
        display: inline-flex;
        flex-direction: column;
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .actions-row label.inline select,
      .actions-row label.inline input {
        margin-top: 4px;
        min-width: 120px;
      }

      #asset-section {
        margin-top: 16px;
      }

      #settings-form fieldset {
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 16px;
        margin: 0 0 16px;
      }

      #settings-form fieldset:last-of-type {
        margin-bottom: 0;
      }

      #settings-form legend {
        font-weight: 600;
        color: var(--muted);
        padding: 0 6px;
      }

      #settings-form .field-inline {
        display: flex;
        flex-direction: column;
        margin-bottom: 12px;
      }

      #settings-form .field-inline:last-child {
        margin-bottom: 0;
      }

      #settings-form .field-inline.gpu-support {
        flex-direction: row;
        align-items: center;
        gap: 16px;
      }

      .field-help {
        font-size: 0.85rem;
        color: var(--muted);
        margin: 6px 0 0;
      }

      .archive-controls {
        flex-direction: row;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .archive-controls label.inline {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .archive-controls select {
        min-width: 180px;
      }

      .gpu-support-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
      }

      #settings-whisper-gpu-status {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
      }

      #settings-whisper-gpu-test {
        white-space: nowrap;
      }

      @media (max-width: 960px) {
        main.layout {
          flex-direction: column;
          padding: 16px;
        }

        .sidebar {
          width: auto;
        }

        .curriculum {
          max-height: 320px;
        }
      }
    </style>
  </head>
  <body>
    <div id="status-bar" class="status-bar" role="status">
      <div id="status-bar-message" class="status-message"></div>
      <div id="status-bar-progress" class="status-progress" hidden>
        <div class="status-progress-track">
          <div id="status-bar-progress-fill" class="status-progress-fill"></div>
        </div>
        <span id="status-bar-progress-text" class="status-progress-text"></span>
      </div>
    </div>
    <main class="layout">
      <aside class="sidebar">
        <section class="panel">
          <h1 data-i18n="sidebar.heading">Lecture Tools</h1>
          <p data-i18n="sidebar.tagline">Review, organise, and process lecture resources quickly.</p>
        </section>
        <section class="panel">
          <h2 data-i18n="sidebar.overview">Overview</h2>
          <dl id="stats" class="stats-grid"></dl>
        </section>
        <section class="panel">
          <div class="panel-heading">
            <h2 data-i18n="sidebar.syllabusTitle">Course syllabus</h2>
          </div>
          <label
            class="sr-only"
            for="search-input"
            data-i18n="sidebar.searchLabel"
          >
            Search syllabus
          </label>
          <input
            id="search-input"
            type="search"
            placeholder="Search by name"
            data-i18n="sidebar.searchPlaceholder"
            data-i18n-attr="placeholder"
            autocomplete="off"
          />
          <div id="curriculum" class="curriculum">
            <div class="placeholder" data-i18n="sidebar.loading">Loading…</div>
          </div>
        </section>
      </aside>
      <section class="content">
        <section class="panel content-panel">
          <div class="top-bar" role="tablist">
            <div class="top-bar-left">
              <button
                type="button"
                class="active"
                data-view="details"
                aria-pressed="true"
                data-i18n="topBar.details"
              >
                Details
              </button>
              <button
                id="toggle-edit-mode"
                type="button"
                class="ghost pill"
                aria-pressed="false"
                data-i18n="topBar.enableEdit"
              >
                Enable edit mode
              </button>
            </div>
            <div class="top-bar-right">
              <button
                type="button"
                data-view="create"
                aria-pressed="false"
                data-i18n="topBar.create"
              >
                Create
              </button>
              <button
                type="button"
                class="ghost"
                data-view="storage"
                aria-pressed="false"
                data-i18n="topBar.storage"
              >
                Storage
              </button>
              <button
                type="button"
                data-view="settings"
                aria-pressed="false"
                data-i18n="topBar.settings"
              >
                Settings
              </button>
            </div>
          </div>
          <div id="view-details" class="view active" data-view="details">
            <header style="display: flex; justify-content: space-between; align-items: center;">
              <h2 data-i18n="details.title">Lecture details</h2>
              <button
                id="delete-lecture"
                class="danger"
                type="button"
                hidden
                data-i18n="details.deleteLecture"
              >
                Delete lecture
              </button>
            </header>
            <div id="edit-mode-banner" class="edit-banner" hidden data-i18n="details.editModeBanner">
              Edit mode is enabled. Update lecture information or remove items while it is active.
            </div>
            <div id="lecture-summary" class="placeholder" data-i18n="details.summaryPlaceholder">
              Select a lecture from the curriculum.
            </div>
            <form id="lecture-edit-form" hidden>
              <div class="field">
                <label for="edit-lecture-name" data-i18n="details.edit.titleLabel">Title</label>
                <input id="edit-lecture-name" name="name" type="text" required />
              </div>
              <div class="field">
                <label for="edit-lecture-module" data-i18n="details.edit.moduleLabel">Module</label>
                <select id="edit-lecture-module" name="module" required></select>
              </div>
              <div class="field">
                <label
                  for="edit-lecture-description"
                  data-i18n="details.edit.descriptionLabel"
                >
                  Description
                </label>
                <textarea
                  id="edit-lecture-description"
                  name="description"
                  rows="4"
                ></textarea>
              </div>
              <div class="form-actions">
                <button type="submit" data-i18n="details.edit.save">Save changes</button>
              </div>
            </form>
            <section id="asset-section" hidden>
              <h3 data-i18n="assets.title">Assets</h3>
              <ul id="asset-list" class="asset-list"></ul>
              <div class="actions-row">
                <button id="transcribe-button" type="button" data-i18n="assets.transcribe">
                  Transcribe audio
                </button>
                <label class="inline" for="transcribe-model" style="margin-left: auto;" data-i18n="assets.modelLabel">
                  Model
                  <select id="transcribe-model">
                    <option value="tiny" data-i18n="assets.model.tiny">tiny</option>
                    <option value="base" selected data-i18n="assets.model.base">base</option>
                    <option value="small" data-i18n="assets.model.small">small</option>
                    <option value="medium" data-i18n="assets.model.medium">medium</option>
                    <option value="large" data-i18n="assets.model.large">large</option>
                    <option value="gpu" class="gpu-only" disabled data-i18n="assets.model.gpu">
                      GPU (hardware accelerated)
                    </option>
                  </select>
                </label>
              </div>
            </section>
          </div>
          <div id="view-create" class="view" data-view="create" hidden>
            <h2 data-i18n="create.title">Create lecture</h2>
            <form id="lecture-create-form">
              <div class="field">
                <label for="create-module" data-i18n="create.moduleLabel">Module</label>
                <select id="create-module" required></select>
              </div>
              <div class="field">
                <label for="create-name" data-i18n="create.titleLabel">Title</label>
                <input id="create-name" type="text" required />
              </div>
              <div class="field">
                <label for="create-description" data-i18n="create.descriptionLabel">Description</label>
                <textarea id="create-description" rows="4"></textarea>
              </div>
              <div class="form-actions">
                <button id="create-submit" type="submit" data-i18n="create.submit">
                  Add lecture
                </button>
              </div>
            </form>
          </div>
          <div id="view-storage" class="view" data-view="storage" hidden>
            <div class="storage-page">
              <div class="storage-header">
                <div>
                  <h2 data-i18n="storage.title">Storage manager</h2>
                  <p id="storage-path" class="storage-path" data-i18n="storage.subtitle"></p>
                </div>
                <div class="storage-actions">
                  <button id="storage-refresh" type="button" data-i18n="storage.actions.refresh">
                    Refresh
                  </button>
                  <button
                    id="storage-purge"
                    type="button"
                    class="danger"
                    data-i18n="storage.actions.purge"
                  >
                    Remove processed audio
                  </button>
                </div>
              </div>
              <section class="storage-usage" aria-live="polite">
                <div class="storage-usage-item">
                  <span class="storage-usage-label" data-i18n="storage.usage.used">Used</span>
                  <span id="storage-used" class="storage-usage-value">--</span>
                </div>
                <div class="storage-usage-item">
                  <span class="storage-usage-label" data-i18n="storage.usage.available">Available</span>
                  <span id="storage-available" class="storage-usage-value">--</span>
                </div>
                <div class="storage-usage-item">
                  <span class="storage-usage-label" data-i18n="storage.usage.total">Total</span>
                  <span id="storage-total" class="storage-usage-value">--</span>
                </div>
              </section>
              <p
                id="storage-purge-summary"
                class="storage-purge-summary"
                data-i18n="storage.purge.none"
              ></p>
              <div id="storage-loading" class="storage-loading" hidden data-i18n="storage.loading">
                Loading…
              </div>
              <div id="storage-empty" class="storage-empty" hidden data-i18n="storage.empty">
                No stored classes found.
              </div>
              <div id="storage-class-wrapper" class="storage-class-wrapper" hidden>
                <ul id="storage-class-list" class="storage-class-list"></ul>
              </div>
            </div>
          </div>
          <div id="view-settings" class="view" data-view="settings" hidden>
            <h2 data-i18n="settings.title">Settings</h2>
            <form id="settings-form">
              <fieldset>
                <legend data-i18n="settings.appearance.legend">Appearance</legend>
                <div class="field-inline">
                  <label for="settings-theme" data-i18n="settings.appearance.themeLabel">Theme</label>
                  <select id="settings-theme">
                    <option value="system" data-i18n="settings.appearance.theme.system">Follow system</option>
                    <option value="light" data-i18n="settings.appearance.theme.light">Light</option>
                    <option value="dark" data-i18n="settings.appearance.theme.dark">Dark</option>
                  </select>
                </div>
                <div class="field-inline">
                  <label for="settings-language" data-i18n="settings.language.label">Language</label>
                  <select id="settings-language">
                    <option value="en" data-i18n="settings.language.choices.en">English</option>
                    <option value="zh" data-i18n="settings.language.choices.zh">中文 (Chinese)</option>
                    <option value="es" data-i18n="settings.language.choices.es">Español (Spanish)</option>
                    <option value="fr" data-i18n="settings.language.choices.fr">Français (French)</option>
                  </select>
                </div>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.whisper.legend">Whisper transcription</legend>
                <div class="field-inline">
                  <label for="settings-whisper-model" data-i18n="settings.whisper.modelLabel">
                    Default model
                  </label>
                  <select id="settings-whisper-model" required>
                    <option value="tiny" data-i18n="settings.whisper.model.tiny">Tiny (fastest)</option>
                    <option value="base" selected data-i18n="settings.whisper.model.base">
                      Base (balanced)
                    </option>
                    <option value="small" data-i18n="settings.whisper.model.small">
                      Small (accurate)
                    </option>
                    <option value="medium" data-i18n="settings.whisper.model.medium">
                      Medium (detailed)
                    </option>
                    <option value="large" data-i18n="settings.whisper.model.large">
                      Large (maximum accuracy)
                    </option>
                    <option value="gpu" class="gpu-only" disabled data-i18n="settings.whisper.model.gpu">
                      GPU (hardware accelerated)
                    </option>
                  </select>
                </div>
                <div class="field-inline">
                  <label for="settings-whisper-compute" data-i18n="settings.whisper.computeLabel">
                    Compute type
                  </label>
                  <input id="settings-whisper-compute" type="text" required />
                </div>
                <div class="field-inline">
                  <label for="settings-whisper-beam" data-i18n="settings.whisper.beamLabel">
                    Beam size
                  </label>
                  <input id="settings-whisper-beam" type="number" min="1" max="10" required />
                </div>
                <div class="field-inline gpu-support">
                  <div class="gpu-support-info">
                    <label data-i18n="settings.whisper.gpu.label">GPU support</label>
                    <p id="settings-whisper-gpu-status" data-i18n="settings.whisper.gpu.status">
                      GPU acceleration not tested.
                    </p>
                  </div>
                  <button id="settings-whisper-gpu-test" type="button" class="secondary">
                    <span data-i18n="settings.whisper.gpu.test">Test support</span>
                  </button>
                </div>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.slides.legend">Slides</legend>
                <div class="field-inline">
                  <label for="settings-slide-dpi" data-i18n="settings.slides.dpiLabel">
                    Rendering DPI
                  </label>
                  <select id="settings-slide-dpi" required>
                    <option value="150" data-i18n="settings.slides.dpi.150">150 dpi (fastest)</option>
                    <option value="200" selected data-i18n="settings.slides.dpi.200">
                      200 dpi (balanced)
                    </option>
                    <option value="300" data-i18n="settings.slides.dpi.300">
                      300 dpi (detailed)
                    </option>
                    <option value="400" data-i18n="settings.slides.dpi.400">
                      400 dpi (high detail)
                    </option>
                    <option value="600" data-i18n="settings.slides.dpi.600">
                      600 dpi (maximum)
                    </option>
                  </select>
                </div>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.archive.legend">Archive</legend>
                <p class="field-help" data-i18n="settings.archive.description">
                  Export your lectures and assets or import an archive from another machine.
                </p>
                <div class="field-inline archive-controls">
                  <button id="settings-export" type="button" class="secondary" data-i18n="settings.archive.export">
                    Export archive
                  </button>
                  <label class="file-input">
                    <span data-i18n="settings.archive.import">Import archive</span>
                    <input id="settings-import" type="file" accept=".zip" />
                  </label>
                  <label class="inline" for="settings-import-mode" data-i18n="settings.archive.modeLabel">
                    Import mode
                    <select id="settings-import-mode">
                      <option value="merge" data-i18n="settings.archive.modes.merge">Merge with existing</option>
                      <option value="replace" data-i18n="settings.archive.modes.replace">Replace existing data</option>
                    </select>
                  </label>
                </div>
                <p class="field-help" data-i18n="settings.archive.hint">
                  Exported archives are stored temporarily and cleared when the app starts.
                </p>
              </fieldset>
              <div class="form-actions">
                <button type="submit" data-i18n="settings.save">Save settings</button>
              </div>
              <div class="form-actions">
                <button id="settings-exit-app" type="button" class="danger" data-i18n="settings.exit">
                  Exit application
                </button>
              </div>
            </form>
          </div>
        </section>
      </section>
    </main>
    <div id="dialog-root" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="dialog-backdrop" class="dialog-backdrop"></div>
      <div
        id="dialog-window"
        class="dialog-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="dialog-title"
        aria-describedby="dialog-message"
      >
        <div class="dialog-header">
          <h2 id="dialog-title" class="dialog-title"></h2>
        </div>
        <div id="dialog-message" class="dialog-message"></div>
        <div id="dialog-input-wrapper" class="dialog-input-wrapper hidden">
          <input id="dialog-input" class="dialog-input" type="text" autocomplete="off" />
        </div>
        <div class="dialog-actions">
          <button
            type="button"
            id="dialog-cancel"
            class="dialog-button secondary"
            data-i18n="dialog.cancel"
          >
            Cancel
          </button>
          <button
            type="button"
            id="dialog-confirm"
            class="dialog-button primary"
            data-i18n="dialog.confirm"
          >
            Confirm
          </button>
        </div>
      </div>
    </div>
    <script>
      (async function () {
        const translations = {
          en: {
            document: {
              title: 'Lecture Tools',
            },
            sidebar: {
              heading: 'Lecture Tools',
              tagline: 'Review, organise, and process lecture resources quickly.',
              overview: 'Overview',
              syllabusTitle: 'Course syllabus',
              searchLabel: 'Search the syllabus',
              searchPlaceholder: 'Search by name',
              loading: 'Loading…',
            },
            topBar: {
              details: 'Details',
              enableEdit: 'Enable edit mode',
              exitEdit: 'Exit edit mode',
              create: 'Create',
              storage: 'Storage',
              settings: 'Settings',
            },
            details: {
              title: 'Lecture details',
              deleteLecture: 'Delete lecture',
              editModeBanner:
                'Edit mode is enabled. Update lecture information or remove items while it is active.',
              summaryPlaceholder: 'Select a lecture from the curriculum.',
              edit: {
                titleLabel: 'Title',
                moduleLabel: 'Module',
                descriptionLabel: 'Description',
                save: 'Save changes',
              },
              noDescription: 'No description recorded yet.',
            },
            assets: {
              title: 'Assets',
              transcribe: 'Transcribe audio',
              modelLabel: 'Model',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU (hardware accelerated)',
              },
              labels: {
                audio: 'Audio',
                slides: 'Slides (PDF)',
                transcript: 'Transcript',
                notes: 'Notes',
                slideImages: 'Slide images (ZIP)',
              },
              status: {
                notLinked: 'Not linked',
                slidesHint: 'Upload a PDF to generate slide images automatically.',
                noSlideImages: 'No slide images generated yet.',
                linked: 'Linked: {{name}}',
                linkedSlides: 'Linked: {{name}} (auto processed)',
                archiveCreated: 'Archive created: {{name}}',
              },
              actions: {
                upload: 'Upload',
                open: 'Open',
                revealFolder: 'Reveal folder',
                revealLocation: 'Reveal location',
              },
            },
            create: {
              title: 'Create lecture',
              moduleLabel: 'Module',
              titleLabel: 'Title',
              descriptionLabel: 'Description',
              submit: 'Add lecture',
            },
            settings: {
              title: 'Settings',
              appearance: {
                legend: 'Appearance',
                themeLabel: 'Theme',
                theme: {
                  system: 'Follow system',
                  light: 'Light',
                  dark: 'Dark',
                },
              },
              language: {
                label: 'Language',
                choices: {
                  en: 'English',
                  zh: '中文 (Chinese)',
                  es: 'Español (Spanish)',
                  fr: 'Français (French)',
                },
              },
              whisper: {
                legend: 'Whisper transcription',
                modelLabel: 'Default model',
                model: {
                  tiny: 'Tiny (fastest)',
                  base: 'Base (balanced)',
                  small: 'Small (accurate)',
                  medium: 'Medium (detailed)',
                  large: 'Large (maximum accuracy)',
                  gpu: 'GPU (hardware accelerated)',
                },
                computeLabel: 'Compute type',
                beamLabel: 'Beam size',
                gpu: {
                  label: 'GPU support',
                  status: 'GPU acceleration not tested.',
                  test: 'Test support',
                  retry: 'Re-run test',
                },
              },
              slides: {
                legend: 'Slides',
                dpiLabel: 'Rendering DPI',
                dpi: {
                  150: '150 dpi (fastest)',
                  200: '200 dpi (balanced)',
                  300: '300 dpi (detailed)',
                  400: '400 dpi (high detail)',
                  600: '600 dpi (maximum)',
                },
              },
              archive: {
                legend: 'Archive',
                description:
                  'Export your lectures and assets or import an archive from another machine.',
                export: 'Export archive',
                import: 'Import archive',
                modeLabel: 'Import mode',
                modes: {
                  merge: 'Merge with existing',
                  replace: 'Replace existing data',
                },
                hint: 'Exported archives are stored temporarily and cleared when the app starts.',
              },
              save: 'Save settings',
              exit: 'Exit application',
            },
            storage: {
              title: 'Storage manager',
              subtitle: 'Review stored assets by class hierarchy.',
              loading: 'Loading…',
              empty: 'No stored classes found.',
              usage: {
                used: 'Used',
                available: 'Available',
                total: 'Total',
              },
              actions: {
                refresh: 'Refresh',
                purge: 'Remove processed audio',
              },
              purge: {
                none: 'No processed audio to remove.',
                available: '{{count}} {{lectureWord}} ready for cleanup.',
                working: 'Removing audio…',
                readyCount: '{{count}} {{lectureWord}} ready for cleanup',
              },
              classes: {
                summary: '{{moduleCount}} {{moduleWord}} • {{lectureCount}} {{lectureWord}}',
                empty: 'No modules stored for this class yet.',
              },
              modules: {
                summary: '{{lectureCount}} {{lectureWord}}',
                empty: 'No lectures stored for this module yet.',
              },
              lecture: {
                audio: 'Audio',
                transcript: 'Transcript',
                notes: 'Notes',
                slides: 'Slides',
                empty: 'No linked assets.',
                eligible: 'Audio ready for removal',
              },
              dialogs: {
                purgeTitle: 'Remove processed audio',
                purgeMessage:
                  'Delete audio files for {{count}} {{lectureWord}} that already have transcripts? This cannot be undone.',
              },
              unnamedClass: 'Untitled class',
              unnamedModule: 'Untitled module',
              unnamedLecture: 'Untitled lecture',
            },
            dialog: {
              cancel: 'Cancel',
              confirm: 'Confirm',
            },
            stats: {
              classes: 'Classes',
              modules: 'Modules',
              lectures: 'Lectures',
              transcripts: 'Transcripts',
              slideDecks: 'Slide decks',
              audio: 'Audio files',
              notes: 'Notes',
              slideArchives: 'Slide archives',
            },
            dialogs: {
              createClass: {
                title: 'Create class',
                message: 'Enter a class name.',
                placeholder: 'Introduction to Astronomy',
              },
              createModule: {
                title: 'Create module',
                message: 'Module name for {{className}}',
                placeholder: 'Foundations',
              },
              createLecture: {
                title: 'Create lecture',
                message: 'Lecture title for {{context}}',
                placeholder: 'Lecture title',
              },
              lectureDescription: {
                title: 'Lecture description',
                placeholder: 'Add a short outline…',
              },
              deleteClass: {
                title: 'Delete class',
                message: 'Delete class "{{className}}"?',
                cancel: 'Keep class',
                summary: 'This will remove {{moduleCount}} {{moduleWord}} and {{lectureCount}} {{lectureWord}}.',
              },
              deleteModule: {
                title: 'Delete module',
                message: 'Delete module "{{moduleName}}"{{classContext}}?',
                cancel: 'Keep module',
                summary: 'This will remove {{lectureCount}} {{lectureWord}}.',
                classContext: ' from "{{className}}"',
              },
              deleteLecture: {
                title: 'Delete lecture',
                message: 'Delete lecture "{{context}}" and all linked assets?',
                cancel: 'Keep lecture',
              },
              confirmDeletion: {
                title: 'Confirm deletion',
                message: 'This action cannot be undone. Do you want to permanently remove it?',
                confirm: 'Yes, delete it',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: 'Exit application',
                message: 'Stop the Lecture Tools server and close this tab?',
              },
              descriptionOptional: 'Description (optional)',
              descriptionPlaceholder: 'Add a short summary…',
            },
            dropdowns: {
              selectModule: 'Select module…',
              noModules: 'No modules available',
            },
            placeholders: {
              noLectures: 'No lectures',
              noLecturesFilter: 'No lectures match the current filter.',
              noClasses: 'No classes available yet.',
              noModules: 'No modules yet.',
            },
            curriculum: {
              addClass: 'Add class',
              addModule: 'Add module',
              manageHeading: 'Manage syllabus',
              classMeta: '{{moduleCount}} {{moduleWord}} • {{lectureCount}} {{lectureWord}}',
              moduleMeta: '{{lectureCount}} {{lectureWord}}',
            },
            common: {
              actions: {
                create: 'Create',
                save: 'Save',
                skip: 'Skip',
                delete: 'Delete',
                open: 'Open',
                upload: 'Upload',
                exit: 'Exit',
                close: 'Close',
                ok: 'OK',
              },
            },
            status: {
              requireEdit: 'Enable edit mode to manage the curriculum.',
              requireEditLecture: 'Enable edit mode to update lecture details.',
              classCreated: 'Class created.',
              classRemoved: 'Class removed.',
              moduleCreated: 'Module created.',
              moduleRemoved: 'Module removed.',
              lectureCreated: 'Lecture created.',
              lectureRemoved: 'Lecture removed.',
              lectureUpdated: 'Lecture updated.',
              lectureTitleRequired: 'Lecture title is required.',
              createLectureRequirements: 'Select a module and enter a title.',
              slidesProcessed: 'Slides uploaded and processed into an image archive.',
              assetUploaded: 'Asset uploaded successfully.',
              openingFolder: 'Opening folder in your file manager.',
              openingLocation: 'Opening asset location in your file manager.',
              transcriptionPreparing: '====> Preparing transcription…',
              transcriptionCompleted: 'Transcription completed.',
              processing: 'Processing…',
              storageLoadFailed: 'Unable to load storage contents.',
              storageUsageFailed: 'Unable to load storage usage.',
              storagePurged: 'Removed processed audio files.',
              storagePurgeFailed: 'Unable to remove processed audio files.',
              gpuChecking: '====> Checking GPU Whisper support…',
              gpuConfirmed: 'GPU Whisper support confirmed.',
              gpuUnavailable: 'GPU acceleration is unavailable on this platform.',
              gpuUnsupported: 'GPU Whisper is not supported on this platform.',
              gpuNotAvailable: 'GPU acceleration is not available on this platform.',
              shuttingDown: 'Shutting down application…',
              settingsSaved: 'Settings saved.',
              gpuFallback: 'Falling back to {{model}} model.',
              lectureReordered: 'Lecture order updated.',
              exporting: 'Preparing archive…',
              exportReady: 'Archive ready to download.',
              exportFailed: 'Unable to create archive.',
              importing: 'Importing archive…',
              importSuccess: 'Imported {{count}} lectures.',
              importNoChanges: 'Archive imported (no new lectures).',
            },
            counts: {
              module: { one: 'module', other: 'modules' },
              lecture: { one: 'lecture', other: 'lectures' },
            },
          },
          zh: {
            document: {
              title: '课堂助手',
            },
            sidebar: {
              heading: '课堂助手',
              tagline: '快速审阅、整理并处理课程资源。',
              overview: '概览',
              syllabusTitle: '课程大纲',
              searchLabel: '搜索课程大纲',
              searchPlaceholder: '按名称搜索',
              loading: '正在加载…',
            },
            topBar: {
              details: '详情',
              enableEdit: '开启编辑模式',
              exitEdit: '退出编辑模式',
              create: '新建',
              storage: '存储',
              settings: '设置',
            },
            details: {
              title: '讲座详情',
              deleteLecture: '删除讲座',
              editModeBanner: '编辑模式已开启，可更新讲座信息或移除项目。',
              summaryPlaceholder: '从课程表中选择一个讲座。',
              edit: {
                titleLabel: '标题',
                moduleLabel: '模块',
                descriptionLabel: '描述',
                save: '保存更改',
              },
              noDescription: '尚未记录描述。',
            },
            assets: {
              title: '资源',
              transcribe: '转录音频',
              modelLabel: '模型',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU（硬件加速）',
              },
              labels: {
                audio: '音频',
                slides: '课件（PDF）',
                transcript: '逐字稿',
                notes: '笔记',
                slideImages: '课件图像（ZIP）',
              },
              status: {
                notLinked: '未关联',
                slidesHint: '上传 PDF 可自动生成课件图像。',
                noSlideImages: '尚未生成课件图像。',
                linked: '已关联：{{name}}',
                linkedSlides: '已关联：{{name}}（自动处理）',
                archiveCreated: '已生成压缩包：{{name}}',
              },
              actions: {
                upload: '上传',
                open: '打开',
                revealFolder: '在文件夹中显示',
                revealLocation: '显示文件位置',
              },
            },
            create: {
              title: '创建讲座',
              moduleLabel: '模块',
              titleLabel: '标题',
              descriptionLabel: '描述',
              submit: '添加讲座',
            },
            settings: {
              title: '设置',
              appearance: {
                legend: '外观',
                themeLabel: '主题',
                theme: {
                  system: '跟随系统',
                  light: '浅色',
                  dark: '深色',
                },
              },
              language: {
                label: '语言',
                choices: {
                  en: 'English（英语）',
                  zh: '中文（简体）',
                  es: 'Español（西班牙语）',
                  fr: 'Français（法语）',
                },
              },
              whisper: {
                legend: 'Whisper 转录',
                modelLabel: '默认模型',
                model: {
                  tiny: 'Tiny（最快）',
                  base: 'Base（均衡）',
                  small: 'Small（更准）',
                  medium: 'Medium（细致）',
                  large: 'Large（最高准确度）',
                  gpu: 'GPU（硬件加速）',
                },
                computeLabel: '计算类型',
                beamLabel: '束搜索宽度',
                gpu: {
                  label: 'GPU 支持',
                  status: '尚未测试 GPU 加速。',
                  test: '测试支持',
                  retry: '重新测试',
                },
              },
              slides: {
                legend: '课件',
                dpiLabel: '渲染 DPI',
                dpi: {
                  150: '150 dpi（最快）',
                  200: '200 dpi（均衡）',
                  300: '300 dpi（更细致）',
                  400: '400 dpi（高细节）',
                  600: '600 dpi（最高）',
                },
              },
              archive: {
                legend: '归档',
                description: '导出讲座及资源，或从其他设备导入归档文件。',
                export: '导出归档',
                import: '导入归档',
                modeLabel: '导入模式',
                modes: {
                  merge: '与现有内容合并',
                  replace: '替换现有数据',
                },
                hint: '导出的归档会临时保存，并在应用启动时清理。',
              },
              save: '保存设置',
              exit: '退出应用',
            },
            storage: {
              title: '存储管理器',
              subtitle: '按课堂结构查看存储的资源。',
              loading: '正在加载…',
              empty: '没有检测到存储的班级。',
              usage: {
                used: '已用',
                available: '可用',
                total: '总计',
              },
              actions: {
                refresh: '刷新',
                purge: '移除已处理的音频',
              },
              purge: {
                none: '没有可移除的音频。',
                available: '有 {{count}} 个{{lectureWord}}可清理。',
                working: '正在移除音频…',
                readyCount: '{{count}} 个{{lectureWord}}可清理',
              },
              classes: {
                summary: '{{moduleCount}} 个{{moduleWord}} • {{lectureCount}} 个{{lectureWord}}',
                empty: '该班级暂无存储的模块。',
              },
              modules: {
                summary: '{{lectureCount}} 个{{lectureWord}}',
                empty: '该模块暂无存储的讲座。',
              },
              lecture: {
                audio: '音频',
                transcript: '逐字稿',
                notes: '笔记',
                slides: '课件',
                empty: '尚未关联资源。',
                eligible: '音频可安全移除',
              },
              dialogs: {
                purgeTitle: '移除已处理的音频',
                purgeMessage: '确认删除 {{count}} 个已生成逐字稿的{{lectureWord}}音频文件？此操作无法撤销。',
              },
              unnamedClass: '未命名班级',
              unnamedModule: '未命名模块',
              unnamedLecture: '未命名讲座',
            },
            dialog: {
              cancel: '取消',
              confirm: '确认',
            },
            stats: {
              classes: '课程',
              modules: '模块',
              lectures: '讲座',
              transcripts: '逐字稿',
              slideDecks: '课件',
              audio: '音频文件',
              notes: '笔记',
              slideArchives: '课件压缩包',
            },
            dialogs: {
              createClass: {
                title: '创建课程',
                message: '输入课程名称。',
                placeholder: '天文学导论',
              },
              createModule: {
                title: '创建模块',
                message: '为 {{className}} 输入模块名称',
                placeholder: '基础内容',
              },
              createLecture: {
                title: '创建讲座',
                message: '为 {{context}} 输入讲座标题',
                placeholder: '讲座标题',
              },
              lectureDescription: {
                title: '讲座描述',
                placeholder: '添加简短大纲…',
              },
              deleteClass: {
                title: '删除课程',
                message: '删除课程“{{className}}”？',
                cancel: '保留课程',
                summary: '此操作将移除 {{moduleCount}} 个{{moduleWord}}和 {{lectureCount}} 个{{lectureWord}}。',
              },
              deleteModule: {
                title: '删除模块',
                message: '删除模块“{{moduleName}}”{{classContext}}？',
                cancel: '保留模块',
                summary: '此操作将移除 {{lectureCount}} 个{{lectureWord}}。',
                classContext: '（来自课程“{{className}}”）',
              },
              deleteLecture: {
                title: '删除讲座',
                message: '删除讲座“{{context}}”及其所有关联资源？',
                cancel: '保留讲座',
              },
              confirmDeletion: {
                title: '确认删除',
                message: '该操作无法撤销，确定要永久删除吗？',
                confirm: '是，删除',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: '退出应用',
                message: '停止 Lecture Tools 服务器并关闭此标签页？',
              },
              descriptionOptional: '描述（可选）',
              descriptionPlaceholder: '添加简短摘要…',
            },
            dropdowns: {
              selectModule: '选择模块…',
              noModules: '暂无可用模块',
            },
            placeholders: {
              noLectures: '暂无讲座',
              noLecturesFilter: '没有符合当前筛选条件的讲座。',
              noClasses: '尚未有课程。',
              noModules: '暂无模块。',
            },
            curriculum: {
              addClass: '添加课程',
              addModule: '添加模块',
              manageHeading: '管理课程大纲',
              classMeta: '{{moduleCount}} 个{{moduleWord}} • {{lectureCount}} 个{{lectureWord}}',
              moduleMeta: '{{lectureCount}} 个{{lectureWord}}',
            },
            common: {
              actions: {
                create: '创建',
                save: '保存',
                skip: '跳过',
                delete: '删除',
                open: '打开',
                upload: '上传',
                exit: '退出',
                close: '关闭',
                ok: '好的',
              },
            },
            status: {
              requireEdit: '开启编辑模式以管理课程表。',
              requireEditLecture: '开启编辑模式以更新讲座详情。',
              classCreated: '课程已创建。',
              classRemoved: '课程已删除。',
              moduleCreated: '模块已创建。',
              moduleRemoved: '模块已删除。',
              lectureCreated: '讲座已创建。',
              lectureRemoved: '讲座已删除。',
              lectureUpdated: '讲座已更新。',
              lectureTitleRequired: '需要填写讲座标题。',
              createLectureRequirements: '请选择模块并输入标题。',
              slidesProcessed: '课件已上传并转换为图像压缩包。',
              assetUploaded: '资源上传成功。',
              openingFolder: '正在文件管理器中打开文件夹。',
              openingLocation: '正在文件管理器中显示资源位置。',
              transcriptionPreparing: '====> 正在准备转录…',
              transcriptionCompleted: '转录完成。',
              processing: '处理中…',
              storageLoadFailed: '无法加载存储内容。',
              storageUsageFailed: '无法加载存储用量。',
              storagePurged: '已移除处理完成的音频。',
              storagePurgeFailed: '无法移除已处理的音频。',
              gpuChecking: '====> 正在检查 GPU Whisper 支持…',
              gpuConfirmed: 'GPU Whisper 支持已确认。',
              gpuUnavailable: '此平台不支持 GPU 加速。',
              gpuUnsupported: '此平台不支持 GPU Whisper。',
              gpuNotAvailable: '此平台无法使用 GPU 加速。',
              shuttingDown: '正在关闭应用…',
              settingsSaved: '设置已保存。',
              gpuFallback: '将回退到 {{model}} 模型。',
              lectureReordered: '课程顺序已更新。',
              exporting: '正在准备归档…',
              exportReady: '归档已生成，可供下载。',
              exportFailed: '无法创建归档。',
              importing: '正在导入归档…',
              importSuccess: '已导入 {{count}} 个讲座。',
              importNoChanges: '归档导入完成（没有新讲座）。',
            },
            counts: {
              module: { one: '模块', other: '模块' },
              lecture: { one: '讲座', other: '讲座' },
            },
          },
          es: {
            document: {
              title: 'Herramientas de clases',
            },
            sidebar: {
              heading: 'Herramientas de clases',
              tagline: 'Revisa, organiza y procesa recursos de clases rápidamente.',
              overview: 'Resumen',
              syllabusTitle: 'Programa del curso',
              searchLabel: 'Buscar en el programa',
              searchPlaceholder: 'Buscar por nombre',
              loading: 'Cargando…',
            },
            topBar: {
              details: 'Detalles',
              enableEdit: 'Activar modo edición',
              exitEdit: 'Salir del modo edición',
              create: 'Crear',
              storage: 'Almacenamiento',
              settings: 'Configuración',
            },
            details: {
              title: 'Detalles de la clase',
              deleteLecture: 'Eliminar clase',
              editModeBanner: 'El modo edición está activo. Actualiza o elimina elementos mientras esté activo.',
              summaryPlaceholder: 'Selecciona una clase del plan de estudios.',
              edit: {
                titleLabel: 'Título',
                moduleLabel: 'Módulo',
                descriptionLabel: 'Descripción',
                save: 'Guardar cambios',
              },
              noDescription: 'Sin descripción registrada todavía.',
            },
            assets: {
              title: 'Recursos',
              transcribe: 'Transcribir audio',
              modelLabel: 'Modelo',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU (acelerado por hardware)',
              },
              labels: {
                audio: 'Audio',
                slides: 'Diapositivas (PDF)',
                transcript: 'Transcripción',
                notes: 'Notas',
                slideImages: 'Imágenes de diapositivas (ZIP)',
              },
              status: {
                notLinked: 'Sin vincular',
                slidesHint: 'Carga un PDF para generar imágenes automáticamente.',
                noSlideImages: 'Aún no se generan imágenes de diapositivas.',
                linked: 'Vinculado: {{name}}',
                linkedSlides: 'Vinculado: {{name}} (procesado automáticamente)',
                archiveCreated: 'Archivo creado: {{name}}',
              },
              actions: {
                upload: 'Subir',
                open: 'Abrir',
                revealFolder: 'Mostrar carpeta',
                revealLocation: 'Mostrar ubicación',
              },
            },
            create: {
              title: 'Crear clase',
              moduleLabel: 'Módulo',
              titleLabel: 'Título',
              descriptionLabel: 'Descripción',
              submit: 'Agregar clase',
            },
            settings: {
              title: 'Configuración',
              appearance: {
                legend: 'Apariencia',
                themeLabel: 'Tema',
                theme: {
                  system: 'Seguir sistema',
                  light: 'Claro',
                  dark: 'Oscuro',
                },
              },
              language: {
                label: 'Idioma',
                choices: {
                  en: 'English (Inglés)',
                  zh: '中文 (Chino)',
                  es: 'Español',
                  fr: 'Français (Francés)',
                },
              },
              whisper: {
                legend: 'Transcripción Whisper',
                modelLabel: 'Modelo predeterminado',
                model: {
                  tiny: 'Tiny (más rápido)',
                  base: 'Base (equilibrado)',
                  small: 'Small (preciso)',
                  medium: 'Medium (detallado)',
                  large: 'Large (máxima precisión)',
                  gpu: 'GPU (acelerado por hardware)',
                },
                computeLabel: 'Tipo de cómputo',
                beamLabel: 'Tamaño de haz',
                gpu: {
                  label: 'Compatibilidad con GPU',
                  status: 'Aceleración GPU no probada.',
                  test: 'Probar compatibilidad',
                  retry: 'Volver a probar',
                },
              },
              slides: {
                legend: 'Diapositivas',
                dpiLabel: 'DPI de renderizado',
                dpi: {
                  150: '150 dpi (más rápido)',
                  200: '200 dpi (equilibrado)',
                  300: '300 dpi (detallado)',
                  400: '400 dpi (alto detalle)',
                  600: '600 dpi (máximo)',
                },
              },
              archive: {
                legend: 'Archivo',
                description:
                  'Exporta tus clases y recursos o importa un archivo desde otro equipo.',
                export: 'Exportar archivo',
                import: 'Importar archivo',
                modeLabel: 'Modo de importación',
                modes: {
                  merge: 'Combinar con los existentes',
                  replace: 'Reemplazar los datos existentes',
                },
                hint: 'Los archivos exportados se guardan temporalmente y se eliminan al iniciar la aplicación.',
              },
              save: 'Guardar configuración',
              exit: 'Salir de la aplicación',
            },
            storage: {
              title: 'Administrador de almacenamiento',
              subtitle: 'Revisa los recursos almacenados según la estructura de clases.',
              loading: 'Cargando…',
              empty: 'No se encontraron clases con almacenamiento.',
              usage: {
                used: 'En uso',
                available: 'Disponible',
                total: 'Total',
              },
              actions: {
                refresh: 'Actualizar',
                purge: 'Quitar audio procesado',
              },
              purge: {
                none: 'No hay audio procesado para eliminar.',
                available: '{{count}} {{lectureWord}} listos para limpiar.',
                working: 'Eliminando audio…',
                readyCount: '{{count}} {{lectureWord}} listos para limpiar',
              },
              classes: {
                summary: '{{moduleCount}} {{moduleWord}} • {{lectureCount}} {{lectureWord}}',
                empty: 'Esta clase no tiene módulos almacenados.',
              },
              modules: {
                summary: '{{lectureCount}} {{lectureWord}}',
                empty: 'Este módulo no tiene clases almacenadas.',
              },
              lecture: {
                audio: 'Audio',
                transcript: 'Transcripción',
                notes: 'Notas',
                slides: 'Diapositivas',
                empty: 'Sin recursos vinculados.',
                eligible: 'Audio listo para eliminarse',
              },
              dialogs: {
                purgeTitle: 'Quitar audio procesado',
                purgeMessage:
                  '¿Eliminar los archivos de audio de {{count}} {{lectureWord}} que ya tienen transcripción? Esta acción no se puede deshacer.',
              },
              unnamedClass: 'Clase sin nombre',
              unnamedModule: 'Módulo sin nombre',
              unnamedLecture: 'Sesión sin nombre',
            },
            dialog: {
              cancel: 'Cancelar',
              confirm: 'Confirmar',
            },
            stats: {
              classes: 'Cursos',
              modules: 'Módulos',
              lectures: 'Clases',
              transcripts: 'Transcripciones',
              slideDecks: 'Presentaciones',
              audio: 'Archivos de audio',
              notes: 'Notas',
              slideArchives: 'Archivos de diapositivas',
            },
            dialogs: {
              createClass: {
                title: 'Crear curso',
                message: 'Ingresa un nombre de curso.',
                placeholder: 'Introducción a la astronomía',
              },
              createModule: {
                title: 'Crear módulo',
                message: 'Nombre del módulo para {{className}}',
                placeholder: 'Fundamentos',
              },
              createLecture: {
                title: 'Crear clase',
                message: 'Título de la clase para {{context}}',
                placeholder: 'Título de la clase',
              },
              lectureDescription: {
                title: 'Descripción de la clase',
                placeholder: 'Agrega un esquema breve…',
              },
              deleteClass: {
                title: 'Eliminar curso',
                message: '¿Eliminar el curso "{{className}}"?',
                cancel: 'Conservar curso',
                summary: 'Esto eliminará {{moduleCount}} {{moduleWord}} y {{lectureCount}} {{lectureWord}}.',
              },
              deleteModule: {
                title: 'Eliminar módulo',
                message: '¿Eliminar el módulo "{{moduleName}}"{{classContext}}?',
                cancel: 'Conservar módulo',
                summary: 'Esto eliminará {{lectureCount}} {{lectureWord}}.',
                classContext: ' del curso "{{className}}"',
              },
              deleteLecture: {
                title: 'Eliminar clase',
                message: '¿Eliminar la clase "{{context}}" y todos los recursos vinculados?',
                cancel: 'Conservar clase',
              },
              confirmDeletion: {
                title: 'Confirmar eliminación',
                message: 'Esta acción no se puede deshacer. ¿Deseas eliminarla permanentemente?',
                confirm: 'Sí, eliminar',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: 'Salir de la aplicación',
                message: '¿Detener el servidor de Lecture Tools y cerrar esta pestaña?',
              },
              descriptionOptional: 'Descripción (opcional)',
              descriptionPlaceholder: 'Agrega un breve resumen…',
            },
            dropdowns: {
              selectModule: 'Seleccionar módulo…',
              noModules: 'No hay módulos disponibles',
            },
            placeholders: {
              noLectures: 'Sin clases',
              noLecturesFilter: 'Ninguna clase coincide con el filtro actual.',
              noClasses: 'Aún no hay cursos disponibles.',
              noModules: 'Sin módulos por ahora.',
            },
            curriculum: {
              addClass: 'Agregar curso',
              addModule: 'Agregar módulo',
              manageHeading: 'Administrar programa',
              classMeta: '{{moduleCount}} {{moduleWord}} • {{lectureCount}} {{lectureWord}}',
              moduleMeta: '{{lectureCount}} {{lectureWord}}',
            },
            common: {
              actions: {
                create: 'Crear',
                save: 'Guardar',
                skip: 'Omitir',
                delete: 'Eliminar',
                open: 'Abrir',
                upload: 'Subir',
                exit: 'Salir',
                close: 'Cerrar',
                ok: 'Aceptar',
              },
            },
            status: {
              requireEdit: 'Activa el modo edición para gestionar el plan de estudios.',
              requireEditLecture: 'Activa el modo edición para actualizar los detalles.',
              classCreated: 'Curso creado.',
              classRemoved: 'Curso eliminado.',
              moduleCreated: 'Módulo creado.',
              moduleRemoved: 'Módulo eliminado.',
              lectureCreated: 'Clase creada.',
              lectureRemoved: 'Clase eliminada.',
              lectureUpdated: 'Clase actualizada.',
              lectureTitleRequired: 'El título de la clase es obligatorio.',
              createLectureRequirements: 'Selecciona un módulo e ingresa un título.',
              slidesProcessed: 'Diapositivas cargadas y convertidas en un archivo de imágenes.',
              assetUploaded: 'Recurso subido correctamente.',
              openingFolder: 'Abriendo carpeta en tu explorador de archivos.',
              openingLocation: 'Mostrando ubicación del recurso en tu explorador.',
              transcriptionPreparing: '====> Preparando transcripción…',
              transcriptionCompleted: 'Transcripción completada.',
              processing: 'Procesando…',
              storageLoadFailed: 'No se pudieron cargar los contenidos del almacenamiento.',
              storageUsageFailed: 'No se pudo cargar el uso del almacenamiento.',
              storagePurged: 'Audio procesado eliminado.',
              storagePurgeFailed: 'No se pudo eliminar el audio procesado.',
              gpuChecking: '====> Comprobando compatibilidad con GPU Whisper…',
              gpuConfirmed: 'Compatibilidad con GPU Whisper confirmada.',
              gpuUnavailable: 'GPU no disponible en esta plataforma.',
              gpuUnsupported: 'GPU Whisper no es compatible con esta plataforma.',
              gpuNotAvailable: 'La aceleración GPU no está disponible en esta plataforma.',
              shuttingDown: 'Cerrando la aplicación…',
              settingsSaved: 'Configuración guardada.',
              gpuFallback: 'Se usará el modelo {{model}}.',
              lectureReordered: 'El orden de las clases se actualizó.',
              exporting: 'Preparando archivo…',
              exportReady: 'Archivo listo para descargar.',
              exportFailed: 'No se pudo crear el archivo.',
              importing: 'Importando archivo…',
              importSuccess: 'Se importaron {{count}} clases.',
              importNoChanges: 'Archivo importado (sin clases nuevas).',
            },
            counts: {
              module: { one: 'módulo', other: 'módulos' },
              lecture: { one: 'clase', other: 'clases' },
            },
          },
          fr: {
            document: {
              title: 'Outils de cours',
            },
            sidebar: {
              heading: 'Outils de cours',
              tagline: 'Passez en revue, organisez et traitez rapidement les ressources de cours.',
              overview: 'Vue d’ensemble',
              syllabusTitle: 'Plan de cours',
              searchLabel: 'Rechercher dans le plan',
              searchPlaceholder: 'Rechercher par nom',
              loading: 'Chargement…',
            },
            topBar: {
              details: 'Détails',
              enableEdit: 'Activer le mode édition',
              exitEdit: 'Quitter le mode édition',
              create: 'Créer',
              storage: 'Stockage',
              settings: 'Paramètres',
            },
            details: {
              title: 'Détails du cours',
              deleteLecture: 'Supprimer le cours',
              editModeBanner:
                'Le mode édition est activé. Mettez à jour les informations ou supprimez des éléments pendant qu’il est actif.',
              summaryPlaceholder: 'Sélectionnez un cours dans le programme.',
              edit: {
                titleLabel: 'Titre',
                moduleLabel: 'Module',
                descriptionLabel: 'Description',
                save: 'Enregistrer les modifications',
              },
              noDescription: 'Aucune description enregistrée pour le moment.',
            },
            assets: {
              title: 'Ressources',
              transcribe: 'Transcrire l’audio',
              modelLabel: 'Modèle',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU (accélération matérielle)',
              },
              labels: {
                audio: 'Audio',
                slides: 'Diapositives (PDF)',
                transcript: 'Transcription',
                notes: 'Notes',
                slideImages: 'Images de diapositives (ZIP)',
              },
              status: {
                notLinked: 'Non lié',
                slidesHint: 'Importez un PDF pour générer automatiquement des images.',
                noSlideImages: 'Aucune image de diapositive générée pour le moment.',
                linked: 'Lié : {{name}}',
                linkedSlides: 'Lié : {{name}} (traitement automatique)',
                archiveCreated: 'Archive créée : {{name}}',
              },
              actions: {
                upload: 'Importer',
                open: 'Ouvrir',
                revealFolder: 'Afficher le dossier',
                revealLocation: 'Afficher l’emplacement',
              },
            },
            create: {
              title: 'Créer un cours',
              moduleLabel: 'Module',
              titleLabel: 'Titre',
              descriptionLabel: 'Description',
              submit: 'Ajouter le cours',
            },
            settings: {
              title: 'Paramètres',
              appearance: {
                legend: 'Apparence',
                themeLabel: 'Thème',
                theme: {
                  system: 'Suivre le système',
                  light: 'Clair',
                  dark: 'Sombre',
                },
              },
              language: {
                label: 'Langue',
                choices: {
                  en: 'English (Anglais)',
                  zh: '中文 (Chinois)',
                  es: 'Español (Espagnol)',
                  fr: 'Français',
                },
              },
              whisper: {
                legend: 'Transcription Whisper',
                modelLabel: 'Modèle par défaut',
                model: {
                  tiny: 'Tiny (plus rapide)',
                  base: 'Base (équilibré)',
                  small: 'Small (précis)',
                  medium: 'Medium (détaillé)',
                  large: 'Large (précision maximale)',
                  gpu: 'GPU (accélération matérielle)',
                },
                computeLabel: 'Type de calcul',
                beamLabel: 'Taille du faisceau',
                gpu: {
                  label: 'Prise en charge GPU',
                  status: 'Accélération GPU non testée.',
                  test: 'Tester la prise en charge',
                  retry: 'Relancer le test',
                },
              },
              slides: {
                legend: 'Diapositives',
                dpiLabel: 'DPI de rendu',
                dpi: {
                  150: '150 dpi (plus rapide)',
                  200: '200 dpi (équilibré)',
                  300: '300 dpi (détaillé)',
                  400: '400 dpi (très détaillé)',
                  600: '600 dpi (maximum)',
                },
              },
              archive: {
                legend: 'Archive',
                description:
                  'Exportez vos cours et ressources ou importez une archive depuis une autre machine.',
                export: 'Exporter l’archive',
                import: 'Importer une archive',
                modeLabel: 'Mode d’importation',
                modes: {
                  merge: 'Fusionner avec l’existant',
                  replace: 'Remplacer les données existantes',
                },
                hint: 'Les archives exportées sont conservées temporairement et supprimées au démarrage de l’application.',
              },
              save: 'Enregistrer les paramètres',
              exit: 'Quitter l’application',
            },
            storage: {
              title: 'Gestionnaire de stockage',
              subtitle: 'Consultez les ressources stockées selon la structure des cours.',
              loading: 'Chargement…',
              empty: 'Aucune classe stockée trouvée.',
              usage: {
                used: 'Utilisé',
                available: 'Disponible',
                total: 'Total',
              },
              actions: {
                refresh: 'Actualiser',
                purge: 'Supprimer l’audio traité',
              },
              purge: {
                none: 'Aucun audio traité à supprimer.',
                available: '{{count}} {{lectureWord}} prêts à nettoyer.',
                working: 'Suppression des audios…',
                readyCount: '{{count}} {{lectureWord}} prêts à nettoyer',
              },
              classes: {
                summary: '{{moduleCount}} {{moduleWord}} • {{lectureCount}} {{lectureWord}}',
                empty: 'Ce cours n’a pas encore de modules stockés.',
              },
              modules: {
                summary: '{{lectureCount}} {{lectureWord}}',
                empty: 'Ce module n’a pas encore de séances stockées.',
              },
              lecture: {
                audio: 'Audio',
                transcript: 'Transcription',
                notes: 'Notes',
                slides: 'Diapositives',
                empty: 'Aucune ressource liée.',
                eligible: 'Audio prêt à être supprimé',
              },
              dialogs: {
                purgeTitle: 'Supprimer l’audio traité',
                purgeMessage:
                  'Supprimer les fichiers audio de {{count}} {{lectureWord}} déjà transcrites ? Cette action est irréversible.',
              },
              unnamedClass: 'Cours sans nom',
              unnamedModule: 'Module sans nom',
              unnamedLecture: 'Séance sans nom',
            },
            dialog: {
              cancel: 'Annuler',
              confirm: 'Confirmer',
            },
            stats: {
              classes: 'Cours',
              modules: 'Modules',
              lectures: 'Leçons',
              transcripts: 'Transcriptions',
              slideDecks: 'Présentations',
              audio: 'Fichiers audio',
              notes: 'Notes',
              slideArchives: 'Archives de diapositives',
            },
            dialogs: {
              createClass: {
                title: 'Créer un cours',
                message: 'Saisissez le nom du cours.',
                placeholder: 'Introduction à l’astronomie',
              },
              createModule: {
                title: 'Créer un module',
                message: 'Nom du module pour {{className}}',
                placeholder: 'Fondements',
              },
              createLecture: {
                title: 'Créer une leçon',
                message: 'Titre de la leçon pour {{context}}',
                placeholder: 'Titre de la leçon',
              },
              lectureDescription: {
                title: 'Description de la leçon',
                placeholder: 'Ajoutez un court aperçu…',
              },
              deleteClass: {
                title: 'Supprimer le cours',
                message: 'Supprimer le cours « {{className}} » ?',
                cancel: 'Conserver le cours',
                summary: 'Cette action supprimera {{moduleCount}} {{moduleWord}} et {{lectureCount}} {{lectureWord}}.',
              },
              deleteModule: {
                title: 'Supprimer le module',
                message: 'Supprimer le module « {{moduleName}} »{{classContext}} ?',
                cancel: 'Conserver le module',
                summary: 'Cette action supprimera {{lectureCount}} {{lectureWord}}.',
                classContext: ' du cours « {{className}} »',
              },
              deleteLecture: {
                title: 'Supprimer la leçon',
                message: 'Supprimer la leçon « {{context}} » et toutes les ressources associées ?',
                cancel: 'Conserver la leçon',
              },
              confirmDeletion: {
                title: 'Confirmer la suppression',
                message: 'Cette action est irréversible. Souhaitez-vous la supprimer définitivement ?',
                confirm: 'Oui, supprimer',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: 'Quitter l’application',
                message: 'Arrêter le serveur Lecture Tools et fermer cet onglet ?',
              },
              descriptionOptional: 'Description (optionnel)',
              descriptionPlaceholder: 'Ajoutez un court résumé…',
            },
            dropdowns: {
              selectModule: 'Sélectionner un module…',
              noModules: 'Aucun module disponible',
            },
            placeholders: {
              noLectures: 'Aucune leçon',
              noLecturesFilter: 'Aucune leçon ne correspond au filtre actuel.',
              noClasses: 'Aucun cours disponible pour le moment.',
              noModules: 'Aucun module pour le moment.',
            },
            curriculum: {
              addClass: 'Ajouter un cours',
              addModule: 'Ajouter un module',
              manageHeading: 'Gérer le plan de cours',
              classMeta: '{{moduleCount}} {{moduleWord}} • {{lectureCount}} {{lectureWord}}',
              moduleMeta: '{{lectureCount}} {{lectureWord}}',
            },
            common: {
              actions: {
                create: 'Créer',
                save: 'Enregistrer',
                skip: 'Ignorer',
                delete: 'Supprimer',
                open: 'Ouvrir',
                upload: 'Importer',
                exit: 'Quitter',
                close: 'Fermer',
                ok: 'OK',
              },
            },
            status: {
              requireEdit: 'Activez le mode édition pour gérer le programme.',
              requireEditLecture: 'Activez le mode édition pour mettre à jour les détails.',
              classCreated: 'Cours créé.',
              classRemoved: 'Cours supprimé.',
              moduleCreated: 'Module créé.',
              moduleRemoved: 'Module supprimé.',
              lectureCreated: 'Leçon créée.',
              lectureRemoved: 'Leçon supprimée.',
              lectureUpdated: 'Leçon mise à jour.',
              lectureTitleRequired: 'Le titre de la leçon est requis.',
              createLectureRequirements: 'Sélectionnez un module et saisissez un titre.',
              slidesProcessed: 'Diapositives importées et converties en archive d’images.',
              assetUploaded: 'Ressource importée avec succès.',
              openingFolder: 'Ouverture du dossier dans votre explorateur de fichiers.',
              openingLocation: 'Affichage de l’emplacement de la ressource dans votre explorateur.',
              transcriptionPreparing: '====> Préparation de la transcription…',
              transcriptionCompleted: 'Transcription terminée.',
              processing: 'Traitement…',
              storageLoadFailed: 'Impossible de charger le contenu du stockage.',
              storageUsageFailed: 'Impossible de charger l’utilisation du stockage.',
              storagePurged: 'Audios traités supprimés.',
              storagePurgeFailed: 'Impossible de supprimer les audios traités.',
              gpuChecking: '====> Vérification de la compatibilité GPU Whisper…',
              gpuConfirmed: 'Compatibilité GPU Whisper confirmée.',
              gpuUnavailable: 'GPU indisponible sur cette plateforme.',
              gpuUnsupported: 'GPU Whisper n’est pas pris en charge sur cette plateforme.',
              gpuNotAvailable: 'L’accélération GPU n’est pas disponible sur cette plateforme.',
              shuttingDown: 'Fermeture de l’application…',
              settingsSaved: 'Paramètres enregistrés.',
              gpuFallback: 'Bascule vers le modèle {{model}}.',
              lectureReordered: 'L’ordre des cours a été mis à jour.',
              exporting: 'Préparation de l’archive…',
              exportReady: 'Archive prête au téléchargement.',
              exportFailed: 'Impossible de créer l’archive.',
              importing: 'Importation de l’archive…',
              importSuccess: '{{count}} cours importés.',
              importNoChanges: 'Archive importée (aucun nouveau cours).',
            },
            counts: {
              module: { one: 'module', other: 'modules' },
              lecture: { one: 'leçon', other: 'leçons' },
            },
          },
        };

        const DEFAULT_LANGUAGE = 'en';

        function resolveTranslation(locale, key) {
          if (!locale || !key) {
            return undefined;
          }
          const segments = key.split('.');
          let value = locale;
          for (const segment of segments) {
            if (value && Object.prototype.hasOwnProperty.call(value, segment)) {
              value = value[segment];
            } else {
              return undefined;
            }
          }
          return typeof value === 'string' || (typeof value === 'object' && value !== null)
            ? value
            : undefined;
        }

        function formatTemplate(template, params) {
          if (!params) {
            return template;
          }
          return template.replace(/\{\{(.*?)\}\}/g, (match, name) => {
            const key = String(name).trim();
            return Object.prototype.hasOwnProperty.call(params, key)
              ? String(params[key])
              : match;
          });
        }

        function getLocale(language) {
          return translations[language] ?? translations[DEFAULT_LANGUAGE];
        }

        let currentLanguage = DEFAULT_LANGUAGE;

        function t(key, params = undefined) {
          if (!key) {
            return '';
          }
          const locale = getLocale(currentLanguage);
          const fallback = translations[DEFAULT_LANGUAGE];
          const template =
            resolveTranslation(locale, key) ?? resolveTranslation(fallback, key) ?? key;
          return formatTemplate(template, params);
        }

        const pluralRules = {
          en: new Intl.PluralRules('en'),
          zh: new Intl.PluralRules('zh'),
          es: new Intl.PluralRules('es'),
          fr: new Intl.PluralRules('fr'),
        };

        function pluralize(language, key, count) {
          const locale = getLocale(language);
          const fallback = translations[DEFAULT_LANGUAGE];
          const rule = (pluralRules[language] ?? pluralRules[DEFAULT_LANGUAGE]).select(
            Number(count),
          );
          const target = resolveTranslation(locale, key);
          const fallbackTarget = resolveTranslation(fallback, key);
          if (target && typeof target === 'string') {
            return target;
          }
          if (target && typeof target === 'object' && target !== null) {
            return target[rule] ?? target.other ?? target.one ?? String(count);
          }
          if (fallbackTarget && typeof fallbackTarget === 'object' && fallbackTarget !== null) {
            return (
              fallbackTarget[rule] ??
              fallbackTarget.other ??
              fallbackTarget.one ??
              String(count)
            );
          }
          return String(count);
        }

        function applyTranslations(language) {
          currentLanguage = language && translations[language] ? language : DEFAULT_LANGUAGE;
          const locale = getLocale(currentLanguage);
          const fallback = translations[DEFAULT_LANGUAGE];
          document.documentElement.lang = currentLanguage;

          document.querySelectorAll('[data-i18n]').forEach((element) => {
            const key = element.getAttribute('data-i18n');
            if (!key) {
              return;
            }
            const attr = element.getAttribute('data-i18n-attr');
            const template = resolveTranslation(locale, key) ?? resolveTranslation(fallback, key);
            if (typeof template !== 'string') {
              return;
            }
            if (attr) {
              attr.split(',').forEach((attributeName) => {
                const name = attributeName.trim();
                if (name) {
                  element.setAttribute(name, formatTemplate(template, {}));
                }
              });
            } else {
              element.textContent = formatTemplate(template, {});
            }
          });

          const titleTranslation = resolveTranslation(locale, 'document.title') ??
            resolveTranslation(fallback, 'document.title');
          if (typeof titleTranslation === 'string') {
            document.title = titleTranslation;
          }
        }

        const WHISPER_MODEL_CHOICES = new Set([
          'tiny',
          'base',
          'small',
          'medium',
          'large',
          'gpu',
        ]);
        const GPU_MODEL = 'gpu';
        const DEFAULT_WHISPER_MODEL = 'base';
        const SLIDE_DPI_CHOICES = new Set(['150', '200', '300', '400', '600']);
        const DEFAULT_SLIDE_DPI = '200';
        const LANGUAGE_CHOICES = new Set(['en', 'zh', 'es', 'fr']);

        function normalizeWhisperModel(value) {
          const candidate =
            typeof value === 'string' ? value.trim() : String(value ?? '');
          return WHISPER_MODEL_CHOICES.has(candidate)
            ? candidate
            : DEFAULT_WHISPER_MODEL;
        }

        function normalizeSlideDpi(value) {
          let candidate;
          if (typeof value === 'number' && Number.isFinite(value)) {
            candidate = String(Math.trunc(value));
          } else if (typeof value === 'string') {
            candidate = value.trim();
          } else {
            candidate = String(value ?? '');
          }
          return SLIDE_DPI_CHOICES.has(candidate) ? candidate : DEFAULT_SLIDE_DPI;
        }

        function normalizeLanguage(value) {
          if (typeof value === 'string') {
            const trimmed = value.trim().toLowerCase();
            return LANGUAGE_CHOICES.has(trimmed) ? trimmed : DEFAULT_LANGUAGE;
          }
          return DEFAULT_LANGUAGE;
        }

        const state = {
          classes: [],
          stats: {},
          query: '',
          selectedLectureId: null,
          buttonMap: new Map(),
          editMode: false,
          activeView: 'details',
          settings: null,
          draggingLectureId: null,
          draggingSourceModuleId: null,
          draggedElement: null,
          gpuWhisper: {
            supported: false,
            checked: false,
            message: t('settings.whisper.gpu.status'),
            output: '',
            lastChecked: null,
            unavailable: false,
          },
          transcriptionProgressTimer: null,
          transcriptionProgressLectureId: null,
          lastProgressMessage: '',
          lastProgressRatio: null,
          statusHideTimer: null,
          storage: {
            usage: null,
            loading: false,
            overview: null,
            purging: false,
            initialized: false,
          },
        };

        const dom = {
          status: document.getElementById('status-bar'),
          statusMessage: document.getElementById('status-bar-message'),
          statusProgress: document.getElementById('status-bar-progress'),
          statusProgressFill: document.getElementById('status-bar-progress-fill'),
          statusProgressText: document.getElementById('status-bar-progress-text'),
          stats: document.getElementById('stats'),
          curriculum: document.getElementById('curriculum'),
          search: document.getElementById('search-input'),
          summary: document.getElementById('lecture-summary'),
          editForm: document.getElementById('lecture-edit-form'),
          editName: document.getElementById('edit-lecture-name'),
          editModule: document.getElementById('edit-lecture-module'),
          editDescription: document.getElementById('edit-lecture-description'),
          deleteButton: document.getElementById('delete-lecture'),
          editToggle: document.getElementById('toggle-edit-mode'),
          editBanner: document.getElementById('edit-mode-banner'),
          assetSection: document.getElementById('asset-section'),
          assetList: document.getElementById('asset-list'),
          transcribeButton: document.getElementById('transcribe-button'),
          transcribeModel: document.getElementById('transcribe-model'),
          createForm: document.getElementById('lecture-create-form'),
          createModule: document.getElementById('create-module'),
          createName: document.getElementById('create-name'),
          createDescription: document.getElementById('create-description'),
          createSubmit: document.getElementById('create-submit'),
          viewButtons: Array.from(document.querySelectorAll('.top-bar [data-view]')),
          views: {
            details: document.getElementById('view-details'),
            create: document.getElementById('view-create'),
            storage: document.getElementById('view-storage'),
            settings: document.getElementById('view-settings'),
          },
          settingsForm: document.getElementById('settings-form'),
          settingsTheme: document.getElementById('settings-theme'),
          settingsLanguage: document.getElementById('settings-language'),
          settingsWhisperModel: document.getElementById('settings-whisper-model'),
          settingsWhisperCompute: document.getElementById('settings-whisper-compute'),
          settingsWhisperBeam: document.getElementById('settings-whisper-beam'),
          settingsWhisperGpuStatus: document.getElementById('settings-whisper-gpu-status'),
          settingsWhisperGpuTest: document.getElementById('settings-whisper-gpu-test'),
          settingsSlideDpi: document.getElementById('settings-slide-dpi'),
          settingsExitApp: document.getElementById('settings-exit-app'),
          settingsExport: document.getElementById('settings-export'),
          settingsImport: document.getElementById('settings-import'),
          settingsImportMode: document.getElementById('settings-import-mode'),
          gpuModelOptions: Array.from(document.querySelectorAll('option.gpu-only')),
          storage: {
            container: document.getElementById('view-storage'),
            path: document.getElementById('storage-path'),
            refresh: document.getElementById('storage-refresh'),
            used: document.getElementById('storage-used'),
            available: document.getElementById('storage-available'),
            total: document.getElementById('storage-total'),
            loading: document.getElementById('storage-loading'),
            empty: document.getElementById('storage-empty'),
            wrapper: document.getElementById('storage-class-wrapper'),
            list: document.getElementById('storage-class-list'),
            purge: document.getElementById('storage-purge'),
            purgeSummary: document.getElementById('storage-purge-summary'),
          },
          dialog: {
            root: document.getElementById('dialog-root'),
            backdrop: document.getElementById('dialog-backdrop'),
            window: document.getElementById('dialog-window'),
            title: document.getElementById('dialog-title'),
            message: document.getElementById('dialog-message'),
            inputWrapper: document.getElementById('dialog-input-wrapper'),
            input: document.getElementById('dialog-input'),
            confirm: document.getElementById('dialog-confirm'),
            cancel: document.getElementById('dialog-cancel'),
          },
        };


        function renderStorageUsage() {
          if (!dom.storage) {
            return;
          }
          const usage = state.storage.usage;
          if (dom.storage.used) {
            dom.storage.used.textContent =
              usage && typeof usage.used === 'number' ? formatBytes(usage.used) : '—';
          }
          if (dom.storage.available) {
            dom.storage.available.textContent =
              usage && typeof usage.free === 'number' ? formatBytes(usage.free) : '—';
          }
          if (dom.storage.total) {
            dom.storage.total.textContent =
              usage && typeof usage.total === 'number' ? formatBytes(usage.total) : '—';
          }
        }

        function renderStoragePurgeSummary() {
          if (!dom.storage || !dom.storage.purgeSummary) {
            return;
          }
          if (state.storage.loading) {
            dom.storage.purgeSummary.textContent = t('storage.loading');
            return;
          }
          const overview = state.storage.overview;
          const eligible = Number(overview?.eligible_audio_total) || 0;
          if (eligible > 0) {
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', eligible);
            dom.storage.purgeSummary.textContent = t('storage.purge.available', {
              count: eligible,
              lectureWord,
            });
          } else {
            dom.storage.purgeSummary.textContent = t('storage.purge.none');
          }
        }

        function renderStoragePurgeControls() {
          if (!dom.storage || !dom.storage.purge) {
            return;
          }
          const overview = state.storage.overview;
          const eligible = Number(overview?.eligible_audio_total) || 0;
          dom.storage.purge.disabled =
            state.storage.loading || state.storage.purging || eligible === 0;
          if (state.storage.purging) {
            dom.storage.purge.textContent = t('storage.purge.working');
          } else {
            dom.storage.purge.textContent = t('storage.actions.purge');
          }
        }

        function renderStorageClasses() {
          if (!dom.storage || !dom.storage.list) {
            return;
          }
          const container = dom.storage.list;
          container.innerHTML = '';
          if (state.storage.loading) {
            return;
          }
          const overview = state.storage.overview;
          const classes = Array.isArray(overview?.classes) ? overview.classes : [];
          classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const classItem = document.createElement('li');
            classItem.className = 'storage-class-card';

            const header = document.createElement('div');
            header.className = 'storage-class-header';

            const title = document.createElement('h3');
            title.className = 'storage-class-title';
            title.textContent = klass.name || t('storage.unnamedClass');
            header.appendChild(title);

            const classSize = document.createElement('span');
            classSize.className = 'storage-class-size';
            classSize.textContent =
              typeof klass.size === 'number' && klass.size >= 0 ? formatBytes(klass.size) : '—';
            header.appendChild(classSize);

            classItem.appendChild(header);

            const moduleCount = Number(klass.module_count) || 0;
            const lectureCount = Number(klass.lecture_count) || 0;
            const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            const classSummaryParts = [
              t('storage.classes.summary', {
                moduleCount,
                moduleWord,
                lectureCount,
                lectureWord,
              }),
            ];
            const classEligible = Number(klass.eligible_audio_count) || 0;
            if (classEligible > 0) {
              classSummaryParts.push(
                t('storage.purge.readyCount', {
                  count: classEligible,
                  lectureWord: pluralize(currentLanguage, 'counts.lecture', classEligible),
                }),
              );
            }
            const classMeta = document.createElement('p');
            classMeta.className = 'storage-class-meta';
            classMeta.textContent = classSummaryParts.filter(Boolean).join(' • ');
            classItem.appendChild(classMeta);

            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            if (!modules.length) {
              const empty = document.createElement('p');
              empty.className = 'storage-class-meta';
              empty.textContent = t('storage.classes.empty');
              classItem.appendChild(empty);
            } else {
              const moduleList = document.createElement('ul');
              moduleList.className = 'storage-module-list';
              modules.forEach((module) => {
                if (!module || typeof module !== 'object') {
                  return;
                }
                const moduleItem = document.createElement('li');
                moduleItem.className = 'storage-module-card';

                const moduleHeader = document.createElement('div');
                moduleHeader.className = 'storage-module-header';

                const moduleTitle = document.createElement('h4');
                moduleTitle.className = 'storage-module-title';
                moduleTitle.textContent = module.name || t('storage.unnamedModule');
                moduleHeader.appendChild(moduleTitle);

                const moduleSize = document.createElement('span');
                moduleSize.className = 'storage-module-size';
                moduleSize.textContent =
                  typeof module.size === 'number' && module.size >= 0
                    ? formatBytes(module.size)
                    : '—';
                moduleHeader.appendChild(moduleSize);

                moduleItem.appendChild(moduleHeader);

                const moduleLectureCount = Number(module.lecture_count) || 0;
                const moduleLectureWord = pluralize(
                  currentLanguage,
                  'counts.lecture',
                  moduleLectureCount,
                );
                const moduleSummaryParts = [
                  t('storage.modules.summary', {
                    lectureCount: moduleLectureCount,
                    lectureWord: moduleLectureWord,
                  }),
                ];
                const moduleEligible = Number(module.eligible_audio_count) || 0;
                if (moduleEligible > 0) {
                  moduleSummaryParts.push(
                    t('storage.purge.readyCount', {
                      count: moduleEligible,
                      lectureWord: pluralize(currentLanguage, 'counts.lecture', moduleEligible),
                    }),
                  );
                }
                const moduleMeta = document.createElement('p');
                moduleMeta.className = 'storage-module-meta';
                moduleMeta.textContent = moduleSummaryParts.filter(Boolean).join(' • ');
                moduleItem.appendChild(moduleMeta);

                const lectures = Array.isArray(module.lectures) ? module.lectures : [];
                if (!lectures.length) {
                  const emptyLecture = document.createElement('p');
                  emptyLecture.className = 'storage-module-meta';
                  emptyLecture.textContent = t('storage.modules.empty');
                  moduleItem.appendChild(emptyLecture);
                } else {
                  const lectureList = document.createElement('ul');
                  lectureList.className = 'storage-lecture-list';
                  lectures.forEach((lecture) => {
                    if (!lecture || typeof lecture !== 'object') {
                      return;
                    }
                    const lectureItem = document.createElement('li');
                    lectureItem.className = 'storage-lecture-item';

                    const lectureHeader = document.createElement('div');
                    lectureHeader.className = 'storage-lecture-header';

                    const lectureTitle = document.createElement('p');
                    lectureTitle.className = 'storage-lecture-title';
                    lectureTitle.textContent = lecture.name || t('storage.unnamedLecture');
                    lectureHeader.appendChild(lectureTitle);

                    const lectureSize = document.createElement('span');
                    lectureSize.className = 'storage-lecture-size';
                    lectureSize.textContent =
                      typeof lecture.size === 'number' && lecture.size >= 0
                        ? formatBytes(lecture.size)
                        : '—';
                    lectureHeader.appendChild(lectureSize);

                    lectureItem.appendChild(lectureHeader);

                    const lectureMeta = document.createElement('p');
                    lectureMeta.className = 'storage-lecture-meta';
                    const assetLabels = [];
                    if (lecture.has_audio) {
                      assetLabels.push(t('storage.lecture.audio'));
                    }
                    if (lecture.has_transcript) {
                      assetLabels.push(t('storage.lecture.transcript'));
                    }
                    if (lecture.has_notes) {
                      assetLabels.push(t('storage.lecture.notes'));
                    }
                    if (lecture.has_slides) {
                      assetLabels.push(t('storage.lecture.slides'));
                    }
                    lectureMeta.textContent = assetLabels.length
                      ? assetLabels.join(' • ')
                      : t('storage.lecture.empty');
                    lectureItem.appendChild(lectureMeta);

                    if (lecture.eligible_audio) {
                      const eligibleBadge = document.createElement('span');
                      eligibleBadge.className = 'storage-lecture-eligible';
                      eligibleBadge.textContent = t('storage.lecture.eligible');
                      lectureItem.appendChild(eligibleBadge);
                    }

                    lectureList.appendChild(lectureItem);
                  });
                  moduleItem.appendChild(lectureList);
                }

                moduleList.appendChild(moduleItem);
              });
              classItem.appendChild(moduleList);
            }

            container.appendChild(classItem);
          });
        }

        function renderStorage() {
          if (!dom.storage) {
            return;
          }
          if (dom.storage.loading) {
            dom.storage.loading.hidden = !state.storage.loading;
          }
          const overview = state.storage.overview;
          const classes = Array.isArray(overview?.classes) ? overview.classes : [];
          if (dom.storage.empty) {
            dom.storage.empty.hidden = state.storage.loading || classes.length > 0;
          }
          if (dom.storage.wrapper) {
            dom.storage.wrapper.hidden = state.storage.loading || classes.length === 0;
          }
          renderStorageUsage();
          renderStoragePurgeSummary();
          renderStoragePurgeControls();
          renderStorageClasses();
        }

        async function refreshStorage() {
          if (!dom.storage) {
            return;
          }
          state.storage.loading = true;
          renderStorage();
          try {
            const overviewPayload = await request('/api/storage/overview');
            state.storage.overview = overviewPayload ?? null;
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message || t('status.storageLoadFailed'), 'error');
            state.storage.overview = null;
          }
          try {
            const usagePayload = await request('/api/storage/usage');
            state.storage.usage = usagePayload?.usage ?? usagePayload ?? null;
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message || t('status.storageUsageFailed'), 'error');
          }
          state.storage.loading = false;
          state.storage.initialized = true;
          renderStorage();
        }

        async function handlePurgeProcessedAudio() {
          if (!dom.storage || !dom.storage.purge) {
            return;
          }
          const overview = state.storage.overview;
          const eligible = Number(overview?.eligible_audio_total) || 0;
          if (!eligible || state.storage.purging) {
            return;
          }
          const lectureWord = pluralize(currentLanguage, 'counts.lecture', eligible);
          const confirmed = await confirmDialog({
            title: t('storage.dialogs.purgeTitle'),
            message: t('storage.dialogs.purgeMessage', { count: eligible, lectureWord }),
            confirmText: t('common.actions.delete'),
            cancelText: t('dialog.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            state.storage.purging = true;
            renderStorage();
            await request('/api/storage/purge-audio', { method: 'POST' });
            showStatus(t('status.storagePurged'), 'success');
            await refreshStorage();
          } catch (error) {
            const messageText = error instanceof Error ? error.message : String(error);
            showStatus(messageText || t('status.storagePurgeFailed'), 'error');
          } finally {
            state.storage.purging = false;
            renderStorage();
          }
        }

        applyTranslations(DEFAULT_LANGUAGE);
        renderStorage();

        const STATUS_DEFAULT_TIMEOUT = 5000;

        function resetStatusProgress() {
          if (dom.statusProgress) {
            dom.statusProgress.hidden = true;
          }
          if (dom.statusProgressFill) {
            dom.statusProgressFill.style.width = '0%';
          }
          if (dom.statusProgressText) {
            dom.statusProgressText.textContent = '';
          }
        }

        function hideStatus() {
          if (state.statusHideTimer !== null) {
            window.clearTimeout(state.statusHideTimer);
            state.statusHideTimer = null;
          }
          if (!dom.status) {
            return;
          }
          dom.status.style.display = 'none';
          dom.status.removeAttribute('data-variant');
          if (dom.statusMessage) {
            dom.statusMessage.textContent = '';
          } else {
            dom.status.textContent = '';
          }
          resetStatusProgress();
        }

        const assetDefinitions = [
          {
            key: 'audio_path',
            labelKey: 'assets.labels.audio',
            accept: 'audio/*,video/*,*/*',
            type: 'audio',
          },
          {
            key: 'slide_path',
            labelKey: 'assets.labels.slides',
            accept: 'application/pdf',
            type: 'slides',
          },
          {
            key: 'transcript_path',
            labelKey: 'assets.labels.transcript',
            accept: '.txt,.md,text/plain',
            type: 'transcript',
          },
          {
            key: 'notes_path',
            labelKey: 'assets.labels.notes',
            accept:
              '.txt,.md,.doc,.docx,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            type: 'notes',
          },
          {
            key: 'slide_image_dir',
            labelKey: 'assets.labels.slideImages',
            accept: null,
            type: 'slide_images',
            reveal: 'folder',
          },
        ];

        function showStatus(message, variant = 'info', options = {}) {
          if (!dom.status) {
            return;
          }

          if (state.statusHideTimer !== null) {
            window.clearTimeout(state.statusHideTimer);
            state.statusHideTimer = null;
          }

          if (!message) {
            hideStatus();
            return;
          }

          const ratioValue =
            options && typeof options.progressRatio === 'number'
              ? options.progressRatio
              : null;
          const hasRatio = Number.isFinite(ratioValue);
          const clampedRatio = hasRatio
            ? Math.max(0, Math.min(Number(ratioValue), 1))
            : null;

          dom.status.dataset.variant = variant;
          dom.status.style.display = 'block';
          if (dom.statusMessage) {
            dom.statusMessage.textContent = message;
          } else {
            dom.status.textContent = message;
          }

          if (clampedRatio !== null) {
            const percentValue = Math.round(clampedRatio * 1000) / 10;
            const label = Number.isInteger(percentValue)
              ? `${percentValue}%`
              : `${percentValue.toFixed(1)}%`;
            if (dom.statusProgress) {
              dom.statusProgress.hidden = false;
            }
            if (dom.statusProgressFill) {
              dom.statusProgressFill.style.width = `${percentValue}%`;
            }
            if (dom.statusProgressText) {
              dom.statusProgressText.textContent = label;
            }
          } else {
            resetStatusProgress();
          }

          const progressActive = clampedRatio !== null && clampedRatio < 1;
          const persistOption =
            options && Object.prototype.hasOwnProperty.call(options, 'persist')
              ? Boolean(options.persist)
              : progressActive;
          const timeoutMs =
            options && typeof options.timeoutMs === 'number' && Number.isFinite(options.timeoutMs)
              ? Math.max(0, options.timeoutMs)
              : STATUS_DEFAULT_TIMEOUT;

          if (!persistOption) {
            state.statusHideTimer = window.setTimeout(() => {
              state.statusHideTimer = null;
              hideStatus();
            }, timeoutMs);
          }
        }

        function updateGpuWhisperUI(status = {}) {
          const supported = Boolean(status.supported);
          const checked = Boolean(status.checked);
          const unavailable = Boolean(status.unavailable);
          const output = typeof status.output === 'string' ? status.output : '';
          const lastChecked = status.last_checked || null;
          let message =
            typeof status.message === 'string' && status.message.trim().length > 0
              ? status.message.trim()
              : checked
              ? t('status.gpuUnavailable')
              : t('settings.whisper.gpu.status');

          state.gpuWhisper = {
            supported,
            checked,
            message,
            output,
            lastChecked,
            unavailable,
          };

          if (dom.settingsWhisperGpuStatus) {
            let displayMessage = message;
            if (output) {
              const snippet = output.split('\n').slice(0, 5).join('\n').trim();
              if (snippet && snippet !== message) {
                displayMessage = `${message}\n${snippet}`;
              }
            }
            dom.settingsWhisperGpuStatus.textContent = displayMessage;
          }

          if (dom.settingsWhisperGpuTest) {
            dom.settingsWhisperGpuTest.disabled = unavailable;
            dom.settingsWhisperGpuTest.textContent = supported
              ? t('settings.whisper.gpu.retry')
              : t('settings.whisper.gpu.test');
          }

          if (dom.gpuModelOptions) {
            dom.gpuModelOptions.forEach((option) => {
              if (option instanceof HTMLOptionElement) {
                option.disabled = !supported;
              }
            });
          }

          const requestedModel =
            state.settings?.whisper_model_requested || state.settings?.whisper_model;
          if (!supported) {
            if (dom.settingsWhisperModel && dom.settingsWhisperModel.value === GPU_MODEL) {
              dom.settingsWhisperModel.value = DEFAULT_WHISPER_MODEL;
            }
            if (dom.transcribeModel && dom.transcribeModel.value === GPU_MODEL) {
              dom.transcribeModel.value = DEFAULT_WHISPER_MODEL;
            }
            if (state.settings) {
              state.settings.whisper_model = dom.settingsWhisperModel
                ? dom.settingsWhisperModel.value
                : DEFAULT_WHISPER_MODEL;
            }
          } else if (requestedModel === GPU_MODEL) {
            if (dom.settingsWhisperModel) {
              dom.settingsWhisperModel.value = GPU_MODEL;
            }
            if (dom.transcribeModel) {
              dom.transcribeModel.value = GPU_MODEL;
            }
            if (state.settings) {
              state.settings.whisper_model = GPU_MODEL;
            }
          }
        }

        const dialogState = { active: false };

        function syncSettingsForm(settings) {
          const themeValue = settings?.theme ?? 'system';
          const languageValue = normalizeLanguage(settings?.language);
          const requestedModel = normalizeWhisperModel(settings?.whisper_model);
          const computeRaw = settings?.whisper_compute_type ?? 'int8';
          const computeValue =
            typeof computeRaw === 'string' ? computeRaw.trim() || 'int8' : 'int8';
          const beamNumber = Math.max(
            1,
            Math.min(10, Number(settings?.whisper_beam_size) || 5),
          );
          const dpiValue = normalizeSlideDpi(settings?.slide_dpi);

          const effectiveModel =
            requestedModel === GPU_MODEL && !state.gpuWhisper.supported
              ? DEFAULT_WHISPER_MODEL
              : requestedModel;

          dom.settingsTheme.value = themeValue;
          dom.settingsLanguage.value = languageValue;
          dom.settingsWhisperModel.value = effectiveModel;
          dom.settingsWhisperCompute.value = computeValue;
          dom.settingsWhisperBeam.value = String(beamNumber);
          dom.settingsSlideDpi.value = dpiValue;
          dom.transcribeModel.value = effectiveModel;

          state.settings = {
            theme: themeValue,
            language: languageValue,
            whisper_model: effectiveModel,
            whisper_model_requested: requestedModel,
            whisper_compute_type: computeValue,
            whisper_beam_size: beamNumber,
            slide_dpi: Number(dpiValue),
          };

          applyTheme(themeValue);
          updateGpuWhisperUI({ ...state.gpuWhisper });
          applyTranslations(languageValue);
          renderStorage();
          updateEditModeUI();
        }

        function showDialog({
          title = '',
          message = '',
          confirmText = t('dialog.confirm'),
          cancelText = t('dialog.cancel'),
          variant = 'primary',
          input = false,
          placeholder = '',
          defaultValue = '',
          required = false,
        } = {}) {
          return new Promise((resolve) => {
            const dialog = dom.dialog;
            if (!dialog.root || dialogState.active) {
              resolve({ confirmed: false, value: null });
              return;
            }

            dialogState.active = true;
            const previousActive =
              document.activeElement instanceof HTMLElement ? document.activeElement : null;
            const requireValue = Boolean(required && input);
            const variantClass = variant === 'danger' ? 'danger' : 'primary';

            dialog.title.textContent = title || '';
            dialog.message.textContent = message || '';
            dialog.message.style.display = message ? 'block' : 'none';

            if (input) {
              dialog.inputWrapper.classList.remove('hidden');
              dialog.input.value = defaultValue ?? '';
              dialog.input.placeholder = placeholder ?? '';
            } else {
              dialog.inputWrapper.classList.add('hidden');
              dialog.input.value = '';
              dialog.input.placeholder = '';
            }

            dialog.confirm.textContent = confirmText;
            dialog.cancel.textContent = cancelText;
            dialog.confirm.classList.remove('primary', 'danger');
            dialog.confirm.classList.add(variantClass);
            dialog.confirm.disabled = false;

            const focusOrder = [];
            if (input) {
              focusOrder.push(dialog.input);
            }
            focusOrder.push(dialog.cancel, dialog.confirm);

            function updateConfirmState() {
              if (!requireValue) {
                dialog.confirm.disabled = false;
                return;
              }
              dialog.confirm.disabled = dialog.input.value.trim().length === 0;
            }

            function cleanup() {
              dialog.confirm.removeEventListener('click', handleConfirm);
              dialog.cancel.removeEventListener('click', handleCancel);
              dialog.backdrop.removeEventListener('click', handleCancel);
              dialog.window.removeEventListener('keydown', handleKeyDown);
              if (input) {
                dialog.input.removeEventListener('input', updateConfirmState);
              }
              dialog.root.classList.add('hidden');
              dialog.root.setAttribute('aria-hidden', 'true');
              document.body.classList.remove('dialog-open');
              dialogState.active = false;
              if (previousActive) {
                previousActive.focus({ preventScroll: true });
              }
            }

            function resolveAndClose(result) {
              cleanup();
              resolve(result);
            }

            function handleConfirm(event) {
              event.preventDefault();
              if (dialog.confirm.disabled) {
                return;
              }
              const value = input ? dialog.input.value : null;
              resolveAndClose({ confirmed: true, value });
            }

            function handleCancel(event) {
              event.preventDefault();
              resolveAndClose({ confirmed: false, value: null });
            }

            function handleKeyDown(event) {
              if (event.key === 'Escape') {
                event.preventDefault();
                handleCancel(event);
                return;
              }
              if (event.key === 'Enter') {
                if (input) {
                  if (requireValue && dialog.input.value.trim().length === 0) {
                    return;
                  }
                  if (document.activeElement !== dialog.cancel) {
                    event.preventDefault();
                    handleConfirm(event);
                  }
                } else if (
                  document.activeElement !== dialog.confirm &&
                  document.activeElement !== dialog.cancel
                ) {
                  event.preventDefault();
                  handleConfirm(event);
                }
                return;
              }
              if (event.key === 'Tab') {
                const focusable = focusOrder.filter(
                  (element) => element instanceof HTMLElement && !element.disabled,
                );
                if (!focusable.length) {
                  return;
                }
                const currentIndex = focusable.indexOf(document.activeElement);
                if (event.shiftKey) {
                  const previousIndex = currentIndex <= 0 ? focusable.length - 1 : currentIndex - 1;
                  focusable[previousIndex].focus();
                } else {
                  const nextIndex = currentIndex === focusable.length - 1 ? 0 : currentIndex + 1;
                  focusable[nextIndex].focus();
                }
                event.preventDefault();
              }
            }

            dialog.confirm.addEventListener('click', handleConfirm);
            dialog.cancel.addEventListener('click', handleCancel);
            dialog.backdrop.addEventListener('click', handleCancel);
            dialog.window.addEventListener('keydown', handleKeyDown);
            if (input) {
              dialog.input.addEventListener('input', updateConfirmState);
            }

            dialog.root.classList.remove('hidden');
            dialog.root.setAttribute('aria-hidden', 'false');
            document.body.classList.add('dialog-open');
            updateConfirmState();

            const initialFocus = input ? dialog.input : dialog.confirm;
            window.requestAnimationFrame(() => {
              initialFocus.focus({ preventScroll: true });
              if (input) {
                const valueLength = dialog.input.value.length;
                dialog.input.setSelectionRange(valueLength, valueLength);
              }
            });
          });
        }

        async function confirmDialog(options = {}) {
          const result = await showDialog({ ...options, input: false });
          return Boolean(result.confirmed);
        }

        async function promptDialog(options = {}) {
          const result = await showDialog({ ...options, input: true });
          if (!result.confirmed) {
            return null;
          }
          return typeof result.value === 'string' ? result.value : '';
        }

        function formatNumber(value) {
          return new Intl.NumberFormat().format(value ?? 0);
        }

        function formatBytes(bytes) {
          if (typeof bytes !== 'number' || Number.isNaN(bytes)) {
            return '';
          }
          if (bytes < 1024) {
            return `${bytes} B`;
          }
          const units = ['KB', 'MB', 'GB', 'TB'];
          let value = bytes / 1024;
          let unitIndex = 0;
          while (value >= 1024 && unitIndex < units.length - 1) {
            value /= 1024;
            unitIndex += 1;
          }
          return `${value >= 100 ? Math.round(value) : value.toFixed(1)} ${units[unitIndex]}`;
        }

        function formatDate(isoString) {
          if (!isoString) {
            return '';
          }
          const formatter = new Intl.DateTimeFormat(undefined, {
            dateStyle: 'medium',
            timeStyle: 'short',
          });
          return formatter.format(new Date(isoString));
        }

        function buildStorageURL(path) {
          if (!path) {
            return '#';
          }
          return `/storage/${path
            .split('/')
            .map((segment) => encodeURIComponent(segment))
            .join('/')}`;
        }

        async function request(url, options = {}) {
          const response = await fetch(url, options);
          if (!response.ok) {
            let detail = `${response.status} ${response.statusText}`;
            try {
              const payload = await response.json();
              if (payload && payload.detail) {
                detail = payload.detail;
              }
            } catch (error) {
              // Ignore JSON parsing errors.
            }
            throw new Error(detail);
          }
          if (response.status === 204) {
            return null;
          }
          const contentType = response.headers.get('content-type') || '';
          if (contentType.includes('application/json')) {
            return await response.json();
          }
          return null;
        }

        async function loadGpuWhisperStatus() {
          try {
            const payload = await request('/api/settings/whisper-gpu/status');
            const status = payload?.status || {};
            updateGpuWhisperUI(status);
          } catch (error) {
            updateGpuWhisperUI({
              supported: false,
              checked: true,
              message: error instanceof Error ? error.message : String(error),
              unavailable: false,
            });
          }
        }

        async function fetchTranscriptionProgress(lectureId) {
          if (!lectureId) {
            return null;
          }
          try {
            const payload = await request(
              `/api/lectures/${lectureId}/transcription-progress`,
            );
            return payload?.progress || null;
          } catch (error) {
            return null;
          }
        }

        function stopTranscriptionProgress({ preserveMessage = false } = {}) {
          if (state.transcriptionProgressTimer !== null) {
            window.clearInterval(state.transcriptionProgressTimer);
          }
          state.transcriptionProgressTimer = null;
          state.transcriptionProgressLectureId = null;
          if (!preserveMessage) {
            state.lastProgressMessage = '';
            state.lastProgressRatio = null;
            resetStatusProgress();
          }
        }

        function handleProgressUpdate(progress) {
          if (!progress) {
            return;
          }
          const message = progress.message || '';
          const variant = progress.error ? 'error' : 'info';
          const finished = Boolean(progress.finished);
          const ratio =
            typeof progress.ratio === 'number' && Number.isFinite(progress.ratio)
              ? Math.max(0, Math.min(progress.ratio, 1))
              : null;
          const shouldUpdate =
            message !== state.lastProgressMessage || ratio !== state.lastProgressRatio;
          if (shouldUpdate) {
            const displayMessage = message || state.lastProgressMessage || t('status.processing');
            showStatus(displayMessage, variant, {
              progressRatio: ratio,
              persist: !finished,
            });
            state.lastProgressMessage = message;
            state.lastProgressRatio = ratio;
          }
          if (finished) {
            stopTranscriptionProgress({ preserveMessage: true });
          }
        }

        function startTranscriptionProgress(lectureId) {
          stopTranscriptionProgress();
          if (!lectureId) {
            return;
          }
          state.transcriptionProgressLectureId = lectureId;
          const poll = async () => {
            const progress = await fetchTranscriptionProgress(lectureId);
            if (progress) {
              handleProgressUpdate(progress);
            }
          };
          poll();
          state.transcriptionProgressTimer = window.setInterval(poll, 1200);
        }

        function clearDetailPanel() {
          dom.summary.textContent = t('details.summaryPlaceholder');
          dom.summary.classList.add('placeholder');
          if (dom.editForm) {
            dom.editForm.reset();
          }
          dom.assetSection.hidden = true;
          dom.assetList.innerHTML = '';
          dom.transcribeButton.disabled = true;
          updateEditControlsAvailability();
        }

        function updateEditControlsAvailability() {
          const hasSelection = Boolean(state.selectedLectureId);
          const allowEditing = state.editMode && hasSelection;
          dom.editForm.hidden = !allowEditing;
          dom.deleteButton.hidden = !allowEditing;
        }

        function updateEditModeUI() {
          const isActive = state.editMode;
          if (dom.editToggle) {
            dom.editToggle.textContent = isActive
              ? t('topBar.exitEdit')
              : t('topBar.enableEdit');
            dom.editToggle.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            dom.editToggle.classList.toggle('active', isActive);
          }
          if (dom.editBanner) {
            dom.editBanner.hidden = !isActive;
          }
          renderCurriculum();
          updateEditControlsAvailability();
        }

        function setActiveView(view) {
          if (!dom.views[view]) {
            return;
          }
          state.activeView = view;
          dom.viewButtons.forEach((button) => {
            const isActive = button.dataset.view === view;
            button.classList.toggle('active', isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
          Object.entries(dom.views).forEach(([key, element]) => {
            if (!element) {
              return;
            }
            const isActive = key === view;
            element.classList.toggle('active', isActive);
            element.hidden = !isActive;
          });
          if (view === 'storage') {
            if (!state.storage.initialized && !state.storage.loading) {
              refreshStorage();
            } else {
              renderStorage();
            }
          }
        }

        function updateStats() {
          const stats = state.stats;
          const entries = [
            [t('stats.classes'), stats.class_count],
            [t('stats.modules'), stats.module_count],
            [t('stats.lectures'), stats.lecture_count],
            [t('stats.transcripts'), stats.transcript_count],
            [t('stats.slideDecks'), stats.slide_count],
            [t('stats.audio'), stats.audio_count],
            [t('stats.notes'), stats.notes_count],
            [t('stats.slideArchives'), stats.slide_image_count],
          ];
          dom.stats.innerHTML = '';
          entries.forEach(([label, value]) => {
            const block = document.createElement('div');
            const term = document.createElement('dt');
            term.textContent = label;
            const data = document.createElement('dd');
            data.textContent = formatNumber(value);
            block.appendChild(term);
            block.appendChild(data);
            dom.stats.appendChild(block);
          });
        }

        function updateModuleOptions() {
          const modules = [];
          state.classes.forEach((klass) => {
            (klass.modules || []).forEach((module) => {
              modules.push({
                id: module.id,
                label: `${klass.name} • ${module.name}`,
              });
            });
          });
          modules.sort((a, b) => a.label.localeCompare(b.label));

          dom.createModule.innerHTML = '';
          dom.editModule.innerHTML = '';

          const createPlaceholder = document.createElement('option');
          createPlaceholder.value = '';
          createPlaceholder.textContent = modules.length
            ? t('dropdowns.selectModule')
            : t('dropdowns.noModules');
          createPlaceholder.disabled = modules.length === 0;
          createPlaceholder.selected = true;
          dom.createModule.appendChild(createPlaceholder);

          modules.forEach((module) => {
            const option = document.createElement('option');
            option.value = String(module.id);
            option.textContent = module.label;
            dom.createModule.appendChild(option.cloneNode(true));
            dom.editModule.appendChild(option);
          });

          dom.createModule.disabled = modules.length === 0;
          dom.createSubmit.disabled = modules.length === 0;
        }

        function matchQuery(text, query) {
          return typeof text === 'string' && text.toLowerCase().includes(query);
        }

        function computeFilteredClasses() {
          const query = state.query.trim().toLowerCase();
          if (!query) {
            return state.classes.map((klass) => ({
              class: klass,
              modules: (klass.modules || []).map((module) => ({
                module,
                lectures: module.lectures || [],
              })),
            }));
          }

          const filtered = [];
          state.classes.forEach((klass) => {
            const classMatch = matchQuery(klass.name, query) || matchQuery(klass.description, query);
            const modules = [];
            (klass.modules || []).forEach((module) => {
              const moduleMatch =
                classMatch || matchQuery(module.name, query) || matchQuery(module.description, query);
              let lectures = module.lectures || [];
              if (!moduleMatch) {
                lectures = (module.lectures || []).filter(
                  (lecture) =>
                    matchQuery(lecture.name, query) || matchQuery(lecture.description, query),
                );
              }
              if (moduleMatch && lectures.length === 0) {
                lectures = module.lectures || [];
              }
              if (lectures.length > 0) {
                modules.push({ module, lectures });
              }
            });
            if (modules.length > 0) {
              filtered.push({ class: klass, modules });
            }
          });
          return filtered;
        }

        function highlightSelected() {
          state.buttonMap.forEach((button, lectureId) => {
            if (lectureId === state.selectedLectureId) {
              button.classList.add('active');
              button.setAttribute('aria-current', 'true');
            } else {
              button.classList.remove('active');
              button.removeAttribute('aria-current');
            }
          });
        }

        function findModuleEntry(moduleId) {
          for (const classEntry of state.classes) {
            const modules = classEntry.modules || [];
            for (const moduleEntry of modules) {
              if (moduleEntry.module.id === moduleId) {
                return { classEntry, moduleEntry };
              }
            }
          }
          return null;
        }

        function findLectureLocation(lectureId) {
          for (const classEntry of state.classes) {
            const modules = classEntry.modules || [];
            for (const moduleEntry of modules) {
              const lectures = moduleEntry.lectures || [];
              for (let index = 0; index < lectures.length; index += 1) {
                if (lectures[index].id === lectureId) {
                  return { classEntry, moduleEntry, index };
                }
              }
            }
          }
          return null;
        }

        function clearDragIndicators() {
          if (!dom.curriculum) {
            return;
          }
          dom.curriculum
            .querySelectorAll('.drop-before, .drop-after')
            .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          dom.curriculum
            .querySelectorAll('.syllabus-lectures.drop-target')
            .forEach((element) => element.classList.remove('drop-target'));
        }

        function startLectureDrag(event, lecture, moduleId) {
          if (!state.editMode) {
            event.preventDefault();
            return;
          }
          state.draggingLectureId = lecture.id;
          state.draggingSourceModuleId = moduleId;
          state.draggedElement = event.currentTarget || null;
          if (event.dataTransfer) {
            event.dataTransfer.effectAllowed = 'move';
            try {
              event.dataTransfer.setData('text/plain', String(lecture.id));
            } catch (error) {
              // Ignore data transfer errors in unsupported browsers.
            }
          }
          if (state.draggedElement) {
            state.draggedElement.classList.add('dragging');
          }
        }

        function clearLectureDrag(event) {
          const element = (event && event.currentTarget) || state.draggedElement;
          if (element) {
            element.classList.remove('dragging');
          }
          state.draggingLectureId = null;
          state.draggingSourceModuleId = null;
          state.draggedElement = null;
          clearDragIndicators();
        }

        function handleLectureDragOver(event) {
          if (!state.editMode || !state.draggingLectureId) {
            return;
          }
          event.preventDefault();
          if (event.dataTransfer) {
            event.dataTransfer.dropEffect = 'move';
          }
          const container = event.currentTarget;
          if (!container || !container.classList) {
            return;
          }
          container.classList.add('drop-target');
          container
            .querySelectorAll('.drop-before, .drop-after')
            .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          const targetItem = event.target && event.target.closest('.syllabus-lecture');
          if (!targetItem || Number(targetItem.dataset.lectureId) === state.draggingLectureId) {
            return;
          }
          const rect = targetItem.getBoundingClientRect();
          const placeAfter = event.clientY > rect.top + rect.height / 2;
          targetItem.classList.add(placeAfter ? 'drop-after' : 'drop-before');
        }

        function handleLectureDragLeave(event) {
          const container = event.currentTarget;
          if (!container) {
            return;
          }
          const related = event.relatedTarget;
          if (!related || (!container.contains(related) && related !== container)) {
            container.classList.remove('drop-target');
            container
              .querySelectorAll('.drop-before, .drop-after')
              .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          }
        }

        async function handleLectureDrop(event, targetModuleId) {
          if (!state.editMode || !state.draggingLectureId) {
            return;
          }
          event.preventDefault();
          const container = event.currentTarget;
          if (container) {
            container.classList.remove('drop-target');
            container
              .querySelectorAll('.drop-before, .drop-after')
              .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          }
          const targetElement = event.target && event.target.closest('.syllabus-lecture');
          let targetIndex = null;
          if (targetElement) {
            const moduleInfo = findModuleEntry(targetModuleId);
            if (moduleInfo) {
              const lectures = moduleInfo.moduleEntry.lectures || [];
              const targetLectureId = Number(targetElement.dataset.lectureId);
              const existingIndex = lectures.findIndex((item) => item.id === targetLectureId);
              if (existingIndex !== -1) {
                const rect = targetElement.getBoundingClientRect();
                const placeAfter = event.clientY > rect.top + rect.height / 2;
                targetIndex = existingIndex + (placeAfter ? 1 : 0);
              }
            }
          }
          await performLectureReorder(state.draggingLectureId, targetModuleId, targetIndex);
        }

        async function performLectureReorder(lectureId, targetModuleId, targetIndex) {
          const sourceInfo = findLectureLocation(lectureId);
          const targetInfo = findModuleEntry(targetModuleId);
          if (!sourceInfo || !targetInfo) {
            clearDragIndicators();
            return;
          }

          const sourceModuleId = sourceInfo.moduleEntry.module.id;
          const sourceLectures = sourceInfo.moduleEntry.lectures || [];
          const targetLectures = targetInfo.moduleEntry.lectures || [];

          let insertionIndex =
            typeof targetIndex === 'number' && Number.isFinite(targetIndex)
              ? targetIndex
              : targetLectures.length;

          if (sourceModuleId === targetModuleId) {
            if (insertionIndex > sourceInfo.index) {
              insertionIndex -= 1;
            }
            if (insertionIndex === sourceInfo.index) {
              clearDragIndicators();
              return;
            }
          }

          const lectureRecord = sourceLectures[sourceInfo.index];
          sourceLectures.splice(sourceInfo.index, 1);

          if (insertionIndex < 0 || insertionIndex > targetLectures.length) {
            insertionIndex = targetLectures.length;
          }

          lectureRecord.module_id = targetModuleId;
          targetLectures.splice(insertionIndex, 0, lectureRecord);

          if (state.draggedElement) {
            state.draggedElement.classList.remove('dragging');
          }

          const modulesToUpdate = new Map();
          modulesToUpdate.set(sourceModuleId, sourceInfo.moduleEntry);
          modulesToUpdate.set(targetModuleId, targetInfo.moduleEntry);

          state.draggingLectureId = null;
          state.draggingSourceModuleId = null;
          state.draggedElement = null;

          renderCurriculum();

          const payload = {
            modules: Array.from(modulesToUpdate.values()).map((moduleEntry) => ({
              module_id: moduleEntry.module.id,
              lecture_ids: (moduleEntry.lectures || []).map((item) => item.id),
            })),
          };

          try {
            await request('/api/lectures/reorder', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            await refreshData();
            showStatus(t('status.lectureReordered'), 'success');
          } catch (error) {
            showStatus(error.message, 'error');
            await refreshData();
          }
        }

        function renderCurriculum() {
          state.buttonMap.clear();
          const filtered = computeFilteredClasses();
          dom.curriculum.innerHTML = '';

          if (state.editMode) {
            const toolbar = document.createElement('div');
            toolbar.className = 'curriculum-toolbar';

            const heading = document.createElement('h3');
            heading.textContent = t('curriculum.manageHeading');
            toolbar.appendChild(heading);

            const actions = document.createElement('div');
            actions.className = 'curriculum-toolbar-actions';

            const addClassButton = document.createElement('button');
            addClassButton.type = 'button';
            addClassButton.className = 'secondary pill';
            addClassButton.textContent = t('curriculum.addClass');
            addClassButton.addEventListener('click', (event) => {
              event.preventDefault();
              handleAddClass();
            });
            actions.appendChild(addClassButton);

            toolbar.appendChild(actions);
            dom.curriculum.appendChild(toolbar);
          }

          if (filtered.length === 0) {
            const message = document.createElement('div');
            message.className = 'placeholder';
            message.textContent = state.classes.length
              ? t('placeholders.noLecturesFilter')
              : t('placeholders.noClasses');
            dom.curriculum.appendChild(message);
            return;
          }

          const syllabus = document.createElement('div');
          syllabus.className = 'syllabus';

          filtered.forEach((entry, classIndex) => {
            const classDetails = document.createElement('details');
            classDetails.className = 'syllabus-class';
            const hasSelection = entry.modules.some((moduleEntry) =>
              (moduleEntry.lectures || []).some(
                (lecture) => lecture.id === state.selectedLectureId,
              ),
            );
            const expandClass =
              state.query || hasSelection || (!state.query && !hasSelection && classIndex === 0);
            classDetails.open = expandClass;

            const summary = document.createElement('summary');
            summary.className = 'syllabus-summary';

            const summaryText = document.createElement('div');
            summaryText.className = 'syllabus-summary-text';

            const title = document.createElement('span');
            title.className = 'syllabus-title';
            title.textContent = entry.class.name;
            summaryText.appendChild(title);

            const moduleCount = entry.modules.length;
            const lectureCount = entry.modules.reduce(
              (total, moduleEntry) => total + (moduleEntry.lectures?.length || 0),
              0,
            );
            const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            const meta = document.createElement('span');
            meta.className = 'syllabus-meta';
            meta.textContent = t('curriculum.classMeta', {
              moduleCount,
              moduleWord,
              lectureCount,
              lectureWord,
            });
            summaryText.appendChild(meta);

            summary.appendChild(summaryText);

            if (state.editMode) {
              const actions = document.createElement('div');
              actions.className = 'syllabus-actions';

              const addModuleButton = document.createElement('button');
              addModuleButton.type = 'button';
              addModuleButton.className = 'text-button';
              addModuleButton.textContent = t('curriculum.addModule');
              addModuleButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                handleAddModule(entry.class);
              });
              actions.appendChild(addModuleButton);

              const deleteClassButton = document.createElement('button');
              deleteClassButton.type = 'button';
              deleteClassButton.className = 'text-button danger';
              deleteClassButton.textContent = t('common.actions.delete');
              deleteClassButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                handleDeleteClass(entry);
              });
              actions.appendChild(deleteClassButton);

              summary.appendChild(actions);
            }

            classDetails.appendChild(summary);

            const content = document.createElement('div');
            content.className = 'syllabus-content';

            if (!entry.modules.length) {
              const emptyModules = document.createElement('div');
              emptyModules.className = 'placeholder';
              emptyModules.textContent = t('placeholders.noModules');
              content.appendChild(emptyModules);
            } else {
              const modulesContainer = document.createElement('div');
              modulesContainer.className = 'syllabus-modules';

              entry.modules.forEach((moduleEntry, moduleIndex) => {
                const moduleDetails = document.createElement('details');
                moduleDetails.className = 'syllabus-module';
                const moduleHasSelection = (moduleEntry.lectures || []).some(
                  (lecture) => lecture.id === state.selectedLectureId,
                );
                const expandModule =
                  state.query ||
                  moduleHasSelection ||
                  (!state.query && !moduleHasSelection && expandClass && moduleIndex === 0);
                moduleDetails.open = expandModule;

                const moduleSummary = document.createElement('summary');
                moduleSummary.className = 'syllabus-summary';

                const moduleSummaryText = document.createElement('div');
                moduleSummaryText.className = 'syllabus-summary-text';

                const moduleTitle = document.createElement('span');
                moduleTitle.className = 'syllabus-title';
                moduleTitle.textContent = moduleEntry.module.name;
                moduleSummaryText.appendChild(moduleTitle);

                const moduleLectureCount = moduleEntry.lectures.length;
                const moduleLectureWord = pluralize(
                  currentLanguage,
                  'counts.lecture',
                  moduleLectureCount,
                );
                const moduleMeta = document.createElement('span');
                moduleMeta.className = 'syllabus-meta';
                moduleMeta.textContent = t('curriculum.moduleMeta', {
                  lectureCount: moduleLectureCount,
                  lectureWord: moduleLectureWord,
                });
                moduleSummaryText.appendChild(moduleMeta);

                moduleSummary.appendChild(moduleSummaryText);

                if (state.editMode) {
                  const moduleActions = document.createElement('div');
                  moduleActions.className = 'syllabus-actions';

                  const deleteModuleButton = document.createElement('button');
                  deleteModuleButton.type = 'button';
                  deleteModuleButton.className = 'text-button danger';
                  deleteModuleButton.textContent = t('common.actions.delete');
                  deleteModuleButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    handleDeleteModule(moduleEntry, entry.class);
                  });
                  moduleActions.appendChild(deleteModuleButton);

                  moduleSummary.appendChild(moduleActions);
                }

                moduleDetails.appendChild(moduleSummary);

                const moduleContent = document.createElement('div');
                moduleContent.className = 'syllabus-content';

                const lectureList = document.createElement('ul');
                lectureList.className = 'syllabus-lectures';
                lectureList.dataset.moduleId = String(moduleEntry.module.id);

                if (!moduleEntry.lectures.length) {
                  lectureList.classList.add('empty');
                  const emptyLectures = document.createElement('div');
                  emptyLectures.className = 'placeholder';
                  emptyLectures.textContent = t('placeholders.noLectures');
                  moduleContent.appendChild(emptyLectures);
                } else {
                  moduleEntry.lectures.forEach((lecture) => {
                    const lectureItem = document.createElement('li');
                    lectureItem.className = 'syllabus-lecture';
                    lectureItem.dataset.lectureId = String(lecture.id);

                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'lecture-button';
                    button.textContent = lecture.name;
                    button.addEventListener('click', (event) => {
                      event.preventDefault();
                      selectLecture(lecture.id);
                    });
                    lectureItem.appendChild(button);
                    state.buttonMap.set(lecture.id, button);

                    if (state.editMode) {
                      lectureItem.draggable = true;
                      lectureItem.addEventListener('dragstart', (event) => {
                        startLectureDrag(event, lecture, moduleEntry.module.id);
                      });
                      lectureItem.addEventListener('dragend', clearLectureDrag);

                      const deleteLectureButton = document.createElement('button');
                      deleteLectureButton.type = 'button';
                      deleteLectureButton.className = 'text-button danger';
                      deleteLectureButton.textContent = t('common.actions.delete');
                      deleteLectureButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        handleDeleteLecture(lecture, moduleEntry.module, entry.class);
                      });
                      lectureItem.appendChild(deleteLectureButton);
                    }

                    lectureList.appendChild(lectureItem);
                  });
                }

                if (state.editMode) {
                  const dropHandler = (event) => handleLectureDrop(event, moduleEntry.module.id);
                  lectureList.addEventListener('dragover', handleLectureDragOver);
                  lectureList.addEventListener('dragleave', handleLectureDragLeave);
                  lectureList.addEventListener('drop', dropHandler);
                }

                moduleContent.appendChild(lectureList);

                moduleDetails.appendChild(moduleContent);
                modulesContainer.appendChild(moduleDetails);
              });

              content.appendChild(modulesContainer);
            }

            classDetails.appendChild(content);
            syllabus.appendChild(classDetails);
          });

          dom.curriculum.appendChild(syllabus);
          highlightSelected();
        }

        function requireEditMode(message = t('status.requireEdit')) {
          if (!state.editMode) {
            showStatus(message, 'info');
            return false;
          }
          return true;
        }

        async function handleAddClass() {
          if (!requireEditMode()) {
            return;
          }
          const name = await promptDialog({
            title: t('dialogs.createClass.title'),
            message: t('dialogs.createClass.message'),
            confirmText: t('common.actions.create'),
            placeholder: t('dialogs.createClass.placeholder'),
            required: true,
          });
          if (!name || !name.trim()) {
            return;
          }
          try {
            await request('/api/classes', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: name.trim() }),
            });
            showStatus(t('status.classCreated'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleAddModule(classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const name = await promptDialog({
            title: t('dialogs.createModule.title'),
            message: t('dialogs.createModule.message', { className: classRecord.name }),
            confirmText: t('common.actions.create'),
            placeholder: t('dialogs.createModule.placeholder'),
            required: true,
          });
          if (!name || !name.trim()) {
            return;
          }
          try {
            await request('/api/modules', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                class_id: classRecord.id,
                name: name.trim(),
              }),
            });
            showStatus(t('status.moduleCreated'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleDeleteClass(classEntry) {
          if (!requireEditMode()) {
            return;
          }
          const moduleCount = classEntry.modules.length;
          const lectureCount = classEntry.modules.reduce(
            (total, moduleEntry) => total + (moduleEntry.lectures?.length || 0),
            0,
          );
          const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
          const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
          let message = t('dialogs.deleteClass.message', { className: classEntry.class.name });
          if (moduleCount || lectureCount) {
            message += `\n\n${t('dialogs.deleteClass.summary', {
              moduleCount,
              moduleWord,
              lectureCount,
              lectureWord,
            })}`;
          }
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteClass.title'),
            message,
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteClass.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            await request(`/api/classes/${classEntry.class.id}`, { method: 'DELETE' });
            if (state.selectedLectureId) {
              const removed = classEntry.modules.some((moduleEntry) =>
                (moduleEntry.lectures || []).some(
                  (lecture) => lecture.id === state.selectedLectureId,
                ),
              );
              if (removed) {
                state.selectedLectureId = null;
                clearDetailPanel();
              }
            }
            showStatus(t('status.classRemoved'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleDeleteModule(moduleEntry, classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const lectureCount = moduleEntry.lectures.length;
          const classContext = classRecord
            ? t('dialogs.deleteModule.classContext', { className: classRecord.name })
            : '';
          let message = t('dialogs.deleteModule.message', {
            moduleName: moduleEntry.module.name,
            classContext,
          });
          if (lectureCount) {
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            message += `\n\n${t('dialogs.deleteModule.summary', {
              lectureCount,
              lectureWord,
            })}`;
          }
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteModule.title'),
            message,
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteModule.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            await request(`/api/modules/${moduleEntry.module.id}`, { method: 'DELETE' });
            if (state.selectedLectureId) {
              const removed = (moduleEntry.lectures || []).some(
                (lecture) => lecture.id === state.selectedLectureId,
              );
              if (removed) {
                state.selectedLectureId = null;
                clearDetailPanel();
              }
            }
            showStatus(t('status.moduleRemoved'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleAddLecture(moduleRecord, classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const contextParts = classRecord
            ? [classRecord.name, moduleRecord.name]
            : [moduleRecord.name];
          const namePrompt = contextParts.join(' • ');
          const name = await promptDialog({
            title: t('dialogs.createLecture.title'),
            message: t('dialogs.createLecture.message', { context: namePrompt }),
            confirmText: t('common.actions.create'),
            placeholder: t('dialogs.createLecture.placeholder'),
            required: true,
          });
          if (!name || !name.trim()) {
            return;
          }
          const description =
            (await promptDialog({
              title: t('dialogs.lectureDescription.title'),
              message: t('dialogs.descriptionOptional'),
              confirmText: t('common.actions.save'),
              cancelText: t('common.actions.skip'),
              placeholder: t('dialogs.lectureDescription.placeholder'),
            })) ?? '';
          try {
            const payload = await request('/api/lectures', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                module_id: moduleRecord.id,
                name: name.trim(),
                description: description.trim(),
              }),
            });
            showStatus(t('status.lectureCreated'), 'success');
            await refreshData();
            const newLectureId = payload?.lecture?.id;
            if (newLectureId) {
              await selectLecture(newLectureId);
            }
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleDeleteLecture(lecture, moduleRecord, classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const contextParts = [lecture.name];
          if (moduleRecord) {
            contextParts.push(moduleRecord.name);
          }
          if (classRecord) {
            contextParts.push(classRecord.name);
          }
          const context = contextParts.join(' • ');
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteLecture.title'),
            message: t('dialogs.deleteLecture.message', { context }),
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteLecture.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            await request(`/api/lectures/${lecture.id}`, { method: 'DELETE' });
            if (state.selectedLectureId === lecture.id) {
              state.selectedLectureId = null;
              clearDetailPanel();
            }
            showStatus(t('status.lectureRemoved'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        function applyTheme(theme) {
          const target = theme || 'system';
          document.body.dataset.theme = target;
        }

        async function loadSettings() {
          try {
            const payload = await request('/api/settings');
            const settings = payload?.settings;
            if (!settings) {
              return;
            }
            syncSettingsForm(settings);
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        function renderAssets(lecture) {
          dom.assetList.innerHTML = '';
          assetDefinitions.forEach((definition) => {
            const value = lecture[definition.key];
            const item = document.createElement('li');
            item.className = 'asset-item';
            const header = document.createElement('div');
            header.className = 'asset-header';
            header.textContent = t(definition.labelKey);
            item.appendChild(header);

            const status = document.createElement('div');
            status.className = 'asset-status';
            let statusText = t('assets.status.notLinked');
            if (value) {
              const fileName = value.split('/').pop();
              if (definition.type === 'slides') {
                statusText = t('assets.status.linkedSlides', { name: fileName });
              } else if (definition.type === 'slide_images') {
                statusText = t('assets.status.archiveCreated', { name: fileName });
              } else {
                statusText = t('assets.status.linked', { name: fileName });
              }
            } else if (definition.type === 'slides') {
              statusText = t('assets.status.slidesHint');
            } else if (definition.type === 'slide_images') {
              statusText = t('assets.status.noSlideImages');
            }
            status.textContent = statusText;
            item.appendChild(status);

            const actions = document.createElement('div');
            actions.className = 'asset-actions';

            if (definition.accept) {
              const wrapper = document.createElement('label');
              wrapper.className = 'file-input';
              const span = document.createElement('span');
              span.textContent = t('assets.actions.upload');
              const input = document.createElement('input');
              input.type = 'file';
              input.accept = definition.accept;
              input.addEventListener('change', (event) => {
                const target = event.target;
                const file = target.files && target.files[0];
                target.value = '';
                if (file) {
                  handleAssetUpload(definition.type, file);
                }
              });
              wrapper.appendChild(span);
              wrapper.appendChild(input);
              actions.appendChild(wrapper);
            }

            const link = document.createElement('a');
            link.textContent = t('assets.actions.open');
            if (value) {
              link.href = buildStorageURL(value);
              link.target = '_blank';
              link.rel = 'noopener';
            } else {
              link.href = '#';
              link.setAttribute('aria-disabled', 'true');
            }
            actions.appendChild(link);

            if (definition.reveal) {
              const revealButton = document.createElement('button');
              revealButton.type = 'button';
              revealButton.className = 'secondary';
              revealButton.textContent =
                definition.reveal === 'folder'
                  ? t('assets.actions.revealFolder')
                  : t('assets.actions.revealLocation');
              revealButton.disabled = !value;
              revealButton.addEventListener('click', () => {
                if (value) {
                  revealAsset(value, definition.reveal);
                }
              });
              actions.appendChild(revealButton);
            }

            item.appendChild(actions);
            dom.assetList.appendChild(item);
          });
        }

        function renderSummary(detail) {
          const lecture = detail.lecture;
          const module = detail.module;
          const classRecord = detail.class;

          dom.summary.classList.remove('placeholder');
          dom.summary.innerHTML = '';

          const title = document.createElement('h3');
          title.textContent = lecture.name;
          dom.summary.appendChild(title);

          const context = document.createElement('div');
          context.className = 'asset-status';
          context.textContent = `${classRecord.name} • ${module.name}`;
          dom.summary.appendChild(context);

          const description = document.createElement('p');
          description.textContent = lecture.description || t('details.noDescription');
          dom.summary.appendChild(description);
        }

        async function refreshData() {
          try {
            const payload = await request('/api/classes');
            state.classes = payload?.classes || [];
            state.stats = payload?.stats || {};
            state.storage.initialized = false;
            state.storage.overview = null;
            state.storage.usage = null;
            updateStats();
            updateModuleOptions();
            renderCurriculum();

            if (state.selectedLectureId) {
              const exists = state.classes.some((klass) =>
                (klass.modules || []).some((module) =>
                  (module.lectures || []).some((lecture) => lecture.id === state.selectedLectureId),
                ),
              );
              if (!exists) {
                state.selectedLectureId = null;
                clearDetailPanel();
              }
            }
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function selectLecture(lectureId) {
          state.selectedLectureId = lectureId;
          highlightSelected();
          setActiveView('details');
          try {
            const detail = await request(`/api/lectures/${lectureId}`);
            if (!detail) {
              return;
            }
            renderSummary(detail);
            dom.assetSection.hidden = false;

            dom.editName.value = detail.lecture.name;
            dom.editDescription.value = detail.lecture.description || '';
            dom.editModule.value = String(detail.lecture.module_id);

            updateEditControlsAvailability();

            if (state.editMode) {
              dom.editName.focus();
            }

            dom.transcribeButton.disabled = !detail.lecture.audio_path;

            renderAssets(detail.lecture);
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleAssetUpload(kind, file) {
          if (!state.selectedLectureId) {
            return;
          }
          const formData = new FormData();
          formData.append('file', file);
          try {
            await request(`/api/lectures/${state.selectedLectureId}/assets/${kind}`, {
              method: 'POST',
              body: formData,
            });
            const successMessage =
              kind === 'slides'
                ? t('status.slidesProcessed')
                : t('status.assetUploaded');
            showStatus(successMessage, 'success');
            await refreshData();
            await selectLecture(state.selectedLectureId);
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        function buildRevealPayload(relativePath, mode = 'file') {
          if (!relativePath) {
            return null;
          }
          if (mode === 'folder') {
            const segments = relativePath.split('/').filter(Boolean);
            if (segments.length > 1) {
              segments.pop();
              return { path: segments.join('/'), select: false };
            }
            return { path: relativePath, select: false };
          }
          return { path: relativePath, select: true };
        }

        async function revealAsset(relativePath, mode = 'file') {
          const payload = buildRevealPayload(relativePath, mode);
          if (!payload) {
            return;
          }
          try {
            await request('/api/assets/reveal', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            const message =
              mode === 'folder'
                ? t('status.openingFolder')
                : t('status.openingLocation');
            showStatus(message, 'info');
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        if (dom.storage && dom.storage.refresh) {
          dom.storage.refresh.addEventListener('click', () => {
            refreshStorage();
          });
        }

        if (dom.storage && dom.storage.purge) {
          dom.storage.purge.addEventListener('click', () => {
            handlePurgeProcessedAudio();
          });
        }

        dom.viewButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const view = button.dataset.view;
            if (!view) {
              return;
            }
            setActiveView(view);
            if (view === 'create') {
              dom.createModule.focus();
            } else if (view === 'details' && state.editMode && state.selectedLectureId) {
              dom.editName.focus();
            }
          });
        });

        if (dom.editToggle) {
          dom.editToggle.addEventListener('click', () => {
            state.editMode = !state.editMode;
            updateEditModeUI();
            if (state.editMode && state.selectedLectureId) {
              setActiveView('details');
              dom.editName.focus();
            }
          });
        }

        dom.search.addEventListener('input', (event) => {
          state.query = event.target.value;
          renderCurriculum();
        });

        dom.editForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (!state.editMode) {
            showStatus(t('status.requireEditLecture'), 'info');
            return;
          }
          if (!state.selectedLectureId) {
            return;
          }
          const payload = {
            name: dom.editName.value.trim(),
            description: dom.editDescription.value.trim(),
          };
          const moduleValue = dom.editModule.value;
          if (moduleValue) {
            payload.module_id = Number(moduleValue);
          }
          if (!payload.name) {
            showStatus(t('status.lectureTitleRequired'), 'error');
            return;
          }
          try {
            await request(`/api/lectures/${state.selectedLectureId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            showStatus(t('status.lectureUpdated'), 'success');
            await refreshData();
            await selectLecture(state.selectedLectureId);
          } catch (error) {
            showStatus(error.message, 'error');
          }
        });

        dom.deleteButton.addEventListener('click', async () => {
          if (!state.selectedLectureId || !state.editMode) {
            return;
          }
          const lectureName = dom.editName.value.trim() || dom.editName.placeholder || '';
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteLecture.title'),
            message: t('dialogs.deleteLecture.message', { context: lectureName }),
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteLecture.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          const secondCheck = await confirmDialog({
            title: t('dialogs.confirmDeletion.title'),
            message: t('dialogs.confirmDeletion.message'),
            confirmText: t('dialogs.confirmDeletion.confirm'),
            cancelText: t('dialog.cancel'),
            variant: 'danger',
          });
          if (!secondCheck) {
            return;
          }
          try {
            await request(`/api/lectures/${state.selectedLectureId}`, { method: 'DELETE' });
            showStatus(t('status.lectureRemoved'), 'success');
            state.selectedLectureId = null;
            clearDetailPanel();
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        });

        dom.createForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          const moduleId = Number(dom.createModule.value);
          const name = dom.createName.value.trim();
          const description = dom.createDescription.value.trim();
          if (!moduleId || !name) {
            showStatus(t('status.createLectureRequirements'), 'error');
            return;
          }
          try {
            const payload = await request('/api/lectures', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ module_id: moduleId, name, description }),
            });
            dom.createForm.reset();
            showStatus(t('status.lectureCreated'), 'success');
            await refreshData();
            const newLectureId = payload?.lecture?.id;
            if (newLectureId) {
              await selectLecture(newLectureId);
            }
          } catch (error) {
            showStatus(error.message, 'error');
          }
        });

        dom.transcribeButton.addEventListener('click', async () => {
          if (!state.selectedLectureId) {
            return;
          }
          const lectureId = state.selectedLectureId;
          const selectedModel = dom.transcribeModel.value;
          dom.transcribeButton.disabled = true;
          showStatus(t('status.transcriptionPreparing'), 'info', { persist: true });
          startTranscriptionProgress(lectureId);
          try {
            const payload = await request(`/api/lectures/${lectureId}/transcribe`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ model: selectedModel }),
            });
            stopTranscriptionProgress();
            const fallbackModel = payload?.fallback_model;
            if (fallbackModel) {
              const fallbackReason =
                typeof payload?.fallback_reason === 'string'
                  ? payload.fallback_reason
                  : t('status.gpuNotAvailable');
              await showDialog({
                title: t('dialogs.gpuWhisper.title'),
                message: `${fallbackReason} ${t('status.gpuFallback', { model: fallbackModel })}`,
                confirmText: t('common.actions.ok'),
                cancelText: t('common.actions.close'),
                variant: 'danger',
              });
              if (dom.transcribeModel) {
                dom.transcribeModel.value = fallbackModel;
              }
              if (dom.settingsWhisperModel) {
                dom.settingsWhisperModel.value = fallbackModel;
              }
              if (state.settings) {
                state.settings.whisper_model = fallbackModel;
                state.settings.whisper_model_requested = fallbackModel;
              }
              await loadGpuWhisperStatus();
            } else if (selectedModel === GPU_MODEL) {
              await loadGpuWhisperStatus();
            }
            showStatus(t('status.transcriptionCompleted'), 'success', { progressRatio: 1 });
            await refreshData();
            await selectLecture(lectureId);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            stopTranscriptionProgress();
            const progress = await fetchTranscriptionProgress(state.selectedLectureId);
            if (progress && progress.message) {
              showStatus(progress.message, progress.error ? 'error' : 'info', {
                progressRatio: progress.ratio,
                persist: !progress.finished,
              });
            } else {
              showStatus(message, 'error');
            }
          } finally {
            dom.transcribeButton.disabled = false;
          }
        });

        if (dom.settingsWhisperGpuTest) {
          dom.settingsWhisperGpuTest.addEventListener('click', async () => {
            if (state.gpuWhisper.unavailable) {
              return;
            }
            dom.settingsWhisperGpuTest.disabled = true;
            showStatus(t('status.gpuChecking'), 'info');
            try {
              const payload = await request('/api/settings/whisper-gpu/test', {
                method: 'POST',
              });
              const status = payload?.status || {};
              updateGpuWhisperUI(status);
              if (status.supported) {
                showStatus(t('status.gpuConfirmed'), 'success');
                if (state.settings?.whisper_model_requested === GPU_MODEL) {
                  if (dom.settingsWhisperModel) {
                    dom.settingsWhisperModel.value = GPU_MODEL;
                  }
                  if (dom.transcribeModel) {
                    dom.transcribeModel.value = GPU_MODEL;
                  }
                  state.settings.whisper_model = GPU_MODEL;
                }
              } else {
                const failureMessage =
                  typeof status.message === 'string' && status.message
                    ? status.message
                    : t('status.gpuUnsupported');
                await showDialog({
                  title: t('dialogs.gpuWhisper.title'),
                  message: failureMessage,
                  confirmText: t('common.actions.ok'),
                  cancelText: t('common.actions.close'),
                  variant: 'danger',
                });
                showStatus(failureMessage, 'error');
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              showStatus(message, 'error');
            } finally {
              dom.settingsWhisperGpuTest.disabled = state.gpuWhisper.unavailable;
            }
          });
        }

        if (dom.settingsExport) {
          dom.settingsExport.addEventListener('click', async () => {
            dom.settingsExport.disabled = true;
            showStatus(t('status.exporting'), 'info');
            try {
              const payload = await request('/api/settings/export', { method: 'POST' });
              const archive = payload?.archive;
              if (!archive || !archive.path) {
                throw new Error(t('status.exportFailed'));
              }
              const link = document.createElement('a');
              link.href = buildStorageURL(archive.path);
              link.download = archive.filename || 'lecture-tools-export.zip';
              document.body.appendChild(link);
              link.click();
              link.remove();
              showStatus(t('status.exportReady'), 'success');
            } catch (error) {
              showStatus(error.message, 'error');
            } finally {
              dom.settingsExport.disabled = false;
            }
          });
        }

        if (dom.settingsImport) {
          dom.settingsImport.addEventListener('change', async (event) => {
            const input = event.target;
            const files = input?.files || [];
            if (!files.length) {
              return;
            }
            const file = files[0];
            const formData = new FormData();
            formData.append('file', file);
            if (dom.settingsImportMode) {
              formData.append('mode', dom.settingsImportMode.value || 'merge');
            }
            dom.settingsImport.disabled = true;
            if (dom.settingsExport) {
              dom.settingsExport.disabled = true;
            }
            showStatus(t('status.importing'), 'info');
            try {
              const payload = await request('/api/settings/import', {
                method: 'POST',
                body: formData,
              });
              const summary = payload?.import;
              if (summary) {
                const count = Number(summary.lectures || 0);
                if (count > 0) {
                  showStatus(t('status.importSuccess', { count }), 'success');
                } else {
                  showStatus(t('status.importNoChanges'), 'success');
                }
              } else {
                showStatus(t('status.importSuccess', { count: 0 }), 'success');
              }
              await refreshData();
            } catch (error) {
              showStatus(error.message, 'error');
            } finally {
              dom.settingsImport.value = '';
              dom.settingsImport.disabled = false;
              if (dom.settingsExport) {
                dom.settingsExport.disabled = false;
              }
            }
          });
        }

        if (dom.settingsExitApp) {
          dom.settingsExitApp.addEventListener('click', async () => {
            const { confirmed } = await showDialog({
              title: t('dialogs.exitApp.title'),
              message: t('dialogs.exitApp.message'),
              confirmText: t('common.actions.exit'),
              cancelText: t('dialog.cancel'),
              variant: 'danger',
            });
            if (!confirmed) {
              return;
            }

            dom.settingsExitApp.disabled = true;
            showStatus(t('status.shuttingDown'), 'info');

            try {
              await request('/api/system/shutdown', { method: 'POST' });
              window.setTimeout(() => {
                try {
                  window.close();
                } catch (error) {
                  // Ignore inability to close the window.
                }
                try {
                  window.location.replace('about:blank');
                } catch (error) {
                  // Ignore navigation failures.
                }
              }, 300);
            } catch (error) {
              dom.settingsExitApp.disabled = false;
              const message = error instanceof Error ? error.message : String(error);
              showStatus(message, 'error');
            }
          });
        }

        if (dom.settingsLanguage) {
          dom.settingsLanguage.addEventListener('change', (event) => {
            const value = normalizeLanguage(event.target.value);
            applyTranslations(value);
            renderStorage();
            updateEditModeUI();
          });
        }

        if (dom.settingsForm) {
          dom.settingsForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const themeValue = dom.settingsTheme.value || 'system';
            const languageValue = normalizeLanguage(dom.settingsLanguage.value);
            const modelValue = normalizeWhisperModel(dom.settingsWhisperModel.value);
            const computeValue = dom.settingsWhisperCompute.value.trim() || 'int8';
            const beamValue = Math.max(
              1,
              Math.min(10, Number(dom.settingsWhisperBeam.value) || 5),
            );
            const dpiValue = Number(normalizeSlideDpi(dom.settingsSlideDpi.value));

            try {
              const response = await request('/api/settings', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  theme: themeValue,
                  language: languageValue,
                  whisper_model: modelValue,
                  whisper_compute_type: computeValue,
                  whisper_beam_size: beamValue,
                  slide_dpi: dpiValue,
                }),
              });
              const updatedSettings = response?.settings ?? {
                theme: themeValue,
                language: languageValue,
                whisper_model: modelValue,
                whisper_compute_type: computeValue,
                whisper_beam_size: beamValue,
                slide_dpi: dpiValue,
              };
              syncSettingsForm(updatedSettings);
              if (modelValue === GPU_MODEL) {
                await loadGpuWhisperStatus();
              }
              showStatus(t('status.settingsSaved'), 'success');
            } catch (error) {
              showStatus(error.message, 'error');
            }
          });
        }
        setActiveView(state.activeView);
        updateEditModeUI();
        clearDetailPanel();
        applyTheme('system');
        await loadGpuWhisperStatus();
        await loadSettings();
        await refreshData();
      })();
    </script>
  </body>
</html>
