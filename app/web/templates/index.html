<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title data-i18n="document.title">Lecture Tools</title>
    <script>
      window.__LECTURE_TOOLS_SERVER_ROOT_PATH__ = "__LECTURE_TOOLS_ROOT_PATH__";
      window.__LECTURE_TOOLS_PDFJS_SCRIPT_URL__ = "__LECTURE_TOOLS_PDFJS_SCRIPT__";
      window.__LECTURE_TOOLS_PDFJS_WORKER_URL__ = "__LECTURE_TOOLS_PDFJS_WORKER__";
      window.__LECTURE_TOOLS_PDFJS_MODULE_URL__ = "__LECTURE_TOOLS_PDFJS_MODULE__";
      window.__LECTURE_TOOLS_PDFJS_WORKER_MODULE_URL__ =
        "__LECTURE_TOOLS_PDFJS_WORKER_MODULE__";
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --background: #f3edff;
        --background-gradient: linear-gradient(135deg, #eaf4ff 0%, #eee4ff 48%, #ffe8fa 100%);
        --text: #1e1b43;
        --muted: #625a86;
        --panel-bg: rgba(255, 255, 255, 0.92);
        --panel-border: rgba(199, 186, 255, 0.65);
        --panel-shadow: 0 18px 36px rgba(119, 103, 187, 0.18);
        --panel-shadow-high: 0 28px 60px rgba(119, 103, 187, 0.28);
        --accent: #c9afff;
        --accent-contrast: #1f163b;
        --accent-muted: rgba(201, 175, 255, 0.24);
        --accent-soft: rgba(201, 175, 255, 0.18);
        --accent-glow: rgba(201, 175, 255, 0.36);
        --accent-strong: rgba(201, 175, 255, 0.55);
        --accent-highlight: rgba(201, 175, 255, 0.65);
        --danger: #ffa9b5;
        --danger-contrast: #2c1421;
        --placeholder: #837aa6;
        --status-info-bg: rgba(201, 175, 255, 0.18);
        --status-info-text: #42327a;
        --status-error-bg: rgba(255, 169, 181, 0.22);
        --status-error-text: #a34051;
        --status-success-bg: rgba(156, 246, 205, 0.22);
        --status-success-text: #1a7a58;
        --status-progress-track: rgba(49, 34, 94, 0.16);
      }

      body {
        --bright-background: #f3edff;
        --bright-background-gradient: linear-gradient(135deg, #eaf4ff 0%, #eee4ff 48%, #ffe8fa 100%);
        --bright-text: #120f2c;
        --bright-muted: #2d2855;
        --bright-panel-bg: rgba(255, 255, 255, 0.92);
        --bright-panel-border: rgba(199, 186, 255, 0.65);
        --bright-panel-shadow: 0 18px 36px rgba(119, 103, 187, 0.18);
        --bright-panel-shadow-high: 0 28px 60px rgba(119, 103, 187, 0.28);
        --bright-panel-sheen: linear-gradient(
          140deg,
          rgba(255, 255, 255, 0.85) 0%,
          rgba(255, 255, 255, 0.45) 45%,
          rgba(255, 255, 255, 0) 100%
        );
        --bright-accent: #c9afff;
        --bright-accent-contrast: #1f163b;
        --bright-accent-muted: rgba(201, 175, 255, 0.24);
        --bright-accent-soft: rgba(201, 175, 255, 0.18);
        --bright-accent-glow: rgba(201, 175, 255, 0.36);
        --bright-accent-strong: rgba(201, 175, 255, 0.55);
        --bright-accent-highlight: rgba(201, 175, 255, 0.65);
        --bright-danger: #ffa9b5;
        --bright-danger-contrast: #2c1421;
        --bright-placeholder: #837aa6;
        --bright-status-info-bg: rgba(201, 175, 255, 0.18);
        --bright-status-info-text: #42327a;
        --bright-status-error-bg: rgba(255, 169, 181, 0.22);
        --bright-status-error-text: #a34051;
        --bright-status-success-bg: rgba(156, 246, 205, 0.22);
        --bright-status-success-text: #1a7a58;
        --bright-status-progress-track: rgba(49, 34, 94, 0.16);

        --bright-interactive-text: #120f2c;
        --bright-interactive-subtle: #2d2855;
        --bright-chrome-shadow: 0 28px 46px rgba(62, 36, 126, 0.18);
        --bright-chrome-border: rgba(201, 175, 255, 0.55);
        --bright-chrome-sheen: linear-gradient(
          128deg,
          rgba(255, 255, 255, 0.72) 0%,
          rgba(201, 175, 255, 0.36) 50%,
          rgba(186, 218, 255, 0.18) 100%
        );
        --bright-nav-button-bg: rgba(255, 255, 255, 0.88);
        --bright-nav-button-hover: rgba(255, 255, 255, 0.98);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(201, 175, 255, 0.6);
        --bright-nav-button-shadow: 0 18px 38px rgba(62, 36, 126, 0.22);
        --bright-nav-button-active-shadow: 0 24px 46px rgba(58, 28, 120, 0.32);
        --bright-chrome-radius: 26px;
        --bright-nav-button-radius: 18px;
        --bright-ambient-1: rgba(114, 174, 255, 0.35);
        --bright-ambient-2: rgba(216, 171, 255, 0.32);
        --bright-ambient-3: rgba(255, 186, 233, 0.3);

        --dark-background: #081321;
        --dark-background-gradient: linear-gradient(150deg, #071421 0%, #0f2737 48%, #13404a 100%);
        --dark-text: #f5f8ff;
        --dark-muted: #c4dbff;
        --dark-panel-bg: rgba(15, 28, 45, 0.92);
        --dark-panel-border: rgba(73, 111, 149, 0.55);
        --dark-panel-shadow: 0 24px 46px rgba(6, 20, 32, 0.6);
        --dark-panel-shadow-high: 0 32px 68px rgba(6, 20, 32, 0.72);
        --dark-panel-sheen: linear-gradient(
          140deg,
          rgba(18, 32, 52, 0.9) 0%,
          rgba(14, 26, 42, 0.55) 55%,
          rgba(10, 20, 32, 0) 100%
        );
        --dark-accent: #6fe1ff;
        --dark-accent-contrast: #041019;
        --dark-accent-muted: rgba(111, 225, 255, 0.24);
        --dark-accent-soft: rgba(111, 225, 255, 0.18);
        --dark-accent-glow: rgba(111, 225, 255, 0.32);
        --dark-accent-strong: rgba(111, 225, 255, 0.42);
        --dark-accent-highlight: rgba(111, 225, 255, 0.5);
        --dark-danger: #ff9aad;
        --dark-danger-contrast: #1f070f;
        --dark-placeholder: #90a9c0;
        --dark-status-info-bg: rgba(88, 212, 255, 0.22);
        --dark-status-info-text: #d6f6ff;
        --dark-status-error-bg: rgba(255, 154, 173, 0.22);
        --dark-status-error-text: #ffd9e1;
        --dark-status-success-bg: rgba(156, 246, 205, 0.2);
        --dark-status-success-text: #a8f5d7;
        --dark-status-progress-track: rgba(255, 255, 255, 0.22);

        --dark-interactive-text: #f6f8ff;
        --dark-interactive-subtle: #c6ddff;
        --dark-chrome-shadow: 0 36px 60px rgba(5, 15, 35, 0.75);
        --dark-chrome-border: rgba(111, 225, 255, 0.26);
        --dark-chrome-sheen: linear-gradient(
          140deg,
          rgba(20, 36, 60, 0.8) 0%,
          rgba(111, 225, 255, 0.3) 50%,
          rgba(58, 144, 199, 0.18) 100%
        );
        --dark-nav-button-bg: rgba(18, 34, 55, 0.82);
        --dark-nav-button-hover: rgba(26, 48, 74, 0.96);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(111, 225, 255, 0.32);
        --dark-nav-button-shadow: 0 26px 50px rgba(4, 12, 28, 0.7);
        --dark-nav-button-active-shadow: 0 32px 58px rgba(6, 16, 36, 0.78);
        --dark-chrome-radius: 26px;
        --dark-nav-button-radius: 18px;
        --dark-ambient-1: rgba(72, 150, 255, 0.25);
        --dark-ambient-2: rgba(120, 200, 255, 0.22);
        --dark-ambient-3: rgba(152, 140, 255, 0.25);

        --background: var(--bright-background);
        --background-gradient: var(--bright-background-gradient);
        --text: var(--bright-text);
        --muted: var(--bright-muted);
        --panel-bg: var(--bright-panel-bg);
        --panel-border: var(--bright-panel-border);
        --panel-shadow: var(--bright-panel-shadow);
        --panel-shadow-high: var(--bright-panel-shadow-high);
        --panel-sheen: var(--bright-panel-sheen);
        --accent: var(--bright-accent);
        --accent-contrast: var(--bright-accent-contrast);
        --accent-muted: var(--bright-accent-muted);
        --accent-soft: var(--bright-accent-soft);
        --accent-glow: var(--bright-accent-glow);
        --accent-strong: var(--bright-accent-strong);
        --accent-highlight: var(--bright-accent-highlight);
        --danger: var(--bright-danger);
        --danger-contrast: var(--bright-danger-contrast);
        --placeholder: var(--bright-placeholder);
        --status-info-bg: var(--bright-status-info-bg);
        --status-info-text: var(--bright-status-info-text);
        --status-error-bg: var(--bright-status-error-bg);
        --status-error-text: var(--bright-status-error-text);
        --status-success-bg: var(--bright-status-success-bg);
        --status-success-text: var(--bright-status-success-text);
        --status-progress-track: var(--bright-status-progress-track);
        --interactive-text: var(--bright-interactive-text, var(--bright-text));
        --interactive-subtle: var(
          --bright-interactive-subtle,
          var(--bright-muted)
        );
        --panel-radius: 16px;
        --chrome-radius: var(--bright-chrome-radius, 22px);
        --nav-button-radius: var(--bright-nav-button-radius, 16px);
        --nav-button-clip: var(--bright-nav-button-clip, none);
        --chrome-shadow: var(--bright-chrome-shadow, var(--panel-shadow));
        --chrome-border: var(--bright-chrome-border, rgba(255, 255, 255, 0.4));
        --chrome-sheen: var(
          --bright-chrome-sheen,
          linear-gradient(
            125deg,
            rgba(255, 255, 255, 0.8) 0%,
            rgba(255, 255, 255, 0.35) 55%,
            transparent 100%
          )
        );
        --nav-button-bg: var(
          --bright-nav-button-bg,
          rgba(255, 255, 255, 0.9)
        );
        --nav-button-hover: var(
          --bright-nav-button-hover,
          rgba(255, 255, 255, 1)
        );
        --nav-button-active: var(--bright-nav-button-active, var(--accent));
        --nav-button-border: var(
          --bright-nav-button-border,
          rgba(255, 255, 255, 0.7)
        );
        --nav-button-shadow: var(
          --bright-nav-button-shadow,
          0 14px 32px rgba(20, 16, 60, 0.2)
        );
        --nav-button-active-shadow: var(
          --bright-nav-button-active-shadow,
          0 18px 38px rgba(32, 24, 82, 0.26)
        );
        --ambient-1: var(--bright-ambient-1);
        --ambient-2: var(--bright-ambient-2);
        --ambient-3: var(--bright-ambient-3);
      }

      body[data-display-mode='bright'] {
        color-scheme: light;
      }

      body[data-display-mode='dark'] {
        color-scheme: dark;
        --background: var(--dark-background);
        --background-gradient: var(--dark-background-gradient);
        --text: var(--dark-text);
        --muted: var(--dark-muted);
        --panel-bg: var(--dark-panel-bg);
        --panel-border: var(--dark-panel-border);
        --panel-shadow: var(--dark-panel-shadow);
        --panel-shadow-high: var(--dark-panel-shadow-high);
        --panel-sheen: var(--dark-panel-sheen);
        --accent: var(--dark-accent);
        --accent-contrast: var(--dark-accent-contrast);
        --accent-muted: var(--dark-accent-muted);
        --accent-soft: var(--dark-accent-soft);
        --accent-glow: var(--dark-accent-glow);
        --accent-strong: var(--dark-accent-strong);
        --accent-highlight: var(--dark-accent-highlight);
        --danger: var(--dark-danger);
        --danger-contrast: var(--dark-danger-contrast);
        --placeholder: var(--dark-placeholder);
        --status-info-bg: var(--dark-status-info-bg);
        --status-info-text: var(--dark-status-info-text);
        --status-error-bg: var(--dark-status-error-bg);
        --status-error-text: var(--dark-status-error-text);
        --status-success-bg: var(--dark-status-success-bg);
        --status-success-text: var(--dark-status-success-text);
        --status-progress-track: var(--dark-status-progress-track);
        --interactive-text: var(--dark-interactive-text, var(--dark-text));
        --interactive-subtle: var(
          --dark-interactive-subtle,
          var(--dark-muted)
        );
        --chrome-radius: var(--dark-chrome-radius, 22px);
        --nav-button-radius: var(--dark-nav-button-radius, 16px);
        --nav-button-clip: var(--dark-nav-button-clip, none);
        --chrome-shadow: var(--dark-chrome-shadow, var(--panel-shadow));
        --chrome-border: var(--dark-chrome-border, rgba(255, 255, 255, 0.24));
        --chrome-sheen: var(
          --dark-chrome-sheen,
          linear-gradient(
            130deg,
            rgba(12, 24, 38, 0.85) 0%,
            rgba(40, 62, 82, 0.55) 60%,
            transparent 100%
          )
        );
        --nav-button-bg: var(
          --dark-nav-button-bg,
          rgba(12, 26, 45, 0.8)
        );
        --nav-button-hover: var(
          --dark-nav-button-hover,
          rgba(24, 42, 64, 0.92)
        );
        --nav-button-active: var(--dark-nav-button-active, var(--accent));
        --nav-button-border: var(
          --dark-nav-button-border,
          rgba(255, 255, 255, 0.14)
        );
        --nav-button-shadow: var(
          --dark-nav-button-shadow,
          0 24px 48px rgba(4, 10, 24, 0.6)
        );
        --nav-button-active-shadow: var(
          --dark-nav-button-active-shadow,
          0 28px 52px rgba(6, 18, 38, 0.72)
        );
        --ambient-1: var(--dark-ambient-1);
        --ambient-2: var(--dark-ambient-2);
        --ambient-3: var(--dark-ambient-3);
      }

      body[data-display-mode='system'] {
        color-scheme: light;
      }

      @media (prefers-color-scheme: dark) {
        body[data-display-mode='system'] {
          color-scheme: dark;
          --background: var(--dark-background);
          --background-gradient: var(--dark-background-gradient);
          --text: var(--dark-text);
          --muted: var(--dark-muted);
          --panel-bg: var(--dark-panel-bg);
          --panel-border: var(--dark-panel-border);
          --panel-shadow: var(--dark-panel-shadow);
          --panel-shadow-high: var(--dark-panel-shadow-high);
          --panel-sheen: var(--dark-panel-sheen);
          --accent: var(--dark-accent);
          --accent-contrast: var(--dark-accent-contrast);
          --accent-muted: var(--dark-accent-muted);
          --accent-soft: var(--dark-accent-soft);
          --accent-glow: var(--dark-accent-glow);
          --accent-strong: var(--dark-accent-strong);
          --accent-highlight: var(--dark-accent-highlight);
          --danger: var(--dark-danger);
          --danger-contrast: var(--dark-danger-contrast);
          --placeholder: var(--dark-placeholder);
          --status-info-bg: var(--dark-status-info-bg);
          --status-info-text: var(--dark-status-info-text);
          --status-error-bg: var(--dark-status-error-bg);
          --status-error-text: var(--dark-status-error-text);
          --status-success-bg: var(--dark-status-success-bg);
          --status-success-text: var(--dark-status-success-text);
          --status-progress-track: var(--dark-status-progress-track);
          --interactive-text: var(--dark-interactive-text, var(--dark-text));
          --interactive-subtle: var(
            --dark-interactive-subtle,
            var(--dark-muted)
          );
          --chrome-radius: var(--dark-chrome-radius, 22px);
          --nav-button-radius: var(--dark-nav-button-radius, 16px);
          --nav-button-clip: var(--dark-nav-button-clip, none);
          --chrome-shadow: var(--dark-chrome-shadow, var(--panel-shadow));
          --chrome-border: var(--dark-chrome-border, rgba(255, 255, 255, 0.24));
          --chrome-sheen: var(
            --dark-chrome-sheen,
            linear-gradient(
              130deg,
              rgba(12, 24, 38, 0.85) 0%,
              rgba(40, 62, 82, 0.55) 60%,
              transparent 100%
            )
          );
          --nav-button-bg: var(
            --dark-nav-button-bg,
            rgba(12, 26, 45, 0.8)
          );
          --nav-button-hover: var(
            --dark-nav-button-hover,
            rgba(24, 42, 64, 0.92)
          );
          --nav-button-active: var(--dark-nav-button-active, var(--accent));
          --nav-button-border: var(
            --dark-nav-button-border,
            rgba(255, 255, 255, 0.14)
          );
          --nav-button-shadow: var(
            --dark-nav-button-shadow,
            0 24px 48px rgba(4, 10, 24, 0.6)
          );
          --nav-button-active-shadow: var(
            --dark-nav-button-active-shadow,
            0 28px 52px rgba(6, 18, 38, 0.72)
          );
          --ambient-1: var(--dark-ambient-1);
          --ambient-2: var(--dark-ambient-2);
          --ambient-3: var(--dark-ambient-3);
        }
      }
      
      body[data-theme='vibrant'] {
        --bright-background: #f3edff;
        --bright-background-gradient: linear-gradient(135deg, #eaf4ff 0%, #eee4ff 48%, #ffe8fa 100%);
        --bright-text: #120f2c;
        --bright-muted: #2d2855;
        --bright-panel-bg: rgba(255, 255, 255, 0.92);
        --bright-panel-border: rgba(199, 186, 255, 0.65);
        --bright-panel-shadow: 0 18px 36px rgba(119, 103, 187, 0.18);
        --bright-panel-shadow-high: 0 30px 60px rgba(119, 103, 187, 0.28);
        --bright-accent: #c9afff;
        --bright-accent-contrast: #1f163b;
        --bright-accent-muted: rgba(201, 175, 255, 0.24);
        --bright-accent-soft: rgba(201, 175, 255, 0.18);
        --bright-accent-glow: rgba(201, 175, 255, 0.36);
        --bright-accent-strong: rgba(201, 175, 255, 0.55);
        --bright-accent-highlight: rgba(201, 175, 255, 0.7);
        --bright-danger: #ffa9b5;
        --bright-danger-contrast: #2c1421;
        --bright-placeholder: #837aa6;
        --bright-status-info-bg: rgba(201, 175, 255, 0.18);
        --bright-status-info-text: #42327a;
        --bright-status-error-bg: rgba(255, 169, 181, 0.22);
        --bright-status-error-text: #a34051;
        --bright-status-success-bg: rgba(156, 246, 205, 0.22);
        --bright-status-success-text: #1a7a58;
        --bright-status-progress-track: rgba(49, 34, 94, 0.16);

        --dark-background: #081321;
        --dark-background-gradient: linear-gradient(150deg, #071421 0%, #0f2737 48%, #13404a 100%);
        --dark-text: #f5f8ff;
        --dark-muted: #c4dbff;
        --dark-panel-bg: rgba(15, 28, 45, 0.92);
        --dark-panel-border: rgba(73, 111, 149, 0.55);
        --dark-panel-shadow: 0 24px 46px rgba(6, 20, 32, 0.6);
        --dark-panel-shadow-high: 0 34px 72px rgba(6, 20, 32, 0.72);
        --dark-accent: #6fe1ff;
        --dark-accent-contrast: #041019;
        --dark-accent-muted: rgba(111, 225, 255, 0.24);
        --dark-accent-soft: rgba(111, 225, 255, 0.18);
        --dark-accent-glow: rgba(111, 225, 255, 0.32);
        --dark-accent-strong: rgba(111, 225, 255, 0.42);
        --dark-accent-highlight: rgba(111, 225, 255, 0.52);
        --dark-danger: #ff9aad;
        --dark-danger-contrast: #1f070f;
        --dark-placeholder: #90a9c0;
        --dark-status-info-bg: rgba(88, 212, 255, 0.22);
        --dark-status-info-text: #d6f6ff;
        --dark-status-error-bg: rgba(255, 154, 173, 0.22);
        --dark-status-error-text: #ffd9e1;
        --dark-status-success-bg: rgba(156, 246, 205, 0.2);
        --dark-status-success-text: #a8f5d7;
        --dark-status-progress-track: rgba(255, 255, 255, 0.22);
      }

      body[data-theme='serene'] {
        --bright-background: #ecf7ff;
        --bright-background-gradient: linear-gradient(140deg, #f0e8ff 0%, #ddefff 52%, #cffff9 100%);
        --bright-text: #0f2b45;
        --bright-muted: #1f4c6f;
        --bright-panel-bg: rgba(255, 255, 255, 0.94);
        --bright-panel-border: rgba(200, 225, 255, 0.65);
        --bright-panel-shadow: 0 18px 36px rgba(91, 140, 202, 0.18);
        --bright-panel-shadow-high: 0 28px 58px rgba(91, 140, 202, 0.26);
        --bright-accent: #5bb7ff;
        --bright-accent-contrast: #082133;
        --bright-accent-muted: rgba(91, 183, 255, 0.22);
        --bright-accent-soft: rgba(91, 183, 255, 0.16);
        --bright-accent-glow: rgba(91, 183, 255, 0.36);
        --bright-accent-strong: rgba(91, 183, 255, 0.5);
        --bright-accent-highlight: rgba(91, 183, 255, 0.58);
        --bright-danger: #ff9fb3;
        --bright-danger-contrast: #32111f;
        --bright-placeholder: #5c7a98;
        --bright-status-info-bg: rgba(189, 219, 255, 0.3);
        --bright-status-info-text: #225289;
        --bright-status-error-bg: rgba(255, 159, 179, 0.24);
        --bright-status-error-text: #96273f;
        --bright-status-success-bg: rgba(156, 246, 205, 0.2);
        --bright-status-success-text: #1f7253;
        --bright-status-progress-track: rgba(91, 183, 255, 0.2);

        --bright-interactive-text: #0f2b45;
        --bright-interactive-subtle: #1f4c6f;
        --bright-chrome-shadow: 0 26px 48px rgba(36, 92, 150, 0.2);
        --bright-chrome-border: rgba(160, 210, 255, 0.55);
        --bright-chrome-sheen: linear-gradient(
          125deg,
          rgba(255, 255, 255, 0.7) 0%,
          rgba(120, 180, 255, 0.38) 48%,
          rgba(200, 245, 255, 0.2) 100%
        );
        --bright-nav-button-bg: rgba(255, 255, 255, 0.9);
        --bright-nav-button-hover: rgba(255, 255, 255, 1);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(120, 180, 255, 0.6);
        --bright-nav-button-shadow: 0 18px 34px rgba(36, 92, 150, 0.2);
        --bright-nav-button-active-shadow: 0 24px 42px rgba(20, 72, 132, 0.3);
        --bright-chrome-radius: 32px;
        --bright-nav-button-radius: 20px;

        --dark-background: #0c111f;
        --dark-background-gradient: linear-gradient(155deg, #10152c 0%, #112f3c 50%, #0f4136 100%);
        --dark-text: #f1fff9;
        --dark-muted: #b9e4da;
        --dark-panel-bg: rgba(14, 27, 38, 0.92);
        --dark-panel-border: rgba(74, 122, 115, 0.55);
        --dark-panel-shadow: 0 24px 46px rgba(6, 20, 24, 0.6);
        --dark-panel-shadow-high: 0 34px 70px rgba(6, 20, 24, 0.7);
        --dark-accent: #9cf6cd;
        --dark-accent-contrast: #041910;
        --dark-accent-muted: rgba(156, 246, 205, 0.24);
        --dark-accent-soft: rgba(156, 246, 205, 0.18);
        --dark-accent-glow: rgba(156, 246, 205, 0.32);
        --dark-accent-strong: rgba(156, 246, 205, 0.42);
        --dark-accent-highlight: rgba(156, 246, 205, 0.52);
        --dark-danger: #ffa9b5;
        --dark-danger-contrast: #1f060d;
        --dark-placeholder: #94b9ac;
        --dark-status-info-bg: rgba(156, 246, 205, 0.18);
        --dark-status-info-text: #dffbee;
        --dark-status-error-bg: rgba(255, 169, 181, 0.22);
        --dark-status-error-text: #ffd6de;
        --dark-status-success-bg: rgba(156, 246, 205, 0.26);
        --dark-status-success-text: #b8ffe5;
        --dark-status-progress-track: rgba(255, 255, 255, 0.18);

        --dark-interactive-text: #f3fff9;
        --dark-interactive-subtle: #b2e7db;
        --dark-chrome-shadow: 0 34px 58px rgba(8, 26, 32, 0.72);
        --dark-chrome-border: rgba(156, 246, 205, 0.28);
        --dark-chrome-sheen: linear-gradient(
          138deg,
          rgba(16, 40, 42, 0.78) 0%,
          rgba(156, 246, 205, 0.32) 50%,
          rgba(120, 220, 210, 0.2) 100%
        );
        --dark-nav-button-bg: rgba(16, 40, 42, 0.82);
        --dark-nav-button-hover: rgba(24, 56, 58, 0.94);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(156, 246, 205, 0.35);
        --dark-nav-button-shadow: 0 26px 46px rgba(6, 20, 24, 0.68);
        --dark-nav-button-active-shadow: 0 34px 54px rgba(7, 24, 24, 0.78);
        --dark-chrome-radius: 30px;
        --dark-nav-button-radius: 20px;
      }

      body[data-theme='pastel'] {
        --bright-background: #fff4f6;
        --bright-background-gradient: linear-gradient(140deg, #e8fff4 0%, #ffe4ec 52%, #fffbe4 100%);
        --bright-text: #2d1424;
        --bright-muted: #4b2637;
        --bright-panel-bg: rgba(255, 255, 255, 0.9);
        --bright-panel-border: rgba(255, 210, 195, 0.6);
        --bright-panel-shadow: 0 20px 40px rgba(255, 173, 208, 0.22);
        --bright-panel-shadow-high: 0 32px 60px rgba(255, 173, 208, 0.3);
        --bright-accent: #ffa9b5;
        --bright-accent-contrast: #331118;
        --bright-accent-muted: rgba(255, 169, 181, 0.26);
        --bright-accent-soft: rgba(255, 169, 181, 0.18);
        --bright-accent-glow: rgba(255, 169, 181, 0.38);
        --bright-accent-strong: rgba(255, 169, 181, 0.55);
        --bright-accent-highlight: rgba(255, 169, 181, 0.68);
        --bright-danger: #ff6f91;
        --bright-danger-contrast: #330b13;
        --bright-placeholder: #b78696;
        --bright-status-info-bg: rgba(255, 210, 140, 0.24);
        --bright-status-info-text: #86532b;
        --bright-status-error-bg: rgba(255, 169, 181, 0.28);
        --bright-status-error-text: #a03653;
        --bright-status-success-bg: rgba(156, 246, 205, 0.24);
        --bright-status-success-text: #2f6e52;
        --bright-status-progress-track: rgba(255, 169, 181, 0.25);

        --bright-interactive-text: #2d1424;
        --bright-interactive-subtle: #4b2637;
        --bright-chrome-shadow: 0 26px 44px rgba(190, 90, 120, 0.22);
        --bright-chrome-border: rgba(255, 189, 208, 0.6);
        --bright-chrome-sheen: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.75) 0%,
          rgba(255, 189, 208, 0.42) 48%,
          rgba(255, 210, 240, 0.22) 100%
        );
        --bright-nav-button-bg: rgba(255, 255, 255, 0.92);
        --bright-nav-button-hover: rgba(255, 255, 255, 1);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(255, 189, 208, 0.6);
        --bright-nav-button-shadow: 0 18px 36px rgba(190, 90, 120, 0.22);
        --bright-nav-button-active-shadow: 0 24px 44px rgba(175, 70, 110, 0.32);
        --bright-chrome-radius: 20px;
        --bright-nav-button-radius: 16px;

        --dark-background: #1b1426;
        --dark-background-gradient: linear-gradient(155deg, #201832 0%, #261c3a 48%, #301e42 100%);
        --dark-text: #fff4fb;
        --dark-muted: #f2cde4;
        --dark-panel-bg: rgba(34, 24, 48, 0.92);
        --dark-panel-border: rgba(213, 171, 223, 0.55);
        --dark-panel-shadow: 0 26px 48px rgba(20, 12, 30, 0.65);
        --dark-panel-shadow-high: 0 36px 74px rgba(20, 12, 30, 0.75);
        --dark-accent: #ffbdd0;
        --dark-accent-contrast: #2b0d19;
        --dark-accent-muted: rgba(255, 189, 208, 0.26);
        --dark-accent-soft: rgba(255, 189, 208, 0.2);
        --dark-accent-glow: rgba(255, 189, 208, 0.36);
        --dark-accent-strong: rgba(255, 189, 208, 0.48);
        --dark-accent-highlight: rgba(255, 189, 208, 0.58);
        --dark-danger: #ff85a1;
        --dark-danger-contrast: #2d0712;
        --dark-placeholder: #d7c6e5;
        --dark-status-info-bg: rgba(205, 177, 255, 0.24);
        --dark-status-info-text: #f4e9ff;
        --dark-status-error-bg: rgba(255, 189, 208, 0.26);
        --dark-status-error-text: #ffe3eb;
        --dark-status-success-bg: rgba(186, 255, 226, 0.22);
        --dark-status-success-text: #e9fff6;
        --dark-status-progress-track: rgba(255, 255, 255, 0.22);

        --dark-interactive-text: #fff7fb;
        --dark-interactive-subtle: #f3d6e8;
        --dark-chrome-shadow: 0 34px 58px rgba(28, 12, 32, 0.72);
        --dark-chrome-border: rgba(255, 189, 208, 0.32);
        --dark-chrome-sheen: linear-gradient(
          140deg,
          rgba(44, 24, 56, 0.82) 0%,
          rgba(255, 189, 208, 0.34) 52%,
          rgba(255, 210, 240, 0.24) 100%
        );
        --dark-nav-button-bg: rgba(44, 24, 56, 0.82);
        --dark-nav-button-hover: rgba(54, 28, 66, 0.95);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(255, 189, 208, 0.38);
        --dark-nav-button-shadow: 0 28px 48px rgba(20, 10, 32, 0.7);
        --dark-nav-button-active-shadow: 0 34px 58px rgba(26, 12, 38, 0.78);
        --dark-chrome-radius: 22px;
        --dark-nav-button-radius: 16px;
      }

      body[data-theme='noir'] {
        --bright-background: #f7f7f7;
        --bright-background-gradient: linear-gradient(135deg, #fdfdfd 0%, #ececec 55%, #d9d9d9 100%);
        --bright-text: #131313;
        --bright-muted: #2f2f2f;
        --bright-panel-bg: rgba(255, 255, 255, 0.94);
        --bright-panel-border: rgba(0, 0, 0, 0.12);
        --bright-panel-shadow: 0 18px 36px rgba(34, 34, 34, 0.12);
        --bright-panel-shadow-high: 0 28px 60px rgba(34, 34, 34, 0.2);
        --bright-accent: #2f2f2f;
        --bright-accent-contrast: #fefefe;
        --bright-accent-muted: rgba(47, 47, 47, 0.2);
        --bright-accent-soft: rgba(47, 47, 47, 0.12);
        --bright-accent-glow: rgba(47, 47, 47, 0.32);
        --bright-accent-strong: rgba(47, 47, 47, 0.48);
        --bright-accent-highlight: rgba(47, 47, 47, 0.58);
        --bright-danger: #d64545;
        --bright-danger-contrast: #120303;
        --bright-placeholder: #8a8a8a;
        --bright-status-info-bg: rgba(96, 96, 96, 0.18);
        --bright-status-info-text: #1f1f1f;
        --bright-status-error-bg: rgba(214, 69, 69, 0.16);
        --bright-status-error-text: #5e1212;
        --bright-status-success-bg: rgba(160, 214, 160, 0.18);
        --bright-status-success-text: #235223;
        --bright-status-progress-track: rgba(32, 32, 32, 0.16);

        --bright-interactive-text: #131313;
        --bright-interactive-subtle: #2f2f2f;
        --bright-chrome-shadow: 0 28px 52px rgba(20, 20, 24, 0.24);
        --bright-chrome-border: rgba(0, 0, 0, 0.2);
        --bright-chrome-sheen: linear-gradient(
          140deg,
          rgba(255, 255, 255, 0.65) 0%,
          rgba(180, 180, 188, 0.35) 52%,
          rgba(240, 240, 240, 0.12) 100%
        );
        --bright-nav-button-bg: rgba(255, 255, 255, 0.92);
        --bright-nav-button-hover: rgba(255, 255, 255, 1);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(0, 0, 0, 0.18);
        --bright-nav-button-shadow: 0 16px 32px rgba(20, 20, 24, 0.24);
        --bright-nav-button-active-shadow: 0 20px 38px rgba(18, 18, 22, 0.28);
        --bright-chrome-radius: 14px;
        --bright-nav-button-radius: 12px;
        --bright-nav-button-clip: inset(0 round 12px);

        --dark-background: #050506;
        --dark-background-gradient: linear-gradient(150deg, #050506 0%, #111112 45%, #1a1a1c 100%);
        --dark-text: #f7f7fb;
        --dark-muted: #d0d0d8;
        --dark-panel-bg: rgba(12, 12, 14, 0.9);
        --dark-panel-border: rgba(120, 120, 126, 0.45);
        --dark-panel-shadow: 0 26px 48px rgba(0, 0, 0, 0.7);
        --dark-panel-shadow-high: 0 38px 78px rgba(0, 0, 0, 0.8);
        --dark-accent: #9fa4b2;
        --dark-accent-contrast: #060607;
        --dark-accent-muted: rgba(159, 164, 178, 0.26);
        --dark-accent-soft: rgba(159, 164, 178, 0.18);
        --dark-accent-glow: rgba(159, 164, 178, 0.32);
        --dark-accent-strong: rgba(159, 164, 178, 0.44);
        --dark-accent-highlight: rgba(159, 164, 178, 0.54);
        --dark-danger: #f16767;
        --dark-danger-contrast: #2a0505;
        --dark-placeholder: #b7b7bd;
        --dark-status-info-bg: rgba(159, 164, 178, 0.24);
        --dark-status-info-text: #f6f6f8;
        --dark-status-error-bg: rgba(241, 103, 103, 0.24);
        --dark-status-error-text: #ffd6d6;
        --dark-status-success-bg: rgba(189, 236, 189, 0.24);
        --dark-status-success-text: #e6f9e6;
        --dark-status-progress-track: rgba(255, 255, 255, 0.22);

        --dark-interactive-text: #f7f7fb;
        --dark-interactive-subtle: #d0d0d8;
        --dark-chrome-shadow: 0 36px 64px rgba(0, 0, 0, 0.75);
        --dark-chrome-border: rgba(255, 255, 255, 0.16);
        --dark-chrome-sheen: linear-gradient(
          150deg,
          rgba(24, 24, 28, 0.8) 0%,
          rgba(120, 120, 140, 0.32) 55%,
          rgba(255, 255, 255, 0.18) 100%
        );
        --dark-nav-button-bg: rgba(24, 24, 28, 0.82);
        --dark-nav-button-hover: rgba(34, 34, 38, 0.95);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(200, 200, 220, 0.28);
        --dark-nav-button-shadow: 0 28px 52px rgba(0, 0, 0, 0.76);
        --dark-nav-button-active-shadow: 0 34px 58px rgba(0, 0, 0, 0.82);
        --dark-chrome-radius: 12px;
        --dark-nav-button-radius: 10px;
        --dark-nav-button-clip: inset(0 round 10px);
      }

      body[data-theme='solar'] {
        --bright-background: #fff7e6;
        --bright-background-gradient: linear-gradient(140deg, #fff3d6 0%, #ffe4b5 48%, #ffd7a3 100%);
        --bright-text: #2d1804;
        --bright-muted: #4f3610;
        --bright-panel-bg: rgba(255, 255, 255, 0.92);
        --bright-panel-border: rgba(255, 204, 153, 0.55);
        --bright-panel-shadow: 0 20px 40px rgba(227, 151, 64, 0.2);
        --bright-panel-shadow-high: 0 32px 62px rgba(227, 151, 64, 0.3);
        --bright-accent: #ffa94d;
        --bright-accent-contrast: #321805;
        --bright-accent-muted: rgba(255, 169, 77, 0.24);
        --bright-accent-soft: rgba(255, 169, 77, 0.16);
        --bright-accent-glow: rgba(255, 169, 77, 0.36);
        --bright-accent-strong: rgba(255, 169, 77, 0.5);
        --bright-accent-highlight: rgba(255, 169, 77, 0.6);
        --bright-danger: #ff7b5c;
        --bright-danger-contrast: #340a04;
        --bright-placeholder: #b6894f;
        --bright-status-info-bg: rgba(255, 210, 140, 0.28);
        --bright-status-info-text: #6f4517;
        --bright-status-error-bg: rgba(255, 123, 92, 0.22);
        --bright-status-error-text: #7f2a18;
        --bright-status-success-bg: rgba(200, 246, 156, 0.22);
        --bright-status-success-text: #2d5f1c;
        --bright-status-progress-track: rgba(255, 169, 77, 0.22);

        --bright-interactive-text: #2d1804;
        --bright-interactive-subtle: #4f3610;
        --bright-chrome-shadow: 0 28px 50px rgba(200, 120, 30, 0.26);
        --bright-chrome-border: rgba(255, 188, 120, 0.58);
        --bright-chrome-sheen: linear-gradient(
          132deg,
          rgba(255, 255, 255, 0.7) 0%,
          rgba(255, 188, 120, 0.42) 48%,
          rgba(255, 220, 150, 0.22) 100%
        );
        --bright-nav-button-bg: rgba(255, 255, 255, 0.92);
        --bright-nav-button-hover: rgba(255, 255, 255, 1);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(255, 188, 120, 0.55);
        --bright-nav-button-shadow: 0 18px 38px rgba(200, 120, 30, 0.22);
        --bright-nav-button-active-shadow: 0 24px 46px rgba(180, 100, 20, 0.3);
        --bright-chrome-radius: 24px;
        --bright-nav-button-radius: 18px;

        --dark-background: #1f1302;
        --dark-background-gradient: linear-gradient(150deg, #301e04 0%, #2a1700 45%, #201205 100%);
        --dark-text: #ffebc6;
        --dark-muted: #f4c487;
        --dark-panel-bg: rgba(36, 21, 4, 0.9);
        --dark-panel-border: rgba(180, 116, 38, 0.55);
        --dark-panel-shadow: 0 26px 48px rgba(12, 6, 1, 0.7);
        --dark-panel-shadow-high: 0 38px 78px rgba(12, 6, 1, 0.78);
        --dark-accent: #ffb347;
        --dark-accent-contrast: #2c1600;
        --dark-accent-muted: rgba(255, 179, 71, 0.26);
        --dark-accent-soft: rgba(255, 179, 71, 0.18);
        --dark-accent-glow: rgba(255, 179, 71, 0.36);
        --dark-accent-strong: rgba(255, 179, 71, 0.5);
        --dark-accent-highlight: rgba(255, 179, 71, 0.6);
        --dark-danger: #ff946a;
        --dark-danger-contrast: #2d0c04;
        --dark-placeholder: #e0bf94;
        --dark-status-info-bg: rgba(255, 179, 71, 0.22);
        --dark-status-info-text: #ffe9cd;
        --dark-status-error-bg: rgba(255, 148, 106, 0.24);
        --dark-status-error-text: #ffd9ca;
        --dark-status-success-bg: rgba(206, 247, 170, 0.24);
        --dark-status-success-text: #f4ffe2;
        --dark-status-progress-track: rgba(255, 243, 213, 0.2);

        --dark-interactive-text: #ffefd4;
        --dark-interactive-subtle: #f5c98f;
        --dark-chrome-shadow: 0 36px 60px rgba(20, 10, 2, 0.74);
        --dark-chrome-border: rgba(255, 179, 71, 0.28);
        --dark-chrome-sheen: linear-gradient(
          148deg,
          rgba(54, 30, 6, 0.82) 0%,
          rgba(255, 179, 71, 0.34) 48%,
          rgba(255, 210, 140, 0.22) 100%
        );
        --dark-nav-button-bg: rgba(54, 30, 6, 0.82);
        --dark-nav-button-hover: rgba(64, 36, 8, 0.94);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(255, 179, 71, 0.35);
        --dark-nav-button-shadow: 0 28px 52px rgba(15, 7, 2, 0.72);
        --dark-nav-button-active-shadow: 0 34px 58px rgba(20, 10, 2, 0.78);
        --dark-chrome-radius: 24px;
        --dark-nav-button-radius: 18px;
      }

      body[data-theme='cyber'] {
        --bright-background: #e6f6ff;
        --bright-background-gradient: linear-gradient(140deg, #e6f6ff 0%, #edf0ff 48%, #f3e8ff 100%);
        --bright-text: #061023;
        --bright-muted: #12345c;
        --bright-panel-bg: rgba(255, 255, 255, 0.94);
        --bright-panel-border: rgba(126, 196, 255, 0.45);
        --bright-panel-shadow: 0 20px 42px rgba(65, 140, 214, 0.2);
        --bright-panel-shadow-high: 0 34px 64px rgba(65, 140, 214, 0.32);
        --bright-accent: #3fd7ff;
        --bright-accent-contrast: #041625;
        --bright-accent-muted: rgba(63, 215, 255, 0.24);
        --bright-accent-soft: rgba(63, 215, 255, 0.16);
        --bright-accent-glow: rgba(63, 215, 255, 0.4);
        --bright-accent-strong: rgba(63, 215, 255, 0.55);
        --bright-accent-highlight: rgba(63, 215, 255, 0.65);
        --bright-danger: #ff6fae;
        --bright-danger-contrast: #2b021b;
        --bright-placeholder: #5b87a8;
        --bright-status-info-bg: rgba(63, 215, 255, 0.22);
        --bright-status-info-text: #0d3c52;
        --bright-status-error-bg: rgba(255, 111, 174, 0.2);
        --bright-status-error-text: #6d1c43;
        --bright-status-success-bg: rgba(156, 246, 205, 0.2);
        --bright-status-success-text: #126f56;
        --bright-status-progress-track: rgba(63, 215, 255, 0.2);

        --bright-interactive-text: #061023;
        --bright-interactive-subtle: #12345c;
        --bright-chrome-shadow: 0 30px 54px rgba(18, 80, 160, 0.26);
        --bright-chrome-border: rgba(120, 210, 255, 0.55);
        --bright-chrome-sheen: linear-gradient(
          134deg,
          rgba(255, 255, 255, 0.78) 0%,
          rgba(120, 210, 255, 0.42) 45%,
          rgba(140, 110, 255, 0.24) 100%
        );
        --bright-nav-button-bg: rgba(245, 255, 255, 0.92);
        --bright-nav-button-hover: rgba(255, 255, 255, 1);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(120, 210, 255, 0.5);
        --bright-nav-button-shadow: 0 18px 40px rgba(18, 80, 160, 0.26);
        --bright-nav-button-active-shadow: 0 26px 52px rgba(18, 80, 220, 0.36);
        --bright-chrome-radius: 22px;
        --bright-nav-button-radius: 14px;
        --bright-nav-button-clip: polygon(8% 0, 100% 0, 92% 100%, 0 100%);

        --dark-background: #040915;
        --dark-background-gradient: linear-gradient(150deg, #040915 0%, #0c1734 48%, #132445 100%);
        --dark-text: #e9faff;
        --dark-muted: #9ddfff;
        --dark-panel-bg: rgba(10, 20, 40, 0.92);
        --dark-panel-border: rgba(74, 130, 189, 0.55);
        --dark-panel-shadow: 0 26px 50px rgba(2, 8, 20, 0.7);
        --dark-panel-shadow-high: 0 38px 80px rgba(2, 8, 20, 0.78);
        --dark-accent: #4af5ff;
        --dark-accent-contrast: #030a12;
        --dark-accent-muted: rgba(74, 245, 255, 0.28);
        --dark-accent-soft: rgba(74, 245, 255, 0.2);
        --dark-accent-glow: rgba(74, 245, 255, 0.4);
        --dark-accent-strong: rgba(74, 245, 255, 0.52);
        --dark-accent-highlight: rgba(74, 245, 255, 0.62);
        --dark-danger: #ff79c6;
        --dark-danger-contrast: #250017;
        --dark-placeholder: #8cc4e4;
        --dark-status-info-bg: rgba(74, 245, 255, 0.24);
        --dark-status-info-text: #dbfaff;
        --dark-status-error-bg: rgba(255, 121, 198, 0.24);
        --dark-status-error-text: #ffd7ef;
        --dark-status-success-bg: rgba(156, 246, 205, 0.22);
        --dark-status-success-text: #c9ffef;
        --dark-status-progress-track: rgba(120, 196, 255, 0.24);

        --dark-interactive-text: #e9faff;
        --dark-interactive-subtle: #9ddfff;
        --dark-chrome-shadow: 0 38px 64px rgba(0, 20, 40, 0.74);
        --dark-chrome-border: rgba(111, 225, 255, 0.4);
        --dark-chrome-sheen: linear-gradient(
          148deg,
          rgba(12, 24, 48, 0.85) 0%,
          rgba(111, 225, 255, 0.36) 48%,
          rgba(140, 110, 255, 0.26) 100%
        );
        --dark-nav-button-bg: rgba(12, 24, 48, 0.78);
        --dark-nav-button-hover: rgba(18, 36, 68, 0.94);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(111, 225, 255, 0.38);
        --dark-nav-button-shadow: 0 30px 54px rgba(0, 20, 40, 0.72);
        --dark-nav-button-active-shadow: 0 36px 64px rgba(0, 30, 60, 0.78);
        --dark-chrome-radius: 18px;
        --dark-nav-button-radius: 0px;
        --dark-nav-button-clip: polygon(10% 0, 100% 0, 90% 100%, 0 100%);
      }

      body[data-theme='obsidian'] {
        --bright-background: #f6f1ff;
        --bright-background-gradient: linear-gradient(140deg, #f6f1ff 0%, #ece4ff 52%, #e3f0ff 100%);
        --bright-text: #1b0d2d;
        --bright-muted: #3c2960;
        --bright-panel-bg: rgba(255, 255, 255, 0.94);
        --bright-panel-border: rgba(125, 98, 160, 0.45);
        --bright-panel-shadow: 0 18px 38px rgba(67, 38, 95, 0.18);
        --bright-panel-shadow-high: 0 30px 62px rgba(67, 38, 95, 0.28);
        --bright-accent: #7e4bff;
        --bright-accent-contrast: #150730;
        --bright-accent-muted: rgba(126, 75, 255, 0.24);
        --bright-accent-soft: rgba(126, 75, 255, 0.16);
        --bright-accent-glow: rgba(126, 75, 255, 0.36);
        --bright-accent-strong: rgba(126, 75, 255, 0.52);
        --bright-accent-highlight: rgba(126, 75, 255, 0.62);
        --bright-danger: #ff6f91;
        --bright-danger-contrast: #2e0a1d;
        --bright-placeholder: #7b65a0;
        --bright-status-info-bg: rgba(126, 75, 255, 0.2);
        --bright-status-info-text: #2d115a;
        --bright-status-error-bg: rgba(255, 111, 145, 0.22);
        --bright-status-error-text: #7f1c3b;
        --bright-status-success-bg: rgba(156, 246, 205, 0.2);
        --bright-status-success-text: #1b6c55;
        --bright-status-progress-track: rgba(126, 75, 255, 0.18);

        --bright-interactive-text: #1b0d2d;
        --bright-interactive-subtle: #3c2960;
        --bright-chrome-shadow: 0 30px 54px rgba(70, 40, 120, 0.24);
        --bright-chrome-border: rgba(126, 75, 255, 0.5);
        --bright-chrome-sheen: linear-gradient(
          138deg,
          rgba(255, 255, 255, 0.78) 0%,
          rgba(126, 75, 255, 0.45) 48%,
          rgba(160, 120, 255, 0.26) 100%
        );
        --bright-nav-button-bg: rgba(255, 255, 255, 0.94);
        --bright-nav-button-hover: rgba(255, 255, 255, 1);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(126, 75, 255, 0.5);
        --bright-nav-button-shadow: 0 20px 42px rgba(70, 40, 120, 0.24);
        --bright-nav-button-active-shadow: 0 26px 52px rgba(80, 44, 150, 0.3);
        --bright-chrome-radius: 28px;
        --bright-nav-button-radius: 20px;
        --bright-nav-button-clip: polygon(0 18%, 84% 0, 100% 100%, 12% 100%);

        --dark-background: #120f1b;
        --dark-background-gradient: linear-gradient(155deg, #1a1428 0%, #261b38 48%, #331f3f 100%);
        --dark-text: #fbf6ff;
        --dark-muted: #d8c9f5;
        --dark-panel-bg: rgba(28, 20, 46, 0.92);
        --dark-panel-border: rgba(122, 96, 161, 0.6);
        --dark-panel-shadow: 0 24px 46px rgba(19, 10, 33, 0.65);
        --dark-panel-shadow-high: 0 36px 72px rgba(19, 10, 33, 0.75);
        --dark-accent: #c9afff;
        --dark-accent-contrast: #160d26;
        --dark-accent-muted: rgba(201, 175, 255, 0.24);
        --dark-accent-soft: rgba(201, 175, 255, 0.18);
        --dark-accent-glow: rgba(201, 175, 255, 0.34);
        --dark-accent-strong: rgba(201, 175, 255, 0.46);
        --dark-accent-highlight: rgba(201, 175, 255, 0.56);
        --dark-danger: #ff7a99;
        --dark-danger-contrast: #26040e;
        --dark-placeholder: #baa6d7;
        --dark-status-info-bg: rgba(201, 175, 255, 0.22);
        --dark-status-info-text: #efe4ff;
        --dark-status-error-bg: rgba(255, 122, 153, 0.24);
        --dark-status-error-text: #ffd2dc;
        --dark-status-success-bg: rgba(156, 246, 205, 0.18);
        --dark-status-success-text: #c4ffe8;
        --dark-status-progress-track: rgba(255, 255, 255, 0.2);

        --dark-interactive-text: #fbf6ff;
        --dark-interactive-subtle: #d8c9f5;
        --dark-chrome-shadow: 0 36px 62px rgba(20, 10, 35, 0.72);
        --dark-chrome-border: rgba(201, 175, 255, 0.34);
        --dark-chrome-sheen: linear-gradient(
          146deg,
          rgba(28, 20, 46, 0.82) 0%,
          rgba(201, 175, 255, 0.32) 48%,
          rgba(160, 120, 255, 0.24) 100%
        );
        --dark-nav-button-bg: rgba(28, 20, 46, 0.86);
        --dark-nav-button-hover: rgba(36, 24, 56, 0.95);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(201, 175, 255, 0.38);
        --dark-nav-button-shadow: 0 30px 56px rgba(19, 10, 33, 0.72);
        --dark-nav-button-active-shadow: 0 36px 64px rgba(24, 12, 42, 0.78);
        --dark-chrome-radius: 22px;
        --dark-nav-button-radius: 18px;
        --dark-nav-button-clip: polygon(4% 0, 100% 0, 92% 100%, 0 100%);
      }

      body[data-theme='ethereal'] {
        --bright-background: #f5fbff;
        --bright-background-gradient: linear-gradient(150deg, #f5fbff 0%, #eef5ff 48%, #f8efff 100%);
        --bright-text: #152145;
        --bright-muted: #2d3d68;
        --bright-panel-bg: rgba(255, 255, 255, 0.9);
        --bright-panel-border: rgba(173, 204, 255, 0.45);
        --bright-panel-shadow: 0 18px 38px rgba(94, 122, 183, 0.18);
        --bright-panel-shadow-high: 0 30px 62px rgba(94, 122, 183, 0.28);
        --bright-accent: #9ad0ff;
        --bright-accent-contrast: #0f1c33;
        --bright-accent-muted: rgba(154, 208, 255, 0.22);
        --bright-accent-soft: rgba(154, 208, 255, 0.16);
        --bright-accent-glow: rgba(154, 208, 255, 0.34);
        --bright-accent-strong: rgba(154, 208, 255, 0.5);
        --bright-accent-highlight: rgba(154, 208, 255, 0.6);
        --bright-danger: #ff7aa2;
        --bright-danger-contrast: #2c0a1e;
        --bright-placeholder: #7a8eb4;
        --bright-status-info-bg: rgba(154, 208, 255, 0.22);
        --bright-status-info-text: #21406a;
        --bright-status-error-bg: rgba(255, 122, 162, 0.22);
        --bright-status-error-text: #7a2443;
        --bright-status-success-bg: rgba(173, 246, 228, 0.22);
        --bright-status-success-text: #1a6d58;
        --bright-status-progress-track: rgba(154, 208, 255, 0.2);

        --bright-interactive-text: #152145;
        --bright-interactive-subtle: #2d3d68;
        --bright-chrome-shadow: 0 28px 52px rgba(80, 100, 180, 0.22);
        --bright-chrome-border: rgba(154, 208, 255, 0.5);
        --bright-chrome-sheen: linear-gradient(
          140deg,
          rgba(255, 255, 255, 0.76) 0%,
          rgba(154, 208, 255, 0.4) 48%,
          rgba(210, 180, 255, 0.22) 100%
        );
        --bright-nav-button-bg: rgba(255, 255, 255, 0.94);
        --bright-nav-button-hover: rgba(255, 255, 255, 1);
        --bright-nav-button-active: var(--bright-accent);
        --bright-nav-button-border: rgba(154, 208, 255, 0.45);
        --bright-nav-button-shadow: 0 20px 42px rgba(80, 100, 180, 0.24);
        --bright-nav-button-active-shadow: 0 28px 52px rgba(70, 90, 200, 0.3);
        --bright-chrome-radius: 34px;
        --bright-nav-button-radius: 22px;

        --dark-background: #141c2a;
        --dark-background-gradient: linear-gradient(155deg, #141c2a 0%, #1a2740 48%, #1f3450 100%);
        --dark-text: #f2f8ff;
        --dark-muted: #c2daf5;
        --dark-panel-bg: rgba(18, 26, 40, 0.92);
        --dark-panel-border: rgba(92, 128, 176, 0.55);
        --dark-panel-shadow: 0 26px 50px rgba(5, 12, 24, 0.68);
        --dark-panel-shadow-high: 0 38px 82px rgba(5, 12, 24, 0.78);
        --dark-accent: #aee2ff;
        --dark-accent-contrast: #0a1524;
        --dark-accent-muted: rgba(174, 226, 255, 0.26);
        --dark-accent-soft: rgba(174, 226, 255, 0.18);
        --dark-accent-glow: rgba(174, 226, 255, 0.34);
        --dark-accent-strong: rgba(174, 226, 255, 0.46);
        --dark-accent-highlight: rgba(174, 226, 255, 0.56);
        --dark-danger: #ff95bb;
        --dark-danger-contrast: #2e0a22;
        --dark-placeholder: #b5cbe6;
        --dark-status-info-bg: rgba(174, 226, 255, 0.24);
        --dark-status-info-text: #eff7ff;
        --dark-status-error-bg: rgba(255, 149, 187, 0.24);
        --dark-status-error-text: #ffe1ec;
        --dark-status-success-bg: rgba(176, 247, 226, 0.22);
        --dark-status-success-text: #e9fff6;
        --dark-status-progress-track: rgba(220, 236, 255, 0.24);

        --dark-interactive-text: #f2f8ff;
        --dark-interactive-subtle: #c2daf5;
        --dark-chrome-shadow: 0 36px 62px rgba(8, 16, 30, 0.72);
        --dark-chrome-border: rgba(174, 226, 255, 0.32);
        --dark-chrome-sheen: linear-gradient(
          150deg,
          rgba(18, 26, 40, 0.82) 0%,
          rgba(174, 226, 255, 0.32) 50%,
          rgba(210, 200, 255, 0.24) 100%
        );
        --dark-nav-button-bg: rgba(18, 26, 40, 0.88);
        --dark-nav-button-hover: rgba(24, 34, 50, 0.95);
        --dark-nav-button-active: var(--dark-accent);
        --dark-nav-button-border: rgba(174, 226, 255, 0.36);
        --dark-nav-button-shadow: 0 30px 56px rgba(8, 16, 30, 0.7);
        --dark-nav-button-active-shadow: 0 36px 64px rgba(10, 20, 38, 0.78);
        --dark-chrome-radius: 26px;
        --dark-nav-button-radius: 20px;
      }

      body[data-effects='none'] {
        --background-gradient: var(--background);
        --panel-shadow: none;
        --panel-shadow-high: none;
        --panel-sheen: none;
        --accent-glow: rgba(0, 0, 0, 0);
        --ambient-opacity: 0;
        --ambient-blur: 0px;
        --ambient-animation: none;
        --ambient-vignette: 0;
      }

      body[data-effects='low'] {
        --background-gradient: var(--background);
        --accent-glow: rgba(0, 0, 0, 0);
        --ambient-opacity: 0.18;
        --ambient-blur: 70px;
        --ambient-animation: ambient-drift 42s ease-in-out infinite;
        --ambient-vignette: 0.15;
      }

      body[data-effects='mid'] {
        --ambient-opacity: 0.38;
        --ambient-blur: 90px;
        --ambient-animation: ambient-drift 34s ease-in-out infinite;
        --ambient-vignette: 0.28;
      }

      body[data-effects='high'] {
        --panel-shadow: var(--panel-shadow-high);
        --accent-glow: var(--accent-highlight);
        --ambient-opacity: 0.62;
        --ambient-blur: 120px;
        --ambient-animation: ambient-drift 26s ease-in-out infinite;
        --ambient-vignette: 0.35;
      }
      * {
        box-sizing: border-box;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .hidden {
        display: none !important;
      }

      body {
        margin: 0;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
        font-size: 15px;
        background: var(--background);
        background-image: var(--background-gradient, none);
        background-attachment: fixed;
        background-size: cover;
        color: var(--text);
        transition: background 0.2s ease, color 0.2s ease;
        min-height: 100vh;
        position: relative;
        overflow-x: hidden;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
      }

      body::before {
        content: '';
        position: fixed;
        inset: -30% -20%;
        background:
          radial-gradient(
            38% 38% at 18% 16%,
            var(--ambient-1) 0%,
            transparent 65%
          ),
          radial-gradient(
            34% 34% at 85% 20%,
            var(--ambient-2) 0%,
            transparent 70%
          ),
          radial-gradient(
            42% 42% at 55% 80%,
            var(--ambient-3) 0%,
            transparent 65%
          );
        opacity: var(--ambient-opacity, 0);
        filter: blur(var(--ambient-blur, 0px));
        animation: var(--ambient-animation, none);
        z-index: 0;
        pointer-events: none;
        transform: translateZ(0);
      }

      body::after {
        content: '';
        position: fixed;
        inset: 0;
        background: radial-gradient(
          circle at 50% 30%,
          rgba(255, 255, 255, 0) 0%,
          rgba(6, 12, 24, var(--ambient-vignette, 0)) 70%,
          rgba(6, 12, 24, calc(var(--ambient-vignette, 0) + 0.12)) 100%
        );
        mix-blend-mode: multiply;
        z-index: 0;
        pointer-events: none;
      }

      @keyframes ambient-drift {
        0% {
          transform: translate3d(0%, 0%, 0) scale(1);
        }
        40% {
          transform: translate3d(-4%, 3%, 0) scale(1.03);
        }
        70% {
          transform: translate3d(5%, -2%, 0) scale(1.05);
        }
        100% {
          transform: translate3d(0%, 0%, 0) scale(1);
        }
      }

      body.dialog-open {
        overflow: hidden;
      }

      main.layout {
        max-width: 1280px;
        margin: 0 auto;
        padding: 24px;
        display: flex;
        gap: 24px;
        align-items: stretch;
        min-height: 100vh;
        box-sizing: border-box;
        position: relative;
        z-index: 1;
      }

      .sidebar {
        width: 320px;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-height: 0;
      }

      .panel {
        background: var(--panel-bg);
        background-image: var(--panel-sheen);
        border: 1px solid var(--panel-border);
        border-radius: var(--panel-radius);
        padding: 18px 20px;
        box-shadow: var(--panel-shadow);
        backdrop-filter: blur(18px);
        position: relative;
        overflow: hidden;
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .dialog {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        z-index: 1000;
      }

      .dialog.hidden {
        display: none !important;
      }

      .dialog-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(2px);
      }

      .dialog-window {
        position: relative;
        z-index: 1;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        padding: 24px;
        width: min(420px, 100%);
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25), var(--panel-shadow);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .asset-viewer-window {
        width: min(1100px, 100%);
        max-width: 96vw;
        height: min(90vh, 880px);
        padding: 0;
        gap: 0;
        overflow: hidden;
      }

      .asset-viewer-chrome {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid var(--panel-border);
        background: var(--panel-bg);
      }

      .asset-viewer-header {
        display: flex;
        align-items: baseline;
        gap: 8px;
        min-width: 0;
      }

      .asset-viewer-title {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: clamp(240px, 45vw, 520px);
      }

      .asset-viewer-meta {
        font-size: 0.85rem;
        color: var(--muted);
        white-space: nowrap;
      }

      .asset-viewer-actions {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .asset-viewer-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--background);
        min-height: 0;
      }

      .asset-viewer-status {
        padding: 20px;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .asset-viewer-content {
        flex: 1;
        position: relative;
        overflow: auto;
        background: rgba(15, 23, 42, 0.02);
      }

      .asset-viewer-content.pdf-mode {
        padding: 0;
        background: #0002;
      }

      .asset-viewer-content.text-mode {
        padding: 24px 28px;
        font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        font-size: 0.95rem;
        line-height: 1.6;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .asset-viewer-content.markdown-mode {
        padding: 28px 32px;
        font-size: 1rem;
        line-height: 1.65;
      }

      .asset-viewer-content.markdown-mode h1,
      .asset-viewer-content.markdown-mode h2,
      .asset-viewer-content.markdown-mode h3,
      .asset-viewer-content.markdown-mode h4,
      .asset-viewer-content.markdown-mode h5,
      .asset-viewer-content.markdown-mode h6 {
        margin-top: 1.6em;
        margin-bottom: 0.6em;
        font-weight: 600;
        color: var(--text);
      }

      .asset-viewer-content.markdown-mode h1 {
        font-size: 1.8rem;
      }

      .asset-viewer-content.markdown-mode h2 {
        font-size: 1.5rem;
      }

      .asset-viewer-content.markdown-mode h3 {
        font-size: 1.25rem;
      }

      .asset-viewer-content.markdown-mode p {
        margin: 0 0 1.1em;
      }

      .asset-viewer-content.markdown-mode ul,
      .asset-viewer-content.markdown-mode ol {
        margin: 0 0 1.1em 1.35em;
        padding: 0;
      }

      .asset-viewer-content.markdown-mode li + li {
        margin-top: 0.4em;
      }

      .asset-viewer-content.markdown-mode pre {
        background: rgba(15, 23, 42, 0.08);
        padding: 16px 18px;
        border-radius: 8px;
        overflow: auto;
        font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        font-size: 0.9rem;
        line-height: 1.5;
        margin: 0 0 1.1em;
      }

      .asset-viewer-content.markdown-mode code {
        background: rgba(15, 23, 42, 0.08);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        font-size: 0.9rem;
      }

      .asset-viewer-content.markdown-mode a {
        color: var(--accent-contrast);
        background: var(--accent-muted);
        text-decoration: none;
        padding: 2px 6px;
        border-radius: 4px;
      }

      .asset-viewer-content.markdown-mode a:hover,
      .asset-viewer-content.markdown-mode a:focus {
        background: var(--accent-strong);
        color: var(--accent-contrast);
      }

      .asset-viewer-content iframe {
        width: 100%;
        height: 100%;
        border: none;
        background: #fff;
      }

      body.debug-enabled {
        padding-right: min(33vw, 520px);
      }

      body.debug-enabled .dialog {
        right: min(33vw, 520px);
      }

      body.debug-enabled .dialog-backdrop {
        right: min(33vw, 520px);
      }

      .debug-pane {
        position: fixed;
        inset: 0 0 0 auto;
        width: min(33vw, 520px);
        min-width: 320px;
        max-width: 520px;
        background: #020617;
        color: #e2e8f0;
        border-left: 2px solid rgba(148, 163, 184, 0.24);
        box-shadow: -12px 0 24px rgba(15, 23, 42, 0.45);
        padding: 18px 20px;
        display: none;
        flex-direction: column;
        gap: 12px;
        font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        z-index: 2000;
      }

      body.debug-enabled .debug-pane {
        display: flex;
      }

      .debug-pane-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .debug-pane-title {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }

      .debug-indicator {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #22d3ee;
      }

      .debug-pane-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 8px;
        align-items: flex-end;
      }

      .debug-filter {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 0.75rem;
        color: rgba(148, 163, 184, 0.85);
      }

      .debug-filter input,
      .debug-filter select {
        padding: 6px 8px;
        border: 1px solid rgba(94, 117, 148, 0.6);
        border-radius: 6px;
        background: rgba(15, 23, 42, 0.85);
        color: #e2e8f0;
        font-size: 0.8rem;
      }

      .debug-filter input::placeholder,
      .debug-filter select:invalid {
        color: rgba(148, 163, 184, 0.6);
      }

      .debug-filter--wide {
        grid-column: span 2;
      }

      @media (max-width: 720px) {
        .debug-filter--wide {
          grid-column: span 1;
        }
      }

      .debug-filter-clear {
        padding: 6px 10px;
        border: 1px solid rgba(94, 117, 148, 0.6);
        border-radius: 6px;
        background: transparent;
        color: rgba(226, 232, 240, 0.9);
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        cursor: pointer;
        transition: background 0.15s ease, color 0.15s ease;
      }

      .debug-filter-clear:hover,
      .debug-filter-clear:focus {
        background: rgba(59, 130, 246, 0.18);
        color: #f8fafc;
      }

      .debug-download-button {
        padding: 6px 12px;
        margin-left: auto;
        border-radius: 6px;
        border: 1px solid rgba(94, 117, 148, 0.4);
        background: rgba(15, 23, 42, 0.45);
        color: rgba(226, 232, 240, 0.92);
        font-size: 0.8rem;
        letter-spacing: 0.02em;
        cursor: pointer;
        transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      }

      .debug-download-button:hover,
      .debug-download-button:focus-visible {
        background: rgba(59, 130, 246, 0.2);
        border-color: rgba(148, 163, 184, 0.8);
        color: #f8fafc;
      }

      .debug-download-button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }

      .debug-heartbeat {
        display: flex;
        align-items: center;
        gap: 4px;
        margin: 12px 0 4px;
        min-height: 16px;
      }

      .debug-heartbeat[data-state='idle'] .debug-heartbeat-dot {
        opacity: 0.4;
      }

      .debug-heartbeat-track {
        display: flex;
        align-items: center;
        gap: 2px;
        flex-wrap: wrap;
      }

      .debug-heartbeat-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: rgba(56, 189, 248, 0.8);
        opacity: 0.8;
        transition: transform 0.2s ease, opacity 0.2s ease;
      }

      .debug-heartbeat-dot[data-severity='warning'] {
        background: rgba(250, 204, 21, 0.9);
      }

      .debug-heartbeat-dot[data-severity='error'],
      .debug-heartbeat-dot[data-severity='critical'] {
        background: rgba(248, 113, 113, 0.95);
      }

      .debug-heartbeat-dot.is-failure {
        transform: scale(1.4);
        box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.2);
      }

      .debug-log-window {
        flex: 1;
        background: rgba(15, 23, 42, 0.82);
        border: 1px solid rgba(51, 65, 85, 0.65);
        border-radius: 12px;
        padding: 16px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .debug-log-window:focus {
        outline: 2px solid rgba(56, 189, 248, 0.6);
        outline-offset: 2px;
      }

      .debug-log-entry {
        position: relative;
        display: grid;
        grid-template-columns: 16px 1fr;
        gap: 12px;
        padding: 12px 14px;
        border-radius: 10px;
        background: rgba(30, 41, 59, 0.78);
        border: 1px solid rgba(71, 85, 105, 0.55);
        box-shadow: 0 4px 12px rgba(2, 6, 23, 0.22);
        color: #e2e8f0;
        word-break: break-word;
        font-size: 0.84rem;
      }

      .debug-log-entry[data-severity='warning'] {
        border-color: rgba(250, 204, 21, 0.55);
      }

      .debug-log-entry[data-severity='error'],
      .debug-log-entry[data-severity='critical'] {
        background: rgba(127, 29, 29, 0.32);
        border-color: rgba(248, 113, 113, 0.7);
        box-shadow: 0 6px 18px rgba(127, 29, 29, 0.35);
      }

      .debug-log-entry.is-first-failure::after {
        content: '';
        position: absolute;
        inset: 4px;
        border-radius: 9px;
        border: 1px dashed rgba(248, 113, 113, 0.8);
        pointer-events: none;
      }

      .debug-log-entry-timeline {
        position: relative;
        display: flex;
        justify-content: center;
      }

      .debug-log-entry-timeline::before {
        content: '';
        position: absolute;
        top: -16px;
        bottom: -16px;
        width: 2px;
        background: rgba(148, 163, 184, 0.22);
      }

      .debug-log-entry-dot {
        margin-top: 4px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: rgba(59, 130, 246, 0.85);
        border: 2px solid rgba(15, 23, 42, 0.85);
        z-index: 1;
      }

      .debug-log-entry[data-severity='warning'] .debug-log-entry-dot {
        background: rgba(250, 204, 21, 0.9);
      }

      .debug-log-entry[data-severity='error'] .debug-log-entry-dot,
      .debug-log-entry[data-severity='critical'] .debug-log-entry-dot {
        background: rgba(248, 113, 113, 0.95);
      }

      .debug-log-entry-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .debug-log-entry-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
        font-size: 0.78rem;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: rgba(148, 163, 184, 0.9);
      }

      .debug-log-entry-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
        font-size: 0.76rem;
        color: rgba(148, 163, 184, 0.92);
      }

      .debug-log-entry-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .debug-log-entry-title {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 6px;
      }

      .debug-log-severity {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 999px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        background: rgba(56, 189, 248, 0.2);
        color: rgba(191, 219, 254, 0.95);
      }

      .debug-log-severity[data-variant='warning'] {
        background: rgba(250, 204, 21, 0.25);
        color: #facc15;
      }

      .debug-log-severity[data-variant='error'],
      .debug-log-severity[data-variant='critical'] {
        background: rgba(248, 113, 113, 0.3);
        color: #fee2e2;
      }

      .debug-log-time {
        font-variant-numeric: tabular-nums;
        opacity: 0.75;
      }

      .debug-log-badge,
      .debug-log-tag {
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(71, 85, 105, 0.7);
        color: rgba(226, 232, 240, 0.95);
        font-weight: 500;
      }

      .debug-log-badge[data-variant='accent'] {
        background: var(--accent-soft);
        color: var(--text);
        border-color: var(--accent-strong);
      }

      .debug-log-badge[data-variant='warning'] {
        background: rgba(250, 204, 21, 0.25);
        color: #facc15;
        border-color: rgba(250, 204, 21, 0.6);
      }

      .debug-log-badge[data-variant='danger'] {
        background: rgba(248, 113, 113, 0.3);
        color: #fecaca;
        border-color: rgba(248, 113, 113, 0.6);
      }

      .debug-log-message-wrapper,
      .debug-stream-entry-message-wrapper {
        display: flex;
        align-items: flex-start;
        gap: 8px;
      }

      .debug-log-message {
        flex: 1 1 auto;
        white-space: pre-wrap;
        line-height: 1.5;
        font-size: 0.9rem;
        color: #f8fafc;
      }

      .debug-copy-button {
        flex: 0 0 auto;
        align-self: flex-start;
        background: rgba(30, 41, 59, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.4);
        border-radius: 6px;
        color: rgba(226, 232, 240, 0.9);
        cursor: pointer;
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.02em;
        padding: 4px 10px;
        text-transform: uppercase;
        transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      }

      .debug-copy-button:hover:not(:disabled),
      .debug-copy-button:focus-visible:not(:disabled) {
        background: rgba(59, 130, 246, 0.25);
        border-color: rgba(96, 165, 250, 0.8);
        color: rgba(191, 219, 254, 0.95);
        outline: none;
      }

      .debug-copy-button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
      }

      .debug-copy-button[data-state='copied'] {
        background: rgba(34, 197, 94, 0.25);
        border-color: rgba(134, 239, 172, 0.8);
        color: rgba(220, 252, 231, 0.95);
      }

      .debug-copy-button[data-state='error'] {
        background: rgba(248, 113, 113, 0.25);
        border-color: rgba(248, 113, 113, 0.7);
        color: rgba(254, 202, 202, 0.95);
      }

      .debug-log-context {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 0.74rem;
        color: rgba(148, 163, 184, 0.92);
      }

      .debug-log-entry-expandable {
        background: rgba(15, 23, 42, 0.55);
        border-radius: 8px;
        border: 1px solid rgba(71, 85, 105, 0.7);
        padding: 6px 10px;
        font-size: 0.78rem;
      }

      .debug-log-entry-expandable summary {
        cursor: pointer;
        font-weight: 600;
        color: rgba(191, 219, 254, 0.95);
      }

      .debug-log-entry-expandable pre {
        margin: 8px 0 0;
        padding: 8px;
        border-radius: 6px;
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(71, 85, 105, 0.55);
        max-height: 240px;
        overflow: auto;
        font-size: 0.72rem;
        line-height: 1.45;
        color: rgba(226, 232, 240, 0.95);
      }

      .debug-log-entry-expandable-block {
        margin-top: 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .debug-log-entry-expandable-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: rgba(148, 163, 184, 0.85);
      }

      .debug-log-empty {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.7);
      }

      .debug-stream-window {
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid rgba(51, 65, 85, 0.6);
        border-radius: 10px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        font-size: 0.8rem;
        color: rgba(226, 232, 240, 0.88);
        flex-shrink: 0;
        max-height: 220px;
        overflow-y: auto;
      }

      .debug-stream-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 8px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(125, 211, 252, 0.85);
      }

      .debug-stream-entries {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 1.5em;
      }

      .debug-stream-entry {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 10px 12px;
        border-radius: 8px;
        background: rgba(30, 41, 59, 0.62);
        border: 1px solid rgba(51, 65, 85, 0.6);
        box-shadow: 0 2px 8px rgba(2, 6, 23, 0.25);
      }

      .debug-stream-entry[data-severity='warning'] {
        border-color: rgba(250, 204, 21, 0.5);
      }

      .debug-stream-entry[data-severity='error'],
      .debug-stream-entry[data-severity='critical'] {
        background: rgba(127, 29, 29, 0.28);
        border-color: rgba(248, 113, 113, 0.65);
      }

      .debug-stream-entry-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: rgba(148, 163, 184, 0.88);
      }

      .debug-stream-entry-title {
        font-weight: 600;
        color: rgba(191, 219, 254, 0.92);
      }

      .debug-stream-entry-time {
        font-variant-numeric: tabular-nums;
        color: rgba(148, 163, 184, 0.75);
      }

      .debug-stream-entry-message {
        flex: 1 1 auto;
        font-size: 0.82rem;
        color: rgba(226, 232, 240, 0.92);
        white-space: pre-wrap;
      }

      .debug-stream-entry-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 0.72rem;
        color: rgba(148, 163, 184, 0.9);
      }

      .debug-stream-entry-error {
        font-size: 0.74rem;
        color: rgba(248, 113, 113, 0.92);
        border-top: 1px solid rgba(248, 113, 113, 0.35);
        padding-top: 4px;
      }

      .debug-stream-empty {
        color: rgba(148, 163, 184, 0.85);
        font-style: italic;
      }

      .debug-log-status {
        font-size: 0.8rem;
        color: #fbbf24;
        min-height: 1em;
      }

      .slide-range-window {
        width: min(960px, calc(100vw - 48px));
        max-width: min(960px, calc(100vw - 48px));
        max-height: min(90vh, 760px);
      }

      .upload-dialog-window {
        width: min(420px, 100%);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .upload-dialog-window .dialog-header {
        margin-bottom: -8px;
      }

      .upload-dropzone {
        border: 2px dashed var(--panel-border);
        border-radius: 12px;
        padding: 32px 24px;
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        justify-content: center;
        background: rgba(148, 163, 184, 0.08);
        cursor: pointer;
        transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      }

      .upload-dropzone:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-glow);
      }

      .upload-dropzone.active,
      .upload-dropzone:hover {
        border-color: var(--accent);
        background: var(--accent-soft);
        transform: translateY(-1px);
      }

      .upload-dropzone strong {
        font-size: 1rem;
      }

      .upload-dropzone p {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .upload-dropzone .dialog-button {
        pointer-events: auto;
      }

      .upload-file-info {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 12px 14px;
        border-radius: 10px;
        border: 1px solid var(--panel-border);
        background: rgba(148, 163, 184, 0.12);
      }

      .upload-file-summary {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: space-between;
        gap: 8px;
      }

      .upload-file-actions {
        display: flex;
        justify-content: flex-end;
      }

      .upload-file-name {
        font-weight: 600;
        word-break: break-word;
      }

      .upload-file-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .upload-file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px dashed var(--panel-border);
        background: rgba(148, 163, 184, 0.08);
        cursor: grab;
        transition: background 0.15s ease, border-color 0.15s ease, transform 0.15s ease;
      }

      .upload-file-item:active {
        cursor: grabbing;
      }

      .upload-file-item.dragging {
        opacity: 0.7;
        transform: scale(0.99);
      }

      .upload-file-item.drop-target {
        border-style: solid;
        border-color: var(--accent);
        background: var(--accent-soft);
      }

      .upload-file-item-name {
        flex: 1;
        font-weight: 600;
        word-break: break-word;
      }

      .upload-file-item-meta {
        font-size: 0.85rem;
        color: var(--muted);
        white-space: nowrap;
      }

      .upload-progress {
        width: 100%;
        height: 8px;
        border-radius: 999px;
        background: var(--status-progress-track);
        overflow: hidden;
      }

      .upload-progress-fill {
        height: 100%;
        width: 0;
        border-radius: inherit;
        background: linear-gradient(90deg, var(--accent), #7c3aed);
        transition: width 0.2s ease;
      }

      .upload-progress-text {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .upload-status-message {
        font-size: 0.9rem;
      }

      .upload-status-message.error {
        color: var(--status-error-text);
      }

      .upload-status-message.success {
        color: var(--status-success-text);
      }

      .upload-dialog-hidden {
        display: none !important;
      }

      .bulk-upload-window {
        width: min(460px, 100%);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .bulk-upload-window .dialog-header {
        margin-bottom: -4px;
      }

      .bulk-upload-file {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 12px 14px;
        border-radius: 10px;
        border: 1px dashed var(--panel-border);
        background: rgba(148, 163, 184, 0.08);
      }

      .bulk-upload-file-name {
        font-weight: 600;
        word-break: break-word;
      }

      .bulk-upload-file-size {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .bulk-upload-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .bulk-upload-field select {
        padding: 10px 12px;
        border-radius: 8px;
        border: 1px solid var(--panel-border);
        background: var(--panel-bg);
        color: var(--text);
        font-size: 0.95rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .bulk-upload-field select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-glow);
      }

      .bulk-upload-status {
        min-height: 20px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .bulk-upload-status.success {
        color: var(--status-success-text);
      }

      .bulk-upload-status.error {
        color: var(--status-error-text);
      }

      .bulk-upload-status.info {
        color: var(--status-info-text);
      }

      .bulk-upload-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .bulk-upload-actions-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .bulk-process-window {
        width: min(960px, 100%);
        max-height: min(90vh, 780px);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .bulk-process-header {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      @media (min-width: 720px) {
        .bulk-process-header {
          flex-direction: row;
          align-items: flex-start;
          justify-content: space-between;
        }
      }

      .bulk-process-heading {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .bulk-process-toolbar {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
      }

      .bulk-process-toolbar .dialog-button {
        white-space: nowrap;
      }

      .bulk-process-content {
        flex: 1;
        min-height: 240px;
        max-height: calc(90vh - 260px);
        overflow: auto;
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        padding: 12px;
        background: var(--background);
      }

      .bulk-process-empty {
        margin: 0;
        color: var(--placeholder);
        font-style: italic;
      }

      .bulk-process-status-message {
        min-height: 20px;
        font-size: 0.9rem;
      }

      .bulk-process-status-message.error {
        color: var(--status-error-text);
      }

      .bulk-process-status-message.success {
        color: var(--status-success-text);
      }

      .bulk-process-summary {
        font-size: 0.9rem;
        color: var(--muted);
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .bulk-process-tree {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .bulk-process-tree details {
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        background: var(--panel-bg);
        overflow: hidden;
      }

      .bulk-process-tree summary {
        list-style: none;
        cursor: pointer;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-weight: 600;
      }

      .bulk-process-tree summary::-webkit-details-marker {
        display: none;
      }

      .bulk-process-tree summary:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .bulk-process-tree .bulk-process-module summary {
        font-weight: 500;
        font-size: 0.95rem;
        background: rgba(148, 163, 184, 0.1);
      }

      .bulk-process-tree .bulk-process-lectures {
        margin: 0;
        padding: 12px 16px 16px;
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .bulk-process-lecture {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .bulk-process-lecture-header {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .bulk-process-lecture-title {
        font-weight: 600;
        color: var(--text);
      }

      .bulk-process-lecture-meta {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .bulk-process-checkbox-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .bulk-process-checkbox {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid transparent;
        background: rgba(148, 163, 184, 0.12);
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, opacity 0.2s ease;
        font-size: 0.85rem;
      }

      .bulk-process-checkbox input {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }

      .bulk-process-checkbox .bulk-process-indicator {
        width: 18px;
        height: 18px;
        border-radius: 6px;
        border: 2px solid var(--panel-border);
        background: var(--panel-bg);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .bulk-process-checkbox .bulk-process-indicator::after {
        content: '';
        width: 10px;
        height: 6px;
        border-left: 2px solid transparent;
        border-bottom: 2px solid transparent;
        transform: rotate(-45deg);
        transition: border-color 0.2s ease;
      }

      .bulk-process-checkbox .bulk-process-status-label {
        font-size: 0.75rem;
        color: var(--muted);
      }

      .bulk-process-checkbox[data-state='unavailable'] {
        background: rgba(148, 163, 184, 0.08);
        color: var(--muted);
        cursor: not-allowed;
        opacity: 0.6;
      }

      .bulk-process-checkbox[data-state='unavailable'] .bulk-process-indicator {
        border-color: rgba(148, 163, 184, 0.5);
      }

      .bulk-process-checkbox[data-state='empty'] {
        border-color: transparent;
      }

      .bulk-process-checkbox[data-state='completed'] {
        border-color: var(--accent);
        background: var(--accent-muted);
        color: var(--accent);
      }

      .bulk-process-checkbox[data-state='completed'] .bulk-process-indicator {
        border-color: var(--accent);
        background: var(--accent-soft);
      }

      .bulk-process-checkbox[data-state='selected'] {
        border-color: var(--accent);
        background: var(--accent);
        color: var(--accent-contrast);
      }

      .bulk-process-checkbox[data-state='selected'] .bulk-process-indicator {
        border-color: var(--accent-contrast);
        background: var(--accent-contrast);
      }

      .bulk-process-checkbox[data-state='selected'] .bulk-process-indicator::after {
        border-left-color: var(--accent);
        border-bottom-color: var(--accent);
      }

      .bulk-process-checkbox[data-state='selected'] .bulk-process-status-label,
      .bulk-process-checkbox[data-state='completed'] .bulk-process-status-label {
        color: inherit;
      }

      .bulk-process-checkbox:focus-within {
        box-shadow: 0 0 0 2px var(--accent-glow);
      }

      .dialog-pending-window {
        width: min(360px, calc(100vw - 48px));
        align-items: center;
      }

      .dialog-pending-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        text-align: center;
      }

      .dialog-pending-spinner {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 4px solid var(--panel-border);
        border-top-color: var(--accent);
        animation: dialog-spinner 1s linear infinite;
      }

      .dialog-pending-message {
        margin: 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      @keyframes dialog-spinner {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .slide-range-body {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .slide-range-preview {
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        background: var(--background);
        padding: 16px;
        max-height: 60vh;
        overflow-y: auto;
        overflow-x: auto;
        box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.08);
        max-width: 100%;
      }

      .slide-range-preview::-webkit-scrollbar {
        width: 10px;
      }

      .slide-range-preview::-webkit-scrollbar-thumb {
        background: var(--accent-muted);
        border-radius: 999px;
      }

      .slide-range-preview::-webkit-scrollbar-track {
        background: transparent;
      }

      .slide-range-loading,
      .slide-range-error {
        font-size: 0.95rem;
        padding: 24px 8px;
        text-align: center;
      }

      .slide-range-loading {
        color: var(--muted);
      }

      .slide-range-error {
        color: var(--status-info-text);
        background: var(--status-info-bg);
        border-radius: 8px;
        margin-bottom: 16px;
      }

      .slide-range-fallback {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 16px;
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        background: var(--panel-bg);
        padding: 12px;
      }

      .slide-range-fallback.hidden {
        display: none !important;
      }

      .slide-range-fallback-preview {
        position: relative;
        width: 100%;
        padding-top: 62.5%;
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        overflow: hidden;
        background: var(--background);
      }

      .slide-range-fallback-preview iframe {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        border: 0;
        background: var(--panel-bg);
      }

      .slide-range-fallback-message {
        font-size: 0.9rem;
        color: var(--muted);
        margin: 0;
      }

      .slide-range-fallback-link {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        align-self: flex-start;
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
      }

      .slide-range-fallback-link:focus,
      .slide-range-fallback-link:hover {
        text-decoration: underline;
      }

      .slide-range-pages {
        --slide-preview-min-width: 220px;
        display: grid;
        grid-template-columns: repeat(
          auto-fill,
          minmax(var(--slide-preview-min-width), 1fr)
        );
        gap: 16px;
      }

      .slide-preview-page {
        background: var(--panel-bg);
        border-radius: 10px;
        border: 1px solid transparent;
        padding: 12px;
        box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
        transition: border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease,
          transform 0.2s ease;
        cursor: pointer;
        opacity: 0.55;
        outline: none;
      }

      .slide-preview-page.selected {
        border-color: var(--accent);
        box-shadow: 0 10px 24px var(--accent-soft);
        opacity: 1;
      }

      .slide-preview-page:focus {
        border-color: var(--accent);
        box-shadow: 0 10px 24px var(--accent-soft);
        opacity: 1;
      }

      .slide-preview-page-label {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 8px;
      }

      .slide-preview-page canvas,
      .slide-preview-page img {
        width: 100%;
        height: auto;
        border-radius: 6px;
        background: #fff;
      }

      .slide-preview-page img {
        display: block;
      }

      .slide-range-zoom {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .slide-range-zoom-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .slide-range-zoom-value {
        font-weight: 600;
        color: var(--text);
        font-variant-numeric: tabular-nums;
      }

      .slide-range-zoom input[type='range'] {
        width: 100%;
        accent-color: var(--accent);
      }

      .slide-range-controls {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .page-selection {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: flex-end;
      }

      .page-inputs {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        flex: 1 1 240px;
      }

      .page-inputs label {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
        color: var(--muted);
        gap: 6px;
        min-width: 140px;
      }

      .page-inputs input[type='number'] {
        padding: 8px 10px;
        border-radius: 6px;
        border: 1px solid var(--panel-border);
        background: var(--panel-bg);
        color: var(--text);
        font-size: 0.95rem;
        font-weight: 500;
      }

      .page-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-start;
      }

      .page-actions .dialog-button {
        white-space: nowrap;
      }

      .page-range-summary {
        font-size: 0.95rem;
        font-weight: 500;
        color: var(--text);
      }

      .slide-range-hint {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .storage-page {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .storage-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 16px;
      }

      .storage-header h2 {
        margin: 0;
      }

      .storage-path {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .storage-browser {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .storage-browser-toolbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .storage-browser-nav {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .storage-browser-nav button {
        border-radius: var(--nav-button-radius);
        border: 1px solid var(--nav-button-border);
        background: var(--nav-button-bg);
        color: var(--interactive-text);
        padding: 8px 16px;
        font-weight: 600;
        cursor: pointer;
        clip-path: var(--nav-button-clip);
        box-shadow: var(--nav-button-shadow);
        transition: transform 0.25s ease, background 0.25s ease,
          color 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
      }

      .storage-browser-nav button:hover {
        border-color: var(--accent);
        background: var(--nav-button-hover);
        color: var(--accent-contrast);
        box-shadow: var(--nav-button-active-shadow);
        transform: translateY(-2px);
      }

      .storage-browser-nav button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
        filter: none;
        transform: none;
        box-shadow: none;
      }

      .storage-browser-table-wrapper {
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        overflow: hidden;
        background: var(--panel-bg);
      }

      .storage-browser-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.95rem;
      }

      .storage-browser-table thead {
        background: var(--background);
        color: var(--muted);
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.05em;
      }

      .storage-browser-table th,
      .storage-browser-table td {
        padding: 10px 14px;
        text-align: left;
        border-bottom: 1px solid var(--panel-border);
      }

      .storage-select-header,
      .storage-select-cell {
        width: 48px;
        text-align: center;
      }

      .storage-select-checkbox {
        width: 16px;
        height: 16px;
      }

      .storage-browser-table tbody tr.is-selected {
        background: var(--accent-muted);
      }

      .storage-browser-table tbody tr:last-child td {
        border-bottom: none;
      }

      .storage-entry-name {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
        cursor: pointer;
        background: transparent;
        border: none;
        padding: 0;
      }

      .storage-entry-name:hover,
      .storage-entry-name:focus {
        text-decoration: underline;
      }

      .storage-entry-type {
        text-transform: capitalize;
        color: var(--muted);
      }

      .storage-entry-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .storage-entry-actions button {
        border-radius: 6px;
        border: 1px solid var(--panel-border);
        background: transparent;
        color: var(--muted);
        padding: 4px 10px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease,
          filter 0.2s ease;
      }

      .storage-entry-actions button:hover {
        border-color: var(--danger);
        color: var(--danger);
        background: rgba(220, 38, 38, 0.12);
      }

      .storage-entry-actions button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        background: transparent;
      }

      .storage-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .storage-actions button {
        border-radius: var(--nav-button-radius);
        border: 1px solid var(--nav-button-border);
        background: var(--nav-button-bg);
        color: var(--interactive-text);
        padding: 8px 16px;
        font-weight: 600;
        cursor: pointer;
        clip-path: var(--nav-button-clip);
        box-shadow: var(--nav-button-shadow);
        transition: transform 0.25s ease, background 0.25s ease,
          color 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease,
          opacity 0.25s ease;
      }

      .storage-actions button:hover {
        border-color: var(--accent);
        background: var(--nav-button-hover);
        color: var(--accent-contrast);
        box-shadow: var(--nav-button-active-shadow);
        transform: translateY(-2px);
      }

      .storage-actions button.primary {
        background: var(--accent);
        border-color: transparent;
        color: var(--accent-contrast);
        box-shadow: var(--nav-button-active-shadow);
      }

      .storage-actions button.primary:hover {
        filter: none;
      }

      .storage-actions button.danger {
        background: var(--danger);
        border-color: transparent;
        color: var(--danger-contrast);
        box-shadow: var(--nav-button-active-shadow);
      }

      .storage-actions button.danger:hover {
        filter: none;
      }

      .storage-actions button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
        filter: none;
        transform: none;
        box-shadow: none;
      }

      .storage-usage {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 12px;
        background: var(--background);
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        padding: 12px 16px;
      }

      .storage-usage-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .storage-usage-label {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .storage-usage-value {
        font-size: 1.1rem;
        font-weight: 600;
      }

      .storage-toggle {
        list-style: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 16px;
        cursor: pointer;
        font-weight: 600;
      }

      .storage-toggle::-webkit-details-marker {
        display: none;
      }

      .storage-toggle::after {
        content: '';
        width: 8px;
        height: 8px;
        border-right: 2px solid var(--muted);
        border-bottom: 2px solid var(--muted);
        transform: rotate(-45deg);
        transition: transform 0.2s ease;
      }

      details[open] > .storage-toggle {
        border-bottom: 1px solid var(--panel-border);
      }

      details[open] > .storage-toggle::after {
        transform: rotate(45deg);
      }

      .storage-module-card > .storage-toggle {
        padding: 12px 16px;
      }

      .storage-lecture-item > .storage-toggle {
        padding: 10px 14px;
      }

      .storage-empty,
      .storage-loading {
        text-align: center;
        padding: 32px 16px;
        color: var(--muted);
        border-radius: 10px;
        border: 1px dashed var(--panel-border);
      }

      .storage-loading {
        border-style: solid;
        border-color: transparent;
      }

      .storage-purge-summary {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .storage-class-wrapper {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .storage-class-list,
      .storage-module-list,
      .storage-lecture-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .storage-module-list,
      .storage-lecture-list {
        gap: 10px;
      }

      .storage-class-card,
      .storage-module-card,
      .storage-lecture-item {
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        background: var(--background);
        overflow: hidden;
      }

      .storage-module-card,
      .storage-lecture-item {
        border-radius: 8px;
      }

      .storage-class-body,
      .storage-module-body,
      .storage-lecture-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px 16px 16px;
        border-top: 1px solid var(--panel-border);
      }

      .storage-lecture-body {
        padding: 10px 16px 14px;
      }

      .storage-resource-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .storage-resource-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .storage-resource-label {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .storage-reveal-button {
        border: 1px solid var(--nav-button-border);
        background: var(--nav-button-bg);
        color: var(--interactive-text);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 0.8rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }

      .storage-reveal-button:hover {
        background: var(--nav-button-hover);
        border-color: var(--accent);
        color: var(--accent-contrast);
      }

      .storage-class-header,
      .storage-module-header,
      .storage-lecture-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }

      .storage-class-title,
      .storage-module-title {
        margin: 0;
        font-size: 1.05rem;
      }

      .storage-lecture-title {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }

      .storage-class-meta,
      .storage-module-meta,
      .storage-lecture-meta {
        margin: 0;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .storage-class-size,
      .storage-module-size,
      .storage-lecture-size {
        font-weight: 600;
        white-space: nowrap;
      }

      .storage-lecture-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .storage-lecture-eligible {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        background: var(--status-success-bg);
        color: var(--status-success-text);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 0.8rem;
        font-weight: 600;
        align-self: flex-start;
      }

      .storage-lecture-processed {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        background: var(--status-info-bg);
        color: var(--status-info-text);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 0.8rem;
        font-weight: 600;
        align-self: flex-start;
      }

      .dialog-title {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
      }

      .dialog-message {
        margin: 0;
        font-size: 0.95rem;
        color: var(--muted);
        white-space: pre-wrap;
      }

      .dialog-input-wrapper {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .dialog-input {
        width: 100%;
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 10px 12px;
        font-size: 0.95rem;
        background: var(--background);
        color: var(--text);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .dialog-input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-glow);
      }

      .dialog-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }

      .slide-range-footer {
        justify-content: flex-end;
        padding-top: 8px;
      }

      .dialog-button {
        border: 1px solid transparent;
        border-radius: 999px;
        padding: 8px 16px;
        font-weight: 600;
        font-size: 0.95rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease,
          filter 0.2s ease;
      }

      .dialog-button:focus {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-glow);
      }

      .dialog-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      .dialog-button.secondary {
        background: transparent;
        border-color: var(--panel-border);
        color: var(--muted);
      }

      .dialog-button.secondary:hover {
        border-color: var(--accent);
        color: var(--text);
        background: var(--accent-soft);
      }

      .dialog-button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-contrast);
      }

      .dialog-button.primary:hover {
        filter: brightness(0.95);
      }

      .dialog-button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: var(--danger-contrast);
      }

      .dialog-button.danger:hover {
        filter: brightness(0.92);
      }

      .panel-heading {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
        color: var(--muted);
      }

      .panel-heading label {
        margin: 0;
        color: inherit;
      }

      .top-bar {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 16px;
        padding: 18px 24px 16px;
        border-bottom: none;
        background: transparent;
        border-radius: var(--chrome-radius);
        overflow: hidden;
        border: 1px solid var(--chrome-border);
        box-shadow: var(--chrome-shadow);
        backdrop-filter: blur(22px);
        isolation: isolate;
      }

      .top-bar::before {
        content: '';
        position: absolute;
        inset: 0;
        background: var(--chrome-sheen);
        opacity: 0.95;
        pointer-events: none;
      }

      .top-bar::after {
        content: '';
        position: absolute;
        top: -120%;
        right: -40%;
        width: 160%;
        height: 200%;
        background: radial-gradient(
          circle at 35% 35%,
          var(--accent-highlight) 0%,
          transparent 62%
        );
        opacity: 0.35;
        filter: blur(44px);
        transform: rotate(10deg);
        pointer-events: none;
      }

      .top-bar-left,
      .top-bar-right {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
      }

      .top-bar button {
        position: relative;
        border-radius: var(--nav-button-radius);
        border: 1px solid var(--nav-button-border);
        background: var(--nav-button-bg);
        color: var(--interactive-text);
        padding: 10px 18px;
        font-weight: 600;
        letter-spacing: 0.01em;
        clip-path: var(--nav-button-clip);
        box-shadow: var(--nav-button-shadow);
        transition: transform 0.3s ease, color 0.3s ease, background 0.3s ease,
          box-shadow 0.3s ease, border-color 0.3s ease, opacity 0.3s ease;
        overflow: hidden;
      }

      .top-bar button::before {
        content: '';
        position: absolute;
        inset: -40% -20%;
        background: radial-gradient(
          circle at 30% 20%,
          var(--accent-highlight) 0%,
          transparent 65%
        );
        opacity: 0;
        transform: translateY(20%) scale(0.6);
        transition: opacity 0.4s ease, transform 0.4s ease;
        pointer-events: none;
      }

      .top-bar button:hover,
      .top-bar button:focus-visible {
        transform: translateY(-2px);
        border-color: var(--accent);
      }

      .top-bar button:hover::before,
      .top-bar button:focus-visible::before {
        opacity: 0.55;
        transform: translateY(0) scale(1);
      }

      .top-bar button:focus-visible {
        outline: none;
        box-shadow: var(--nav-button-shadow), 0 0 0 3px var(--accent-soft);
      }

      .top-bar button.active {
        background: linear-gradient(
          135deg,
          var(--nav-button-active) 0%,
          var(--accent-highlight) 100%
        );
        border-color: transparent;
        color: var(--accent-contrast);
        box-shadow: var(--nav-button-active-shadow);
      }

      .top-bar button.active::before {
        opacity: 0.85;
        transform: translateY(0) scale(1.05);
      }

      .top-bar button.ghost {
        background: var(--nav-button-bg);
        opacity: 0.86;
        color: var(--interactive-text);
      }

      .top-bar button.ghost:hover,
      .top-bar button.ghost:focus-visible {
        opacity: 1;
      }

      .top-bar button.ghost.active {
        opacity: 1;
      }

      .top-bar button.pill {
        border-radius: var(--nav-button-radius);
      }

      .content-panel {
        position: relative;
        padding: 0;
        overflow: hidden;
        border-radius: calc(var(--chrome-radius) - 6px);
        border: 1px solid var(--panel-border);
        background: var(--panel-bg);
        background-image: var(--panel-sheen);
        box-shadow: var(--panel-shadow-high);
        backdrop-filter: blur(18px);
        min-height: 360px;
        display: flex;
        flex-direction: column;
        flex: 1;
      }

      .content-panel::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.08) 0%,
          rgba(0, 0, 0, 0.04) 100%
        );
        opacity: 0.6;
        pointer-events: none;
      }

      .content-panel > * {
        position: relative;
        z-index: 1;
      }

      .view-stack {
        position: relative;
        flex: 1;
        min-height: 320px;
        perspective: var(--view-stack-perspective, 0px);
        display: grid;
        grid-auto-rows: minmax(0, 1fr);
        align-items: stretch;
        --view-direction: 1;
      }

      .content-panel .view {
        position: relative;
        grid-area: 1 / 1;
        padding: 24px;
        min-height: 0;
        overflow-y: auto;
        opacity: var(--view-enter-opacity, 0);
        pointer-events: none;
        transform: var(
          --view-enter-transform,
          translate3d(
            var(--view-enter-x, 0px),
            var(--view-enter-y, 24px),
            var(--view-enter-z, 0px)
          )
            scale(var(--view-enter-scale, 0.98))
            rotateX(var(--view-enter-tilt, 2deg))
        );
        filter: var(--view-enter-filter, blur(18px) saturate(1.08));
        --view-filter-duration: 340ms;
        --view-slide-distance: 56px;
        --view-enter-x: calc(var(--view-direction, 1) * var(--view-slide-distance));
        --view-exit-x: calc(var(--view-direction, 1) * -1 * var(--view-slide-distance));
        --view-enter-y: 24px;
        --view-exit-y: -18px;
        --view-enter-z: 0px;
        --view-exit-z: 0px;
        --view-enter-scale: 0.98;
        --view-exit-scale: 0.98;
        --view-enter-tilt: 2deg;
        --view-exit-tilt: -2deg;
        transition:
          opacity var(--view-transition-duration, 380ms)
            var(--view-transition-easing, cubic-bezier(0.25, 0.8, 0.25, 1)),
          transform var(--view-transition-duration, 380ms)
            var(--view-transition-easing, cubic-bezier(0.25, 0.8, 0.25, 1)),
          filter var(--view-filter-duration, 340ms)
            var(--view-transition-easing, cubic-bezier(0.25, 0.8, 0.25, 1));
        flex: 1 1 auto;
        width: 100%;
        box-sizing: border-box;
        transform-origin: var(--view-transform-origin, 50% 45%);
        transform-style: preserve-3d;
        backface-visibility: hidden;
        will-change: opacity, transform, filter;
      }

      .view {
        display: none;
      }

      .view.active,
      .view.leaving {
        display: block;
      }

      .view.active {
        opacity: var(--view-active-opacity, 1);
        pointer-events: auto;
        transform: var(
          --view-active-transform,
          translate3d(0, 0, 0) scale(1) rotateX(0deg)
        );
        filter: var(--view-active-filter, blur(0) saturate(1.02));
        z-index: 2;
      }

      .view.leaving {
        opacity: var(--view-exit-opacity, 0);
        pointer-events: none;
        transform: var(
          --view-exit-transform,
          translate3d(
            var(--view-exit-x, 0px),
            var(--view-exit-y, -18px),
            var(--view-exit-z, 0px)
          )
            scale(var(--view-exit-scale, 0.98))
            rotateX(var(--view-exit-tilt, -2deg))
        );
        filter: var(--view-exit-filter, blur(16px) saturate(0.94));
        z-index: 1;
      }

      .view[hidden] {
        display: none !important;
      }

      body[data-effects='none'] .view-stack {
        --view-stack-perspective: 0px;
      }

      body[data-effects='none'] .content-panel .view {
        transition: none;
        --view-transition-duration: 0ms;
        --view-filter-duration: 0ms;
        --view-enter-transform: none;
        --view-active-transform: none;
        --view-exit-transform: none;
        --view-enter-filter: none;
        --view-active-filter: none;
        --view-exit-filter: none;
        --view-transform-origin: 50% 50%;
      }

      body[data-effects='low'] .view-stack {
        --view-stack-perspective: 0px;
      }

      body[data-effects='low'] .content-panel .view {
        --view-transition-duration: 260ms;
        --view-transition-easing: cubic-bezier(0.33, 1, 0.68, 1);
        --view-filter-duration: 200ms;
        --view-slide-distance: 32px;
        --view-enter-y: 12px;
        --view-exit-y: -8px;
        --view-enter-scale: 0.99;
        --view-exit-scale: 0.995;
        --view-enter-tilt: 0deg;
        --view-exit-tilt: 0deg;
        --view-enter-filter: blur(6px) saturate(1.02);
        --view-active-filter: none;
        --view-exit-filter: blur(6px) saturate(0.98);
        --view-transform-origin: 50% 50%;
      }

      body[data-effects='mid'] .view-stack {
        --view-stack-perspective: 1200px;
      }

      body[data-effects='mid'] .content-panel .view {
        --view-transition-duration: 380ms;
        --view-transition-easing: cubic-bezier(0.24, 0.9, 0.25, 1);
        --view-filter-duration: 320ms;
        --view-slide-distance: 48px;
        --view-enter-y: 20px;
        --view-exit-y: -14px;
        --view-enter-scale: 0.97;
        --view-exit-scale: 0.985;
        --view-enter-tilt: 3deg;
        --view-exit-tilt: -2deg;
        --view-enter-filter: blur(18px) saturate(1.1);
        --view-active-filter: blur(0) saturate(1.02);
        --view-exit-filter: blur(12px) saturate(0.96);
        --view-transform-origin: 50% 44%;
      }

      body[data-effects='high'] .view-stack {
        --view-stack-perspective: 1800px;
      }

      body[data-effects='high'] .content-panel .view {
        --view-transition-duration: 520ms;
        --view-transition-easing: cubic-bezier(0.16, 1, 0.3, 1);
        --view-filter-duration: 460ms;
        --view-slide-distance: 70px;
        --view-enter-y: 16px;
        --view-exit-y: -16px;
        --view-enter-z: -120px;
        --view-exit-z: 140px;
        --view-enter-scale: 0.92;
        --view-exit-scale: 0.94;
        --view-enter-tilt: 8deg;
        --view-exit-tilt: -6deg;
        --view-enter-filter: blur(32px) saturate(1.28) brightness(1.06);
        --view-active-filter: blur(0) saturate(1.08) brightness(1);
        --view-exit-filter: blur(24px) saturate(0.9) brightness(0.92);
        --view-transform-origin: 50% 42%;
      }

      body[data-effects='high'] .content-panel .view::after {
        content: '';
        position: absolute;
        inset: 0;
        background:
          radial-gradient(
            140% 140% at 20% 20%,
            rgba(255, 255, 255, 0.28) 0%,
            rgba(255, 255, 255, 0) 65%
          ),
          linear-gradient(
            120deg,
            rgba(108, 176, 255, 0.28) 0%,
            rgba(181, 129, 255, 0.24) 45%,
            rgba(255, 255, 255, 0) 100%
          );
        opacity: 0;
        transform: translateY(72px) scale(0.88);
        filter: blur(38px);
        transition:
          opacity 540ms cubic-bezier(0.16, 1, 0.3, 1),
          transform 540ms cubic-bezier(0.16, 1, 0.3, 1),
          filter 520ms cubic-bezier(0.16, 1, 0.3, 1);
        pointer-events: none;
        mix-blend-mode: screen;
      }

      body[data-effects='high'] .content-panel .view.active::after {
        opacity: 0.24;
        transform: translateY(0) scale(1);
        filter: blur(18px);
      }

      body[data-effects='high'] .content-panel .view.leaving::after {
        opacity: 0;
        transform: translateY(-96px) scale(1.08);
        filter: blur(42px);
      }

      @media (prefers-reduced-motion: reduce) {
        body::before {
          animation: none !important;
        }
        .content-panel .view {
          transition: none !important;
          filter: none !important;
          transform: none !important;
        }
        .view.active,
        .view.leaving {
          transform: none !important;
          filter: none !important;
        }
        .content-panel .view::after {
          opacity: 0 !important;
          transform: none !important;
          filter: none !important;
        }
      }

      .tasks-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .tasks-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .tasks-header-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tasks-description {
        color: var(--muted);
        font-size: 0.95rem;
        margin: 0;
      }

      .tasks-empty {
        color: var(--muted);
        font-style: italic;
      }

      .tasks-list {
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .task-section {
        display: flex;
        flex-direction: column;
        gap: 10px;
        border-top: 1px solid var(--panel-border);
        padding-top: 12px;
      }

      .task-section:first-of-type {
        border-top: none;
        padding-top: 0;
      }

      .task-section-heading {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
        margin: 0;
      }

      .task-section-empty {
        margin: 0;
        font-size: 0.85rem;
        font-style: italic;
        color: var(--muted);
      }

      .task-entry {
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 14px 16px;
        background: var(--panel-bg);
        box-shadow: var(--panel-shadow);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .task-entry[data-status='error'] {
        border-color: var(--danger);
      }

      .task-entry-title {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: space-between;
        gap: 8px;
      }

      .task-entry-title h3 {
        margin: 0;
      }

      .task-entry-status {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--muted);
      }

      .task-entry[data-status='error'] .task-entry-status {
        color: var(--status-error-text);
      }

      .task-entry[data-status='finished'] .task-entry-status {
        color: var(--status-success-text);
      }

      .task-entry-meta {
        color: var(--muted);
        font-size: 0.85rem;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }

      .task-entry-message {
        margin: 0;
        font-size: 0.95rem;
      }

      .task-entry-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .task-entry-actions button {
        padding: 6px 12px;
        font-size: 0.85rem;
      }

      .task-entry-actions button.text {
        background: transparent;
        border-color: transparent;
        color: var(--accent);
        padding: 0;
      }

      .task-entry-actions button.text:hover {
        text-decoration: underline;
        opacity: 1;
      }

      .task-controls {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .task-controls button {
        min-width: 140px;
      }

      .edit-banner {
        background: var(--status-info-bg);
        color: var(--status-info-text);
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 0.9rem;
        margin-bottom: 12px;
      }

      h1 {
        font-size: 1.6rem;
        margin: 0 0 8px;
      }

      h2 {
        font-size: 1.2rem;
        margin: 0 0 12px;
      }

      h3 {
        font-size: 1rem;
        margin: 16px 0 8px;
      }

      p {
        margin: 0 0 12px;
        line-height: 1.5;
      }

      label {
        font-weight: 600;
        display: block;
        margin-bottom: 4px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      input[type='text'],
      input[type='search'],
      input[type='number'],
      textarea,
      select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 6px;
        border: 1px solid var(--panel-border);
        font-family: inherit;
        font-size: 0.95rem;
        background: var(--panel-bg);
        color: var(--text);
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      textarea {
        resize: vertical;
        min-height: 96px;
      }

      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px var(--accent-soft);
      }

      button {
        border: 1px solid var(--accent);
        background: var(--accent);
        color: var(--accent-contrast);
        border-radius: 6px;
        padding: 8px 14px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }

      button:hover {
        opacity: 0.92;
      }

      button.secondary {
        background: var(--nav-button-bg);
        border-color: var(--nav-button-border);
        color: var(--interactive-text);
        box-shadow: var(--nav-button-shadow);
      }

      button.secondary:hover {
        background: var(--nav-button-hover);
        border-color: var(--accent);
        color: var(--accent-contrast);
        box-shadow: var(--nav-button-active-shadow);
      }

      button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: var(--danger-contrast);
      }

      button.danger:hover {
        opacity: 0.9;
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .pill {
        border-radius: 999px;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
      }

      .stats-grid div {
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 10px;
        background: var(--background);
      }

      .stats-grid dt {
        margin: 0;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--muted);
      }

      .stats-grid dd {
        margin: 4px 0 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text);
      }

      .curriculum {
        margin-top: 12px;
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        padding: 16px;
        background: var(--panel-bg);
        max-height: calc(100vh - 260px);
        overflow-y: auto;
        font-size: 0.95rem;
      }

      .curriculum-editor-host {
        margin-top: 16px;
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        padding: 16px;
        background: var(--panel-bg);
      }

      .curriculum-editor-host[hidden] {
        display: none;
      }

      .curriculum.placeholder {
        color: var(--placeholder);
        font-style: italic;
      }

      .curriculum-editor {
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-height: 320px;
      }

      .curriculum-editor-header {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .curriculum-editor-header h3 {
        margin: 0;
        font-size: 1rem;
        color: var(--muted);
      }

      .curriculum-editor-header p {
        margin: 0;
        color: var(--placeholder);
        font-size: 0.85rem;
        line-height: 1.4;
      }

      .curriculum-editor-textarea {
        width: 100%;
        flex: 1;
        min-height: 260px;
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        padding: 12px 14px;
        background: var(--background);
        color: var(--text);
        font-family: 'JetBrains Mono', 'Fira Code', 'SFMono-Regular', Menlo, Consolas,
          monospace;
        font-size: 0.9rem;
        line-height: 1.5;
        resize: vertical;
        white-space: pre;
      }

      .curriculum-editor-textarea:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .curriculum-toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }

      .curriculum-toolbar h3 {
        margin: 0;
        font-size: 1rem;
        color: var(--muted);
      }

      .curriculum-toolbar-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .syllabus {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .syllabus details {
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        background: var(--background);
        overflow: hidden;
      }

      .syllabus summary {
        list-style: none;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        cursor: pointer;
        font-weight: 600;
        position: relative;
      }

      .syllabus summary::-webkit-details-marker {
        display: none;
      }

      .syllabus summary::before {
        content: '';
        width: 10px;
        height: 10px;
        border-right: 2px solid var(--muted);
        border-bottom: 2px solid var(--muted);
        transform: rotate(-45deg);
        transition: transform 0.2s ease;
        flex-shrink: 0;
      }

      details[open] > summary::before {
        transform: rotate(45deg);
      }

      .syllabus-summary-text {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
        min-width: 0;
      }

      .syllabus-summary-header {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .syllabus-id-tag {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0 6px;
        border-radius: 999px;
        background: var(--accent-soft);
        color: var(--accent);
        font-size: 0.75rem;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.02em;
      }

      .syllabus-title {
        font-size: 1rem;
      }

      .syllabus-meta {
        color: var(--muted);
        font-size: 0.85rem;
      }

      .syllabus-actions {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .syllabus-content {
        padding: 0 16px 16px 36px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .mini-console-panel {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .mini-console-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .mini-console-header h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .mini-console-entries {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .mini-console-entry {
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        padding: 10px 12px;
        box-shadow: var(--panel-shadow);
        background: var(--panel-bg);
        border-left: 4px solid var(--accent);
      }

      .mini-console-entry[data-variant='success'] {
        border-left-color: var(--status-success-text);
      }

      .mini-console-entry[data-variant='error'] {
        border-left-color: var(--status-error-text);
      }

      .mini-console-entry[data-variant='info'] {
        border-left-color: var(--status-info-text);
      }

      .mini-console-entry-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
      }

      .mini-console-message {
        margin: 0 0 8px;
        font-size: 0.9rem;
        color: var(--text);
      }

      .mini-console-meta {
        font-size: 0.75rem;
        color: var(--muted);
        letter-spacing: 0.02em;
      }

      .mini-console-progress-track {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: var(--status-progress-track);
        overflow: hidden;
      }

      .mini-console-progress-fill {
        height: 100%;
        border-radius: 999px;
        background: linear-gradient(90deg, var(--accent) 0%, var(--accent-highlight) 100%);
        transition: width 0.3s ease;
      }

      .mini-console-progress-fill.indeterminate {
        width: 100%;
        animation: mini-console-indeterminate 1.4s linear infinite;
        background: repeating-linear-gradient(
          120deg,
          var(--accent-soft) 0%,
          var(--accent) 25%,
          var(--accent-soft) 50%
        );
      }

      @keyframes mini-console-indeterminate {
        0% {
          transform: translateX(-30%);
        }
        100% {
          transform: translateX(30%);
        }
      }

      .mini-console-empty {
        font-size: 0.9rem;
        color: var(--muted);
        font-style: italic;
      }

      .syllabus-modules {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .syllabus-module summary {
        font-weight: 500;
        padding: 10px 14px;
      }

      .syllabus-module .syllabus-content {
        padding: 0 16px 16px 28px;
      }

      .syllabus-lectures {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .syllabus-lectures.empty {
        min-height: 36px;
      }

      .syllabus-lecture {
        display: flex;
        align-items: center;
        gap: 8px;
        position: relative;
      }

      .syllabus-lecture.dragging {
        opacity: 0.55;
      }

      .syllabus-lectures.drop-target {
        background: var(--accent-soft);
        border-radius: 8px;
        padding: 6px;
      }

      .syllabus-lecture.drop-before::before,
      .syllabus-lecture.drop-after::after {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent);
        border-radius: 999px;
      }

      .syllabus-lecture.drop-before::before {
        top: -4px;
      }

      .syllabus-lecture.drop-after::after {
        bottom: -4px;
      }

      .lecture-button {
        flex: 1;
        text-align: left;
        padding: 8px 12px;
        border: 1px solid transparent;
        border-radius: 8px;
        background: transparent;
        cursor: pointer;
        font-size: 0.95rem;
        color: inherit;
        transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .lecture-button .lecture-title {
        flex: 1;
        min-width: 0;
      }

      .lecture-button:hover,
      .lecture-button:focus {
        border-color: var(--panel-border);
        background: var(--accent-muted);
        outline: none;
      }

      .lecture-button.active {
        border-color: var(--accent);
        background: var(--accent-soft);
        color: var(--accent);
      }

      button.text-button {
        background: transparent;
        border: none;
        color: var(--accent);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      button.text-button:hover {
        background: var(--accent-muted);
      }

      button.text-button.danger {
        color: var(--danger);
      }

      button.text-button.danger:hover {
        background: rgba(220, 38, 38, 0.12);
      }

      .icon-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 30px;
        height: 30px;
        border-radius: 999px;
        border: none;
        background: transparent;
        color: var(--accent);
        padding: 0;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .icon-button:hover,
      .icon-button:focus-visible {
        background: var(--accent-muted);
      }

      .icon-button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px var(--accent-glow);
      }

      .icon-button.danger {
        width: auto;
        height: auto;
        min-width: 0;
        padding: 0;
        border-radius: 4px;
        background: transparent;
        color: var(--danger);
      }

      .icon-button.danger:hover,
      .icon-button.danger:focus-visible {
        background: rgba(220, 38, 38, 0.08);
        color: var(--danger);
      }

      .icon-button.danger:focus-visible {
        box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.2);
      }

      .icon-button .icon {
        font-size: 1.15rem;
        line-height: 1;
        transition: color 0.2s ease, transform 0.2s ease;
      }

      .icon-button.danger .icon {
        color: inherit;
        font-size: 1rem;
      }

      .icon-button.danger:hover .icon,
      .icon-button.danger:focus-visible .icon {
        transform: rotate(90deg);
      }

      .placeholder {
        color: var(--placeholder);
        font-style: italic;
        pointer-events: none;
      }

      .field {
        margin-bottom: 12px;
      }

      .form-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 12px;
      }

      .asset-list {
        list-style: none;
        margin: 12px 0 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .asset-item {
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 10px 12px;
        background: var(--background);
      }

      .asset-header {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .asset-status {
        font-size: 0.9rem;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .asset-sublist {
        list-style: none;
        margin: 6px 0 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .asset-sublist-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .asset-sublist-item strong {
        font-size: 0.9rem;
        color: var(--text);
      }

      .asset-sublist-meta {
        font-size: 0.8rem;
      }

      .asset-sublist-actions {
        margin-left: auto;
        display: flex;
        gap: 6px;
      }

      .asset-sublist-actions button {
        border: none;
        background: none;
        color: var(--accent);
        cursor: pointer;
        font-size: 0.8rem;
        padding: 0;
      }

      .asset-sublist-actions button:hover {
        text-decoration: underline;
      }

      .asset-status-note {
        display: block;
        margin-top: 4px;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .asset-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      .asset-actions button {
        border-radius: var(--nav-button-radius);
        border: 1px solid var(--nav-button-border);
        background: var(--nav-button-bg);
        color: var(--interactive-text);
        padding: 8px 16px;
        font-weight: 600;
        cursor: pointer;
        clip-path: var(--nav-button-clip);
        box-shadow: var(--nav-button-shadow);
        transition: transform 0.25s ease, background 0.25s ease,
          color 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease,
          opacity 0.25s ease;
      }

      .asset-actions button.secondary {
        background: var(--nav-button-bg);
      }

      .asset-actions button.secondary:hover {
        border-color: var(--accent);
        color: var(--accent-contrast);
        background: var(--nav-button-hover);
        box-shadow: var(--nav-button-active-shadow);
        transform: translateY(-2px);
      }

      .asset-actions button.danger {
        background: var(--danger);
        border-color: transparent;
        color: var(--danger-contrast);
        box-shadow: var(--nav-button-active-shadow);
      }

      .asset-actions button.danger:hover {
        filter: none;
        transform: translateY(-2px);
      }

      .asset-actions button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
        filter: none;
        transform: none;
        box-shadow: none;
      }

      .asset-actions label.inline {
        display: inline-flex;
        flex-direction: column;
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .asset-actions label.inline select,
      .asset-actions label.inline input {
        margin-top: 4px;
        min-width: 120px;
      }

      #asset-section {
        margin-top: 16px;
      }

      #settings-form fieldset {
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 16px;
        margin: 0 0 16px;
      }

      #settings-form fieldset:last-of-type {
        margin-bottom: 0;
      }

      #settings-form legend {
        font-weight: 600;
        color: var(--muted);
        padding: 0 6px;
      }

      #settings-form .field-inline {
        display: flex;
        flex-direction: column;
        margin-bottom: 12px;
      }

      #settings-form .field-inline:last-child {
        margin-bottom: 0;
      }

      #settings-form .field-inline.gpu-support {
        flex-direction: row;
        align-items: center;
        gap: 16px;
      }

      #settings-form .field-inline.cloud-connection-status {
        flex-direction: row;
        align-items: center;
        gap: 16px;
      }

      .update-status {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .update-meta {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .update-log-wrapper {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .update-log-label {
        font-size: 0.9rem;
        font-weight: 500;
      }

      .update-log {
        background: rgba(15, 23, 42, 0.05);
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 12px;
        font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        font-size: 0.85rem;
        line-height: 1.4;
        max-height: 240px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-break: break-word;
      }

      body[data-display-mode='dark'] .update-log {
        background: rgba(148, 163, 184, 0.12);
      }

      @media (prefers-color-scheme: dark) {
        body[data-display-mode='system'] .update-log {
          background: rgba(148, 163, 184, 0.12);
        }
      }

      .update-log-empty {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .field-help {
        font-size: 0.85rem;
        color: var(--muted);
        margin: 6px 0 0;
      }

      .archive-controls {
        flex-direction: row;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .archive-controls label.inline {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .archive-controls select {
        min-width: 180px;
      }

      .gpu-support-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
      }

      #settings-whisper-gpu-status {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
      }

      #settings-whisper-gpu-test {
        white-space: nowrap;
      }

      #settings-local-boost-status {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
      }

      #settings-local-boost-test {
        white-space: nowrap;
      }

      @media (max-width: 960px) {
        main.layout {
          flex-direction: column;
          padding: 16px;
        }

        .sidebar {
          width: auto;
        }

        .curriculum {
          max-height: 320px;
        }
      }
    </style>
  </head>
  <body data-display-mode="system" data-theme="vibrant" data-effects="mid">
    <main class="layout">
      <aside class="sidebar">
        <section class="panel">
          <h1 data-i18n="sidebar.heading">Lecture Tools</h1>
          <p data-i18n="sidebar.tagline">Review, organise, and process lecture resources quickly.</p>
        </section>
        <section id="sidebar-overview" class="panel" hidden>
          <h2 data-i18n="sidebar.overview">Overview</h2>
          <dl id="stats" class="stats-grid"></dl>
        </section>
        <section class="panel">
          <div class="panel-heading">
            <h2 data-i18n="sidebar.syllabusTitle">Course syllabus</h2>
          </div>
          <label
            class="sr-only"
            for="search-input"
            data-i18n="sidebar.searchLabel"
          >
            Search syllabus
          </label>
          <input
            id="search-input"
            type="search"
            placeholder="Search by name"
            data-i18n="sidebar.searchPlaceholder"
            data-i18n-attr="placeholder"
            autocomplete="off"
          />
          <div id="curriculum" class="curriculum">
            <div class="placeholder" data-i18n="sidebar.loading">Loading</div>
          </div>
        </section>
        <section id="mini-console-panel" class="panel mini-console-panel">
          <div class="mini-console-header">
            <h2 data-i18n="sidebar.miniConsoleTitle">Mini console</h2>
          </div>
          <div
            id="mini-console-empty"
            class="mini-console-empty"
            data-i18n="sidebar.miniConsoleEmpty"
          >
            No recent activity.
          </div>
          <div
            id="mini-console-entries"
            class="mini-console-entries"
            role="log"
            aria-live="polite"
            aria-atomic="false"
          ></div>
        </section>
      </aside>
      <section class="content">
        <section class="panel content-panel">
          <div class="top-bar" role="tablist">
            <div class="top-bar-left">
              <button
                type="button"
                class="active"
                data-view="details"
                aria-pressed="true"
                data-i18n="topBar.details"
              >
                Details
              </button>
              <button
                id="toggle-edit-mode"
                type="button"
                class="ghost pill"
                aria-pressed="false"
                data-i18n="topBar.enableEdit"
              >
                Enable edit mode
              </button>
            </div>
            <div class="top-bar-right">
              <button
                type="button"
                class="ghost"
                data-view="tasks"
                aria-pressed="false"
                data-i18n="topBar.tasks"
              >
                Tasks
              </button>
              <button
                type="button"
                data-view="create"
                aria-pressed="false"
                data-i18n="topBar.create"
              >
                Create
              </button>
              <button
                type="button"
                class="ghost"
                data-view="storage"
                aria-pressed="false"
                data-i18n="topBar.storage"
              >
                Storage
              </button>
              <button
                type="button"
                data-view="settings"
                aria-pressed="false"
                data-i18n="topBar.settings"
              >
                Settings
              </button>
            </div>
          </div>
          <div id="view-stack" class="view-stack">
            <div id="view-details" class="view active" data-view="details">
            <header style="display: flex; justify-content: space-between; align-items: center;">
              <h2 data-i18n="details.title">Lecture details</h2>
              <button
                id="delete-lecture"
                class="danger"
                type="button"
                hidden
                data-i18n="details.deleteLecture"
              >
                Delete lecture
              </button>
            </header>
            <div id="edit-mode-banner" class="edit-banner" hidden data-i18n="details.editModeBanner">
              Edit mode is enabled. Update lecture information or remove items while it is active.
            </div>
            <div id="curriculum-editor-host" class="curriculum-editor-host" hidden></div>
            <div id="lecture-summary" class="placeholder" data-i18n="details.summaryPlaceholder">
              Select a lecture from the curriculum.
            </div>
            <form id="lecture-edit-form" hidden>
              <div class="field">
                <label for="edit-lecture-name" data-i18n="details.edit.titleLabel">Title</label>
                <input id="edit-lecture-name" name="name" type="text" required />
              </div>
              <div class="field">
                <label for="edit-lecture-module" data-i18n="details.edit.moduleLabel">Module</label>
                <select id="edit-lecture-module" name="module" required></select>
              </div>
              <div class="field">
                <label
                  for="edit-lecture-description"
                  data-i18n="details.edit.descriptionLabel"
                >
                  Description
                </label>
                <textarea
                  id="edit-lecture-description"
                  name="description"
                  rows="4"
                ></textarea>
              </div>
              <div class="form-actions">
                <button type="submit" data-i18n="details.edit.save">Save changes</button>
              </div>
            </form>
            <section id="asset-section" hidden>
              <h3 data-i18n="assets.title">Assets</h3>
              <ul id="asset-list" class="asset-list"></ul>
            </section>
            </div>
            <div id="view-tasks" class="view" data-view="tasks" hidden>
            <section class="panel tasks-panel">
              <div class="tasks-header">
                <h2 data-i18n="tasks.title">Tasks</h2>
                <div class="tasks-header-actions">
                  <button
                    id="tasks-clear-done"
                    type="button"
                    class="ghost"
                    data-i18n="tasks.clearDone"
                  >
                    Clear done
                  </button>
                  <button id="tasks-refresh" type="button" class="ghost" data-i18n="tasks.refresh">
                    Refresh
                  </button>
                </div>
              </div>
                <p id="tasks-description" class="tasks-description" data-i18n="tasks.description">
                  Queue transcription and slide processing jobs to run in order.
              </p>
              <div class="task-controls">
                <button
                  id="task-bulk-process"
                  type="button"
                  class="secondary"
                  data-i18n="tasks.bulkProcess.button"
                >
                  Bulk process
                </button>
                <button
                  id="task-bulk-upload"
                  type="button"
                  class="secondary"
                  data-i18n="tasks.bulkUpload.button"
                >
                  Bulk upload
                </button>
                <button
                  id="task-bulk-download"
                  type="button"
                  class="secondary"
                  data-i18n="tasks.bulkDownload.button"
                >
                  Bulk download
                </button>
              </div>
              <input id="task-bulk-input" class="sr-only" type="file" multiple />
              <div id="tasks-empty" class="tasks-empty" data-i18n="tasks.empty">
                No tasks in the queue.
              </div>
              <div
                id="tasks-list"
                class="tasks-list"
                role="list"
                aria-live="polite"
                aria-busy="false"
              ></div>
            </section>
            </div>
            <div id="view-create" class="view" data-view="create" hidden>
            <h2 data-i18n="create.title">Create lecture</h2>
            <form id="lecture-create-form">
              <div class="field">
                <label for="create-module" data-i18n="create.moduleLabel">Module</label>
                <select id="create-module" required></select>
              </div>
              <div class="field">
                <label for="create-name" data-i18n="create.titleLabel">Title</label>
                <input id="create-name" type="text" required />
              </div>
              <div class="field">
                <label for="create-description" data-i18n="create.descriptionLabel">Description</label>
                <textarea id="create-description" rows="4"></textarea>
              </div>
              <div class="form-actions">
                <button id="create-submit" type="submit" data-i18n="create.submit">
                  Add lecture
                </button>
              </div>
            </form>
            </div>
            <div id="view-storage" class="view" data-view="storage" hidden>
            <div class="storage-page">
              <div class="storage-header">
                <h2 data-i18n="storage.title">Storage manager</h2>
                <div class="storage-actions">
                  <button id="storage-refresh" type="button" data-i18n="storage.actions.refresh">
                    Refresh
                  </button>
                  <button
                    id="storage-repair"
                    type="button"
                    class="secondary"
                    data-i18n="storage.actions.repair"
                  >
                    Repair storage
                  </button>
                  <button
                    id="storage-download-selected"
                    type="button"
                    class="secondary"
                    data-i18n="storage.actions.downloadSelected"
                    disabled
                  >
                    Download selected
                  </button>
                  <button
                    id="storage-purge"
                    type="button"
                    class="danger"
                    data-i18n="storage.actions.purge"
                  >
                    Remove processed audio
                  </button>
                </div>
              </div>
              <section class="storage-browser" aria-live="polite">
                <div class="storage-browser-toolbar">
                  <div class="storage-browser-nav">
                    <button
                      id="storage-nav-root"
                      type="button"
                      data-i18n="storage.browser.root"
                    >
                      Root
                    </button>
                    <button
                      id="storage-nav-up"
                      type="button"
                      data-i18n="storage.browser.up"
                    >
                      Up
                    </button>
                  </div>
                  <p id="storage-path" class="storage-path">/</p>
                </div>
                <div
                  id="storage-browser-loading"
                  class="storage-loading"
                  hidden
                  data-i18n="storage.browser.loading"
                >
                  Loading
                </div>
                <div
                  id="storage-browser-empty"
                  class="storage-empty"
                  hidden
                  data-i18n="storage.browser.empty"
                >
                  No files or folders found.
                </div>
                <div
                  id="storage-browser-table-wrapper"
                  class="storage-browser-table-wrapper"
                  hidden
                >
                  <table class="storage-browser-table">
                    <thead>
                      <tr>
                        <th scope="col" class="storage-select-header">
                          <label
                            class="sr-only"
                            for="storage-select-all"
                            data-i18n="storage.browser.select"
                          >
                            Select
                          </label>
                          <input id="storage-select-all" type="checkbox" disabled />
                        </th>
                        <th scope="col" data-i18n="storage.browser.name">Name</th>
                        <th scope="col" data-i18n="storage.browser.type">Type</th>
                        <th scope="col" data-i18n="storage.browser.size">Size</th>
                        <th scope="col" data-i18n="storage.browser.modified">Modified</th>
                        <th scope="col" data-i18n="storage.browser.actions">Actions</th>
                      </tr>
                    </thead>
                    <tbody id="storage-browser-body"></tbody>
                  </table>
                </div>
              </section>
              <section class="storage-usage" aria-live="polite">
                <div class="storage-usage-item">
                  <span class="storage-usage-label" data-i18n="storage.usage.used">Used</span>
                  <span id="storage-used" class="storage-usage-value">--</span>
                </div>
                <div class="storage-usage-item">
                  <span class="storage-usage-label" data-i18n="storage.usage.available">Available</span>
                  <span id="storage-available" class="storage-usage-value">--</span>
                </div>
                <div class="storage-usage-item">
                  <span class="storage-usage-label" data-i18n="storage.usage.total">Total</span>
                  <span id="storage-total" class="storage-usage-value">--</span>
                </div>
                <div class="storage-usage-item">
                  <span class="storage-usage-label" data-i18n="storage.usage.library">Library size</span>
                  <span id="storage-library" class="storage-usage-value">--</span>
                </div>
              </section>
              <p
                id="storage-purge-summary"
                class="storage-purge-summary"
                data-i18n="storage.purge.none"
              ></p>
              <p
                id="storage-repair-summary"
                class="storage-purge-summary"
                data-i18n="storage.repair.none"
              ></p>
              <div id="storage-loading" class="storage-loading" hidden data-i18n="storage.loading">
                Loading
              </div>
              <div id="storage-empty" class="storage-empty" hidden data-i18n="storage.empty">
                No stored classes found.
              </div>
            <div id="storage-class-wrapper" class="storage-class-wrapper" hidden>
              <ul id="storage-class-list" class="storage-class-list"></ul>
            </div>
            </div>
            </div>
            <div id="view-settings" class="view" data-view="settings" hidden>
            <h2 data-i18n="settings.title">Settings</h2>
            <form id="settings-form">
              <fieldset>
                <legend data-i18n="settings.appearance.legend">Appearance</legend>
                <div class="field-inline">
                  <label
                    for="settings-display-mode"
                    data-i18n="settings.appearance.displayModeLabel"
                  >
                    Display Mode
                  </label>
                  <select id="settings-display-mode">
                    <option value="system" data-i18n="settings.appearance.displayMode.system">
                      Follow system
                    </option>
                    <option value="bright" data-i18n="settings.appearance.displayMode.bright">
                      Bright
                    </option>
                    <option value="dark" data-i18n="settings.appearance.displayMode.dark">
                      Dark
                    </option>
                  </select>
                </div>
                <div class="field-inline">
                  <label for="settings-theme" data-i18n="settings.appearance.themeLabel">
                    Theme Palette
                  </label>
                  <select id="settings-theme">
                    <option value="vibrant" data-i18n="settings.appearance.theme.vibrant">
                      Vibrant
                    </option>
                    <option value="serene" data-i18n="settings.appearance.theme.serene">
                      Serene
                    </option>
                    <option value="noir" data-i18n="settings.appearance.theme.noir">
                      Noir
                    </option>
                    <option value="solar" data-i18n="settings.appearance.theme.solar">
                      Solar
                    </option>
                    <option value="cyber" data-i18n="settings.appearance.theme.cyber">
                      Cyber
                    </option>
                    <option value="pastel" data-i18n="settings.appearance.theme.pastel">
                      Pastel
                    </option>
                    <option value="obsidian" data-i18n="settings.appearance.theme.obsidian">
                      Obsidian
                    </option>
                    <option value="ethereal" data-i18n="settings.appearance.theme.ethereal">
                      Ethereal
                    </option>
                  </select>
                </div>
                <div class="field-inline">
                  <label
                    for="settings-visual-effects"
                    data-i18n="settings.appearance.effectsLabel"
                  >
                    Visual Effects Level
                  </label>
                  <select id="settings-visual-effects">
                    <option value="none" data-i18n="settings.appearance.effects.none">
                      None
                    </option>
                    <option value="low" data-i18n="settings.appearance.effects.low">Low</option>
                    <option value="mid" data-i18n="settings.appearance.effects.mid">Medium</option>
                    <option value="high" data-i18n="settings.appearance.effects.high">High</option>
                  </select>
                </div>
                <div class="field-inline">
                  <label for="settings-language" data-i18n="settings.language.label">Language</label>
                  <select id="settings-language">
                    <option value="en" data-i18n="settings.language.choices.en">English</option>
                    <option value="zh" data-i18n="settings.language.choices.zh"> (Chinese)</option>
                    <option value="es" data-i18n="settings.language.choices.es">Espaol (Spanish)</option>
                    <option value="fr" data-i18n="settings.language.choices.fr">Franais (French)</option>
                  </select>
                </div>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.debug.legend">Debugging</legend>
                <label class="field-inline" for="settings-debug-enabled">
                  <input id="settings-debug-enabled" type="checkbox" />
                  <span data-i18n="settings.debug.enable">Enable debug mode</span>
                </label>
                <p class="field-help" data-i18n="settings.debug.description">
                  Show a live console on the right that streams detailed program output.
                </p>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.whisper.legend">Whisper transcription</legend>
                <div class="field-inline">
                  <label for="settings-whisper-model" data-i18n="settings.whisper.modelLabel">
                    Default model
                  </label>
                  <select id="settings-whisper-model" required>
                    <option value="tiny" data-i18n="settings.whisper.model.tiny">Tiny (fastest)</option>
                    <option value="base" selected data-i18n="settings.whisper.model.base">
                      Base (balanced)
                    </option>
                    <option value="small" data-i18n="settings.whisper.model.small">
                      Small (accurate)
                    </option>
                    <option value="medium" data-i18n="settings.whisper.model.medium">
                      Medium (detailed)
                    </option>
                    <option value="large" data-i18n="settings.whisper.model.large">
                      Large (maximum accuracy)
                    </option>
                    <option value="gpu" class="gpu-only" disabled data-i18n="settings.whisper.model.gpu">
                      GPU (hardware accelerated)
                    </option>
                  </select>
                </div>
                <div class="field-inline">
                  <label for="settings-whisper-compute" data-i18n="settings.whisper.computeLabel">
                    Compute type
                  </label>
                  <input id="settings-whisper-compute" type="text" required />
                </div>
                <div class="field-inline">
                  <label for="settings-whisper-beam" data-i18n="settings.whisper.beamLabel">
                    Beam size
                  </label>
                  <input id="settings-whisper-beam" type="number" min="1" max="10" required />
                </div>
                <div class="field-inline gpu-support">
                  <div class="gpu-support-info">
                    <label data-i18n="settings.whisper.gpu.label">GPU support</label>
                    <p id="settings-whisper-gpu-status" data-i18n="settings.whisper.gpu.status">
                      GPU acceleration not tested.
                    </p>
                  </div>
                  <button id="settings-whisper-gpu-test" type="button" class="secondary">
                    <span data-i18n="settings.whisper.gpu.test">Test support</span>
                  </button>
                </div>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.cloudConnection.legend">Cloud connection</legend>
                <label class="field-inline" for="settings-cloud-connection-enabled">
                  <input id="settings-cloud-connection-enabled" type="checkbox" />
                  <span data-i18n="settings.cloudConnection.enable">Connect to cloud server</span>
                </label>
                <div class="field-inline">
                  <label for="settings-cloud-server-url" data-i18n="settings.cloudConnection.urlLabel">
                    Cloud server URL
                  </label>
                  <input
                    id="settings-cloud-server-url"
                    type="url"
                    inputmode="url"
                    placeholder="https://cloud.example.com"
                  />
                </div>
                <label class="field-inline" for="settings-cloud-auto-connect">
                  <input id="settings-cloud-auto-connect" type="checkbox" />
                  <span data-i18n="settings.cloudConnection.autoConnect">
                    Always auto-connect on launch
                  </span>
                </label>
                <div class="field-inline">
                  <label for="settings-cloud-processing-target" data-i18n="settings.cloudConnection.processingLabel">
                    Process tasks
                  </label>
                  <select id="settings-cloud-processing-target" required>
                    <option value="cloud" data-i18n="settings.cloudConnection.processing.cloud">
                      In the cloud
                    </option>
                    <option value="local" data-i18n="settings.cloudConnection.processing.local">
                      On this machine
                    </option>
                  </select>
                </div>
                <div class="field-inline cloud-connection-status">
                  <div class="gpu-support-info">
                    <label data-i18n="settings.cloudConnection.statusLabel">Connection status</label>
                    <p id="settings-cloud-connection-status" data-i18n="settings.cloudConnection.status.idle">
                      Not tested.
                    </p>
                  </div>
                  <button id="settings-cloud-connection-test" type="button" class="secondary">
                    <span data-i18n="settings.cloudConnection.test">Test connection</span>
                  </button>
                </div>
                <p class="field-help" data-i18n="settings.cloudConnection.description">
                  Connect your local UI to a cloud server. Cloud mode streams structures and assets
                  from the server and only pulls files when needed. When you disconnect or restart,
                  cloud files are cleared locally.
                </p>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.audio.legend">Audio</legend>
                <div class="field-inline">
                  <label for="settings-audio-mastering" data-i18n="settings.audio.masteringLabel">
                    Enable mastered audio
                  </label>
                  <input id="settings-audio-mastering" type="checkbox" />
                </div>
                <p class="field-help" data-i18n="settings.audio.masteringDescription">
                  Automatically enhance uploaded audio for clarity.
                </p>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.slides.legend">Slides</legend>
                <div class="field-inline">
                  <label for="settings-slide-dpi" data-i18n="settings.slides.dpiLabel">
                    Rendering DPI
                  </label>
                  <select id="settings-slide-dpi" required>
                    <option value="150" data-i18n="settings.slides.dpi.150">150 dpi (fastest)</option>
                    <option value="200" selected data-i18n="settings.slides.dpi.200">
                      200 dpi (balanced)
                    </option>
                    <option value="300" data-i18n="settings.slides.dpi.300">
                      300 dpi (detailed)
                    </option>
                    <option value="400" data-i18n="settings.slides.dpi.400">
                      400 dpi (high detail)
                    </option>
                    <option value="600" data-i18n="settings.slides.dpi.600">
                      600 dpi (maximum)
                    </option>
                  </select>
                </div>
                <label class="field-inline" for="settings-slide-force-ocr">
                  <input id="settings-slide-force-ocr" type="checkbox" />
                  <span data-i18n="settings.slides.forceOcrLabel">
                    Force OCR even when text is detected
                  </span>
                </label>
                <p class="field-help" data-i18n="settings.slides.forceOcrDescription">
                  Always run OCR on slide PDFs, even if a text layer is present.
                </p>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.update.legend">System updates</legend>
                <p class="field-help" data-i18n="settings.update.description">
                  Update Lecture Tools without leaving the browser.
                </p>
                <label for="settings-update-password" data-i18n="settings.update.passwordLabel">
                  Sudo password
                </label>
                <input
                  id="settings-update-password"
                  type="password"
                  autocomplete="new-password"
                />
                <div class="field-inline">
                  <label class="inline" for="settings-update-password-clear">
                    <input id="settings-update-password-clear" type="checkbox" />
                    <span data-i18n="settings.update.passwordClear">Clear saved password</span>
                  </label>
                  <span
                    id="settings-update-password-status"
                    class="field-help"
                    data-i18n="settings.update.passwordSaved"
                    hidden
                  >
                    Password saved.
                  </span>
                </div>
                <p class="field-help" data-i18n="settings.update.passwordHelp">
                  Passwords are hidden after saving. Enter a new password to replace the saved one.
                </p>
                <div class="field-inline">
                  <button id="settings-update-run" type="button" class="secondary" data-i18n="settings.update.run">
                    Run update
                  </button>
                  <button
                    id="settings-update-refresh"
                    type="button"
                    class="ghost"
                    data-i18n="settings.update.refresh"
                  >
                    Refresh status
                  </button>
                </div>
                <div class="update-status">
                  <div
                    id="settings-update-status"
                    class="field-help"
                    data-i18n="settings.update.status.idle"
                  >
                    No update in progress.
                  </div>
                  <div id="settings-update-meta" class="update-meta" hidden></div>
                </div>
                <div id="settings-update-log-wrapper" class="update-log-wrapper" hidden>
                  <div class="update-log-label" data-i18n="settings.update.logLabel">Activity log</div>
                  <pre
                    id="settings-update-log"
                    class="update-log"
                    aria-live="polite"
                    hidden
                  ></pre>
                  <div
                    id="settings-update-log-empty"
                    class="update-log-empty"
                    data-i18n="settings.update.logEmpty"
                  >
                    No update activity yet.
                  </div>
                </div>
              </fieldset>
              <fieldset>
                <legend data-i18n="settings.archive.legend">Archive</legend>
                <p class="field-help" data-i18n="settings.archive.description">
                  Export your lectures and assets or import an archive from another machine.
                </p>
                <div class="field-inline archive-controls">
                  <button id="settings-export" type="button" class="secondary" data-i18n="settings.archive.export">
                    Export archive
                  </button>
                  <button
                    id="settings-import"
                    type="button"
                    class="secondary"
                    data-i18n="settings.archive.import"
                  >
                    Import archive
                  </button>
                  <label class="inline" for="settings-import-mode" data-i18n="settings.archive.modeLabel">
                    Import mode
                    <select id="settings-import-mode">
                      <option value="merge" data-i18n="settings.archive.modes.merge">Merge with existing</option>
                      <option value="replace" data-i18n="settings.archive.modes.replace">Replace existing data</option>
                    </select>
                  </label>
                </div>
                <p class="field-help" data-i18n="settings.archive.hint">
                  Exported archives are stored temporarily and cleared when the app starts.
                </p>
              </fieldset>
              <div class="form-actions">
                <button type="submit" data-i18n="settings.save">Save settings</button>
              </div>
              <div class="form-actions">
                <button id="settings-exit-app" type="button" class="danger" data-i18n="settings.exit">
                  Exit application
                </button>
              </div>
            </form>
            </div>
          </div>
        </section>
      </section>
    </main>
    <aside
      id="debug-pane"
      class="debug-pane"
      role="region"
      aria-live="polite"
      aria-label="Debug console"
      hidden
    >
      <div class="debug-pane-header">
        <h2 class="debug-pane-title" data-i18n="debug.title">Debug console</h2>
        <span class="debug-indicator" data-i18n="debug.live">Live</span>
      </div>
      <div id="debug-heartbeat" class="debug-heartbeat" data-state="idle">
        <div class="debug-heartbeat-track" aria-hidden="true"></div>
        <span class="sr-only">Recent activity timeline</span>
      </div>
      <div class="debug-pane-controls">
        <label class="debug-filter">
          <span class="debug-filter-label">Severity</span>
          <select id="debug-filter-severity">
            <option value="all">All</option>
            <option value="debug">Debug</option>
            <option value="info">Info</option>
            <option value="warning">Warning</option>
            <option value="error">Error</option>
            <option value="critical">Critical</option>
          </select>
        </label>
        <label class="debug-filter">
          <span class="debug-filter-label">Category</span>
          <select id="debug-filter-category">
            <option value="all">All</option>
            <option value="app">App</option>
            <option value="task">Task</option>
            <option value="server">Server</option>
          </select>
        </label>
        <label class="debug-filter">
          <span class="debug-filter-label">Correlation</span>
          <input
            id="debug-filter-correlation"
            type="search"
            placeholder="Filter by correlation ID"
            autocomplete="off"
          />
        </label>
        <label class="debug-filter">
          <span class="debug-filter-label">Task</span>
          <input
            id="debug-filter-task"
            type="search"
            placeholder="Filter by task ID"
            autocomplete="off"
          />
        </label>
        <label class="debug-filter debug-filter--wide">
          <span class="debug-filter-label">Quick search</span>
          <input
            id="debug-filter-query"
            type="search"
            placeholder="Search message, context, or trace"
            autocomplete="off"
          />
        </label>
        <button id="debug-filter-clear" type="button" class="debug-filter-clear">
          Clear
        </button>
        <button id="debug-download-log" type="button" class="debug-download-button">
          Download log
        </button>
      </div>
      <div
        id="debug-log-window"
        class="debug-log-window"
        role="log"
        aria-live="polite"
        aria-atomic="false"
        tabindex="0"
      >
        <div id="debug-log-empty" class="debug-log-empty" data-i18n="debug.empty">
          Enable debug mode to inspect program activity in real time.
        </div>
      </div>
      <div
        id="debug-stream-window"
        class="debug-stream-window"
        role="status"
        aria-live="polite"
        aria-atomic="false"
      >
        <div class="debug-stream-header">
          <span class="debug-stream-title" data-i18n="debug.stream.title">Server activity</span>
        </div>
        <div id="debug-stream-entries" class="debug-stream-entries">
          <div id="debug-stream-empty" class="debug-stream-empty" data-i18n="debug.stream.empty">
            Waiting for server activity
          </div>
        </div>
      </div>
      <div id="debug-log-status" class="debug-log-status" hidden></div>
    </aside>
    <div id="dialog-root" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="dialog-backdrop" class="dialog-backdrop"></div>
      <div
        id="dialog-window"
        class="dialog-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="dialog-title"
        aria-describedby="dialog-message"
      >
        <div class="dialog-header">
          <h2 id="dialog-title" class="dialog-title"></h2>
        </div>
        <div id="dialog-message" class="dialog-message"></div>
        <div id="dialog-input-wrapper" class="dialog-input-wrapper hidden">
          <input id="dialog-input" class="dialog-input" type="text" autocomplete="off" />
        </div>
        <div class="dialog-actions">
          <button
            type="button"
            id="dialog-cancel"
            class="dialog-button secondary"
            data-i18n="dialog.cancel"
          >
            Cancel
          </button>
          <button
            type="button"
            id="dialog-confirm"
            class="dialog-button primary"
            data-i18n="dialog.confirm"
          >
            Confirm
          </button>
        </div>
      </div>
    </div>
    <div id="slide-range-dialog" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="slide-range-backdrop" class="dialog-backdrop"></div>
      <div
        id="slide-range-window"
        class="dialog-window slide-range-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="slide-range-title"
        aria-describedby="slide-range-description"
      >
        <div class="dialog-header">
          <h2 id="slide-range-title" class="dialog-title"></h2>
        </div>
        <p id="slide-range-description" class="dialog-message"></p>
        <div class="slide-range-body">
          <div id="slide-range-preview" class="slide-range-preview">
            <div id="slide-range-loading" class="slide-range-loading"></div>
            <div id="slide-range-error" class="slide-range-error hidden"></div>
            <div
              id="slide-range-fallback"
              class="slide-range-fallback hidden"
              aria-live="polite"
            >
              <div class="slide-range-fallback-preview">
                <iframe
                  id="slide-range-fallback-frame"
                  title=""
                  loading="lazy"
                  referrerpolicy="no-referrer"
                ></iframe>
              </div>
              <p id="slide-range-fallback-message" class="slide-range-fallback-message"></p>
              <a
                id="slide-range-fallback-link"
                class="slide-range-fallback-link hidden"
                href="#"
                target="_blank"
                rel="noopener noreferrer"
              ></a>
            </div>
            <div id="slide-range-pages" class="slide-range-pages"></div>
          </div>
          <div class="slide-range-controls">
            <div class="page-selection">
              <div class="page-inputs">
                <label for="slide-range-start">
                  <span id="slide-range-start-label"></span>
                  <input id="slide-range-start" type="number" min="1" value="1" />
                </label>
                <label for="slide-range-end">
                  <span id="slide-range-end-label"></span>
                  <input id="slide-range-end" type="number" min="1" value="1" />
                </label>
              </div>
              <div class="page-actions">
                <button
                  type="button"
                  id="slide-range-select-all"
                  class="dialog-button secondary"
                ></button>
                <button
                  type="button"
                  id="slide-range-confirm"
                  class="dialog-button primary"
                ></button>
              </div>
            </div>
            <div class="slide-range-zoom">
              <div class="slide-range-zoom-header">
                <label id="slide-range-zoom-label" for="slide-range-zoom"></label>
                <span
                  id="slide-range-zoom-value"
                  class="slide-range-zoom-value"
                  aria-live="polite"
                ></span>
              </div>
              <input
                id="slide-range-zoom"
                type="range"
                min="50"
                max="200"
                value="100"
                step="10"
              />
            </div>
            <p id="slide-range-hint" class="slide-range-hint"></p>
            <p id="slide-range-summary" class="page-range-summary"></p>
          </div>
        </div>
        <div class="dialog-actions slide-range-footer">
          <button type="button" id="slide-range-cancel" class="dialog-button secondary"></button>
        </div>
      </div>
    </div>
    <div id="asset-viewer" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="asset-viewer-backdrop" class="dialog-backdrop"></div>
      <div
        id="asset-viewer-window"
        class="dialog-window asset-viewer-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="asset-viewer-title"
        tabindex="-1"
      >
        <div class="asset-viewer-chrome">
          <div class="asset-viewer-header">
            <span id="asset-viewer-title" class="asset-viewer-title"></span>
            <span id="asset-viewer-meta" class="asset-viewer-meta hidden"></span>
          </div>
          <div class="asset-viewer-actions">
            <button id="asset-viewer-download" type="button" class="text-button"></button>
            <button id="asset-viewer-close" type="button" class="text-button"></button>
          </div>
        </div>
        <div class="asset-viewer-body">
          <div id="asset-viewer-status" class="asset-viewer-status hidden"></div>
          <div id="asset-viewer-content" class="asset-viewer-content" role="document"></div>
        </div>
      </div>
    </div>
    <div id="dialog-pending" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="dialog-pending-backdrop" class="dialog-backdrop"></div>
      <div
        id="dialog-pending-window"
        class="dialog-window dialog-pending-window"
        role="status"
        aria-live="polite"
      >
        <div class="dialog-pending-content">
          <div class="dialog-pending-spinner" aria-hidden="true"></div>
          <p id="dialog-pending-message" class="dialog-pending-message"></p>
        </div>
      </div>
    </div>
    <div id="upload-dialog" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="upload-dialog-backdrop" class="dialog-backdrop"></div>
      <div
        id="upload-dialog-window"
        class="dialog-window upload-dialog-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="upload-dialog-title"
        aria-describedby="upload-dialog-description"
      >
        <div class="dialog-header">
          <h2 id="upload-dialog-title" class="dialog-title"></h2>
        </div>
        <p id="upload-dialog-description" class="dialog-message"></p>
        <input id="upload-dialog-input" class="sr-only" type="file" />
        <label
          id="upload-dropzone"
          class="upload-dropzone"
          tabindex="0"
          role="button"
          aria-describedby="upload-dropzone-help"
          for="upload-dialog-input"
        >
          <strong id="upload-dropzone-prompt"></strong>
          <p id="upload-dropzone-help"></p>
          <span
            id="upload-browse-button"
            class="dialog-button secondary"
            role="button"
            tabindex="0"
          ></span>
        </label>
        <div id="upload-file-info" class="upload-file-info hidden">
          <div class="upload-file-summary">
            <div id="upload-file-name" class="upload-file-name"></div>
            <div id="upload-file-size" class="upload-progress-text"></div>
          </div>
          <ul id="upload-file-list" class="upload-file-list hidden" aria-live="polite"></ul>
          <div class="upload-file-actions">
            <button id="upload-clear" type="button" class="dialog-button secondary"></button>
          </div>
        </div>
        <div id="upload-progress-container" class="hidden">
          <div
            id="upload-progress"
            class="upload-progress"
            role="progressbar"
            aria-valuemin="0"
            aria-valuemax="100"
            aria-valuenow="0"
          >
            <div id="upload-progress-fill" class="upload-progress-fill"></div>
          </div>
          <div id="upload-progress-text" class="upload-progress-text"></div>
        </div>
        <div id="upload-status-message" class="upload-status-message"></div>
        <div class="dialog-actions">
          <button type="button" id="upload-cancel" class="dialog-button secondary"></button>
          <button type="button" id="upload-confirm" class="dialog-button primary"></button>
        </div>
      </div>
    </div>
    <div id="bulk-upload-dialog" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="bulk-upload-backdrop" class="dialog-backdrop"></div>
      <div
        id="bulk-upload-window"
        class="dialog-window bulk-upload-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="bulk-upload-title"
        aria-describedby="bulk-upload-subtitle"
      >
        <div class="dialog-header">
          <h2 id="bulk-upload-title" class="dialog-title"></h2>
          <p id="bulk-upload-subtitle" class="dialog-message"></p>
        </div>
        <div class="bulk-upload-file">
          <div id="bulk-upload-file-name" class="bulk-upload-file-name"></div>
          <div id="bulk-upload-file-size" class="bulk-upload-file-size"></div>
        </div>
        <label class="bulk-upload-field" for="bulk-upload-lecture">
          <span id="bulk-upload-lecture-label"></span>
          <select id="bulk-upload-lecture"></select>
        </label>
        <label class="bulk-upload-field" for="bulk-upload-type">
          <span id="bulk-upload-type-label"></span>
          <select id="bulk-upload-type"></select>
        </label>
        <div id="bulk-upload-status" class="bulk-upload-status" role="status"></div>
        <div class="bulk-upload-actions">
          <div class="bulk-upload-actions-group">
            <button id="bulk-upload-dispose" type="button" class="dialog-button secondary"></button>
            <button id="bulk-upload-dispose-all" type="button" class="dialog-button danger"></button>
          </div>
          <div class="bulk-upload-actions-group">
            <button id="bulk-upload-cancel" type="button" class="dialog-button secondary"></button>
            <button id="bulk-upload-next" type="button" class="dialog-button primary"></button>
          </div>
        </div>
      </div>
    </div>
    <div id="bulk-process-dialog" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="bulk-process-backdrop" class="dialog-backdrop"></div>
      <div
        id="bulk-process-window"
        class="dialog-window bulk-process-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="bulk-process-title"
        aria-describedby="bulk-process-subtitle"
      >
        <div class="dialog-header bulk-process-header">
          <div class="bulk-process-heading">
            <h2
              id="bulk-process-title"
              class="dialog-title"
              data-i18n="tasks.bulkProcess.title"
            ></h2>
            <p
              id="bulk-process-subtitle"
              class="dialog-message"
              data-i18n="tasks.bulkProcess.subtitle"
            ></p>
          </div>
          <div class="bulk-process-toolbar">
            <button
              id="bulk-process-select-all"
              type="button"
              class="dialog-button secondary"
              data-i18n="tasks.bulkProcess.selectAll"
            ></button>
            <button
              id="bulk-process-clear"
              type="button"
              class="dialog-button secondary"
              data-i18n="tasks.bulkProcess.clear"
            ></button>
          </div>
        </div>
        <div id="bulk-process-content" class="bulk-process-content"></div>
        <p
          id="bulk-process-empty"
          class="bulk-process-empty hidden"
          data-i18n="tasks.bulkProcess.empty"
        ></p>
        <div
          id="bulk-process-status"
          class="bulk-process-status-message"
          role="status"
          aria-live="polite"
        ></div>
        <div id="bulk-process-summary" class="bulk-process-summary"></div>
        <div class="dialog-actions">
          <button
            id="bulk-process-cancel"
            type="button"
            class="dialog-button secondary"
            data-i18n="tasks.bulkProcess.cancel"
          ></button>
          <button
            id="bulk-process-submit"
            type="button"
            class="dialog-button primary"
            data-i18n="tasks.bulkProcess.submit"
            disabled
          ></button>
        </div>
      </div>
    </div>
    <div id="bulk-download-dialog" class="dialog hidden" aria-hidden="true" tabindex="-1">
      <div id="bulk-download-backdrop" class="dialog-backdrop"></div>
      <div
        id="bulk-download-window"
        class="dialog-window bulk-process-window"
        role="dialog"
        aria-modal="true"
        aria-labelledby="bulk-download-title"
        aria-describedby="bulk-download-subtitle"
      >
        <div class="dialog-header bulk-process-header">
          <div class="bulk-process-heading">
            <h2 id="bulk-download-title" class="dialog-title" data-i18n="tasks.bulkDownload.title">
              Bulk download assets
            </h2>
            <p id="bulk-download-subtitle" class="dialog-message" data-i18n="tasks.bulkDownload.subtitle">
              Select lectures and asset formats to download.
            </p>
          </div>
          <div class="bulk-process-toolbar">
            <button id="bulk-download-select-all" type="button" class="dialog-button" data-i18n="tasks.bulkDownload.selectAll">
              Select all
            </button>
            <button id="bulk-download-clear" type="button" class="dialog-button" data-i18n="tasks.bulkDownload.clear">
              Clear selections
            </button>
          </div>
        </div>
        <div id="bulk-download-content" class="bulk-process-content"></div>
        <div id="bulk-download-empty" class="bulk-process-empty hidden" data-i18n="tasks.bulkDownload.empty">
          No assets available.
        </div>
        <div id="bulk-download-status" class="bulk-process-status-message" role="status"></div>
        <div id="bulk-download-summary" class="bulk-process-summary"></div>
        <div class="dialog-actions">
          <button id="bulk-download-cancel" type="button" class="dialog-button" data-i18n="tasks.bulkDownload.cancel">
            Cancel
          </button>
          <button id="bulk-download-submit" type="button" class="dialog-button primary" data-i18n="tasks.bulkDownload.submit">
            Prepare download
          </button>
        </div>
      </div>
    </div>
    <script>
      (async function () {
        const translations = {
          en: {
            document: {
              title: 'Lecture Tools',
            },
            sidebar: {
              heading: 'Lecture Tools',
              tagline: 'Review, organise, and process lecture resources quickly.',
              overview: 'Overview',
              syllabusTitle: 'Course syllabus',
              searchLabel: 'Search the syllabus',
              searchPlaceholder: 'Search by name',
              loading: 'Loading',
              miniConsoleTitle: 'Mini console',
              miniConsoleEmpty: 'No recent activity.',
            },
            topBar: {
              details: 'Details',
              enableEdit: 'Edit syllabus',
              exitEdit: 'Save syllabus',
              tasks: 'Tasks',
              create: 'Create',
              storage: 'Storage',
              settings: 'Settings',
            },
            details: {
              title: 'Lecture details',
              deleteLecture: 'Delete lecture',
              editModeBanner:
                'Edit mode is enabled. Update lecture information or remove items while it is active.',
              summaryPlaceholder: 'Select a lecture from the curriculum.',
              edit: {
                titleLabel: 'Title',
                moduleLabel: 'Module',
                descriptionLabel: 'Description',
                save: 'Save changes',
              },
              noDescription: 'No description recorded yet.',
            },
            assets: {
              title: 'Assets',
              transcribe: 'Transcribe audio',
              modelLabel: 'Model',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU (hardware accelerated)',
              },
              labels: {
                audio: 'Audio (.wav, .mp3, .mp4, .m4a, .aac, .flac, .ogg, .opus)',
                masteredAudio: 'Mastered audio',
                slides: 'Slides (PDF or document)',
                transcript: 'Transcript',
                notes: 'Notes',
                slideBundle: 'Slide bundle (Markdown + ZIP)',
              },
              status: {
                notLinked: 'Not linked',
                slidesHint: 'Upload a PDF to generate the Markdown bundle. Other document formats are stored as-is.',
                noSlideImages: 'No slide bundle yet. Upload a PDF and use Process slides to generate one.',
                linked: 'Linked: {{name}}',
                slidesUploaded: 'Slides uploaded: {{name}}',
                slidesStoredOnly: 'Stored as a document. Processing is available for PDFs.',
                archiveCreated: 'Bundle created: {{name}}',
                mastered: 'Mastered: {{name}}',
                audioPending: 'Uploaded {{count}} audio file(s) pending combination.',
                slidesPending: 'Uploaded {{count}} slide file(s) pending combination.',
              },
              actions: {
                upload: 'Upload',
                processSlides: 'Process slides',
                view: 'View',
                download: 'Download',
                remove: 'Remove',
              },
            },
            tasks: {
              title: 'Tasks',
              description: 'Queue transcription and slide processing jobs to run in order.',
              empty: 'No tasks in the queue.',
              refresh: 'Refresh',
              clearDone: 'Clear done',
              sections: {
                current: 'Current',
                queued: 'Queued',
                done: 'Done',
                empty: 'No tasks in this section.',
              },
              actions: {
                open: 'Open lecture',
                retry: 'Retry',
                dismiss: 'Dismiss',
              },
              bulkProcess: {
                button: 'Bulk process',
                title: 'Bulk process lectures',
                subtitle: 'Select lectures and assets to add to the processing queue.',
                selectAll: 'Select all',
                clear: 'Clear selections',
                empty: 'No lectures available for processing.',
                cancel: 'Cancel',
                submit: 'Queue tasks',
                summaryEmpty: 'No tasks selected.',
                summarySelected: '{{count}} {{taskWord}} selected.',
                summaryBreakdown:
                  'Merge slide PDFs: {{merge}}  Transcribe audio: {{transcription}}  Process slides: {{slides}}.',
                status: {
                  unavailable: 'Upload required',
                  empty: 'Not selected',
                  completed: 'Already processed',
                  selected: 'Queued for processing',
                },
              },
              bulkUpload: {
                button: 'Bulk upload',
                title: 'Bulk upload',
                fileProgress: 'File {{current}} of {{total}}',
                lectureLabel: 'Lecture',
                typeLabel: 'File type',
                selectLecture: 'Select a lecture',
                selectType: 'Select file type',
                next: 'Upload & next',
                complete: 'Upload & complete',
                skip: 'Dispose',
                skipAll: 'Dispose all',
                cancel: 'Cancel',
                uploading: 'Uploading {{name}}',
                success: 'Uploaded {{name}}.',
                failure: 'Failed to upload {{name}}.',
                disposed: 'Skipped {{name}}.',
                finished: 'Bulk upload complete: {{uploaded}} uploaded, {{skipped}} skipped.',
                noLectures: 'Add a lecture before starting a bulk upload.',
                noTypes: 'No uploadable asset types are available.',
              },
              bulkDownload: {
                button: 'Bulk download',
                title: 'Bulk download assets',
                subtitle: 'Select lectures and asset formats to download.',
                selectAll: 'Select all',
                clear: 'Clear selections',
                empty: 'No downloadable assets available.',
                cancel: 'Cancel',
                submit: 'Prepare download',
                summaryEmpty: 'No assets selected.',
                summarySelected: '{{count}} {{assetWord}} selected.',
                summaryBreakdown:
                  'Audio: {{audio}}  Transcript (TXT): {{txt}}  Slides (PDF): {{pdf}}  Notes (MD): {{md}}  Bundles (ZIP): {{zip}}.',
                assetSingular: 'asset',
                assetPlural: 'assets',
                status: {
                  available: 'Available',
                  selected: 'Selected',
                  unavailable: 'Missing',
                },
                assets: {
                  audio: 'Audio',
                  txt: 'Transcript (TXT)',
                  pdf: 'Slides (PDF)',
                  md: 'Notes (MD)',
                  zip: 'Slide bundle (ZIP)',
                },
                preparing: 'Preparing archive',
                ready: 'Archive ready: {{filename}}.',
                failure: 'Unable to prepare download.',
                noneSelected: 'Select at least one asset to continue.',
              },
              status: {
                pending: 'Pending',
                running: 'In progress',
                finished: 'Completed',
                failed: 'Failed',
              },
              labels: {
                transcription: 'Transcription',
                slideBundle: 'Slide bundle generation',
                slideMerge: 'Slide PDF merge',
                generic: 'Task',
                untitled: 'Untitled lecture',
              },
              messages: {
                pending: 'Waiting for available resources',
                completed: 'Completed successfully.',
              },
              retryUnavailable: 'Retry is not available for this task.',
              form: {
                lectureLabel: 'Lecture',
                placeholder: 'Select a lecture',
                operationLabel: 'Action',
                operation: {
                  transcription: 'Transcribe audio',
                  slideBundle: 'Process slides',
                  slideMerge: 'Merge uploaded PDFs',
                },
                pageStartLabel: 'Start page',
                pageEndLabel: 'End page',
                submit: 'Add task',
              },
              notifications: {
                queued: 'Task added to the queue.',
                cleared: 'Cleared {{count}} completed tasks.',
              },
            },
            create: {
              title: 'Create lecture',
              moduleLabel: 'Module',
              titleLabel: 'Title',
              descriptionLabel: 'Description',
              submit: 'Add lecture',
            },
            settings: {
              title: 'Settings',
              appearance: {
                legend: 'Appearance',
                displayModeLabel: 'Display mode',
                displayMode: {
                  system: 'Follow system',
                  bright: 'Bright',
                  dark: 'Dark',
                },
                themeLabel: 'Theme palette',
                theme: {
                  vibrant: 'Vibrant',
                  serene: 'Serene',
                  noir: 'Noir',
                  solar: 'Solar',
                  cyber: 'Cyber',
                  pastel: 'Pastel',
                  obsidian: 'Obsidian',
                  ethereal: 'Ethereal',
                },
                effectsLabel: 'Visual effects',
                effects: {
                  none: 'None',
                  low: 'Low',
                  mid: 'Medium',
                  high: 'High',
                },
              },
              language: {
                label: 'Language',
                choices: {
                  en: 'English',
                  zh: ' (Chinese)',
                  es: 'Espaol (Spanish)',
                  fr: 'Franais (French)',
                },
              },
              debug: {
                legend: 'Debugging',
                enable: 'Enable debug mode',
                description:
                  'Show a live console on the right that streams detailed program output.',
              },
              whisper: {
                legend: 'Whisper transcription',
                modelLabel: 'Default model',
                model: {
                  tiny: 'Tiny (fastest)',
                  base: 'Base (balanced)',
                  small: 'Small (accurate)',
                  medium: 'Medium (detailed)',
                  large: 'Large (maximum accuracy)',
                  gpu: 'GPU (hardware accelerated)',
                },
                computeLabel: 'Compute type',
                beamLabel: 'Beam size',
                gpu: {
                  label: 'GPU support',
                  status: 'GPU acceleration not tested.',
                  test: 'Test support',
                  retry: 'Re-run test',
                },
              },
              cloudConnection: {
                legend: 'Cloud connection',
                enable: 'Connect to cloud server',
                urlLabel: 'Cloud server URL',
                autoConnect: 'Always auto-connect on launch',
                processingLabel: 'Process tasks',
                processing: {
                  cloud: 'In the cloud',
                  local: 'On this machine',
                },
                statusLabel: 'Connection status',
                status: {
                  idle: 'Not tested.',
                  connected: 'Connected.',
                  disconnected: 'Disconnected.',
                  disabled: 'Disabled.',
                },
                test: 'Test connection',
                description:
                  'Connect your local UI to a cloud server. Cloud mode streams structures and assets from the server and only pulls files when needed. When you disconnect or restart, cloud files are cleared locally.',
                cancelReason: 'Cloud connection session ended.',
                notifications: {
                  connected: 'Cloud connection established.',
                },
                errors: {
                  unavailable: 'Cloud server is unavailable.',
                  disconnected: 'Cloud connection is enabled but the server is unavailable.',
                },
              },
              audio: {
                legend: 'Audio',
                masteringLabel: 'Enable mastered audio',
                masteringDescription: 'Automatically enhance uploaded audio for clarity.',
              },
              slides: {
                legend: 'Slides',
                dpiLabel: 'Rendering DPI',
                forceOcrLabel: 'Force OCR even when text is detected',
                forceOcrDescription: 'Always run OCR on slide PDFs, even if a text layer is present.',
                dpi: {
                  150: '150 dpi (fastest)',
                  200: '200 dpi (balanced)',
                  300: '300 dpi (detailed)',
                  400: '400 dpi (high detail)',
                  600: '600 dpi (maximum)',
                },
              },
              update: {
                legend: 'System updates',
                description: 'Update Lecture Tools without leaving the browser.',
                passwordLabel: 'Sudo password',
                passwordHelp:
                  'Passwords are hidden after saving. Enter a new password to replace the saved one.',
                passwordSaved: 'Password saved.',
                passwordClear: 'Clear saved password',
                run: 'Run update',
                refresh: 'Refresh status',
                status: {
                  idle: 'No update in progress.',
                  running: 'Update running. Keep this window open until it completes.',
                  success: 'The most recent update completed successfully.',
                  failure: 'The most recent update encountered an error.',
                },
                startedAt: 'Started {{time}}.',
                finishedAt: 'Finished {{time}}.',
                exitCode: 'Exit code {{code}}.',
                logLabel: 'Activity log',
                logEmpty: 'No update activity yet.',
              },
              archive: {
                legend: 'Archive',
                description:
                  'Export your lectures and assets or import an archive from another machine.',
                export: 'Export archive',
                import: 'Import archive',
                modeLabel: 'Import mode',
                modes: {
                  merge: 'Import and add to existing content',
                  replace: 'Clear existing content and overwrite',
                },
                hint: 'Exported archives are stored temporarily and cleared when the app starts.',
              },
              save: 'Save settings',
              exit: 'Exit application',
            },
            storage: {
              title: 'Storage manager',
              subtitle: 'Review stored assets by class hierarchy.',
              loading: 'Loading',
              empty: 'No stored classes found.',
              usage: {
                used: 'Used',
                available: 'Available',
                total: 'Total',
                library: 'Library size',
              },
              actions: {
                refresh: 'Refresh',
                repair: 'Repair storage',
                downloadSelected: 'Download selected',
                purge: 'Remove processed audio',
              },
              browser: {
                root: 'Root',
                up: 'Up',
                loading: 'Loading',
                empty: 'No files or folders found.',
                select: 'Select',
                name: 'Name',
                type: 'Type',
                size: 'Size',
                modified: 'Modified',
                actions: 'Actions',
                directory: 'Folder',
                file: 'File',
                unnamed: 'Unnamed item',
                selectAction: 'Select {{name}}',
              },
              purge: {
                none: 'No processed audio to remove.',
                available: '{{count}} {{lectureWord}} ready for cleanup.',
                working: 'Removing audio',
                readyCount: '{{count}} {{lectureWord}} ready for cleanup',
              },
              repair: {
                working: 'Repairing',
                summary: 'Removed {{count}} {{itemWord}}  Freed {{freed}}',
                none: 'No storage repairs have been run yet.',
                noChange: 'No space reclaimed',
              },
              reveal: {
                unavailable: 'Unable to locate this item in storage.',
              },
              classes: {
                summary: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
                empty: 'No modules stored for this class yet.',
                masteredCount: '{{count}} {{lectureWord}} with mastered audio',
              },
              modules: {
                summary: '{{lectureCount}} {{lectureWord}}',
                empty: 'No lectures stored for this module yet.',
                masteredCount: '{{count}} {{lectureWord}} with mastered audio',
              },
              lecture: {
                audio: 'Audio',
                processedAudio: 'Mastered audio',
                transcript: 'Transcript',
                notes: 'Notes',
                slides: 'Slides',
                empty: 'No linked assets.',
                eligible: 'Audio ready for removal',
                processedBadge: 'Mastered audio',
              },
              dialogs: {
                purgeTitle: 'Remove processed audio',
                purgeMessage:
                  'Delete audio files for {{count}} {{lectureWord}} that already have transcripts? This cannot be undone.',
                deleteTitle: 'Delete storage item',
                deleteMessage: 'Delete {{name}} from storage? This cannot be undone.',
                deleteConfirm: 'Delete',
              },
              unnamedClass: 'Untitled class',
              unnamedModule: 'Untitled module',
              unnamedLecture: 'Untitled lecture',
            },
            debug: {
              title: 'Debug console',
              live: 'Live',
              empty: 'Enable debug mode to inspect program activity in real time.',
              error: 'Unable to load debug output.',
              stream: {
                title: 'Server activity',
                empty: 'Waiting for server activity',
              },
            },
            dialog: {
              cancel: 'Cancel',
              confirm: 'Confirm',
            },
            stats: {
              classes: 'Classes',
              modules: 'Modules',
              lectures: 'Lectures',
              transcripts: 'Transcripts',
              slideDecks: 'Slide decks',
              audio: 'Audio files',
              processedAudio: 'Mastered audio',
              notes: 'Notes',
              slideArchives: 'Slide bundles',
            },
            dialogs: {
              createClass: {
                title: 'Create class',
                message: 'Enter a class name.',
                placeholder: 'Introduction to Astronomy',
              },
              createModule: {
                title: 'Create module',
                message: 'Module name for {{className}}',
                placeholder: 'Foundations',
              },
              createLecture: {
                title: 'Create lecture',
                message: 'Lecture title for {{context}}',
                placeholder: 'Lecture title',
              },
              lectureDescription: {
                title: 'Lecture description',
                placeholder: 'Add a short outline',
              },
              deleteClass: {
                title: 'Delete class',
                message: 'Delete class "{{className}}"?',
                cancel: 'Keep class',
                summary: 'This will remove {{moduleCount}} {{moduleWord}} and {{lectureCount}} {{lectureWord}}.',
              },
              deleteModule: {
                title: 'Delete module',
                message: 'Delete module "{{moduleName}}"{{classContext}}?',
                cancel: 'Keep module',
                summary: 'This will remove {{lectureCount}} {{lectureWord}}.',
                classContext: ' from "{{className}}"',
              },
              deleteLecture: {
                title: 'Delete lecture',
                message: 'Delete lecture "{{context}}" and all linked assets?',
                cancel: 'Keep lecture',
              },
              removeAsset: {
                title: 'Remove {{asset}}',
                message: 'Remove the current {{asset}} from this lecture? This cannot be undone.',
                confirm: 'Remove asset',
              },
              confirmDeletion: {
                title: 'Confirm deletion',
                message: 'This action cannot be undone. Do you want to permanently remove it?',
                confirm: 'Yes, delete it',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: 'Exit application',
                message: 'Stop the Lecture Tools server and close this tab?',
              },
              slideRange: {
                title: 'Select pages to process',
                description:
                  'Review the slide thumbnails and choose which pages to convert into images.',
                loading: 'Loading preview',
                error:
                  'Slide previews are shown below. Adjust the range manually if needed.',
                startLabel: 'Start page',
                endLabel: 'End page',
                rangeHint: 'Use the inputs or page previews to adjust the selection.',
                zoomLabel: 'Preview zoom',
                zoomValue: '{{value}}% view',
                fallbackMessage:
                  'Open the PDF below in a new tab if you need to inspect it directly.',
                fallbackLink: 'Open PDF in new tab',
                fallbackFrameTitle: 'Fallback PDF preview',
                summary: 'Processing pages {{start}}{{end}} of {{total}}.',
                summarySingle: 'Processing page {{start}} of {{total}}.',
                summaryUnknown: 'Processing pages {{start}}{{end}}.',
                summarySingleUnknown: 'Processing page {{start}}.',
                allPages: 'Processing all pages in the document.',
                pageLabel: 'Page {{page}}',
                selectAll: 'Select all',
                confirm: 'Confirm & Continue',
              },
              upload: {
                title: 'Upload file',
                description: 'Drag a file here or browse to select one from your computer.',
                prompt: 'Drag and drop a file',
                help: 'You can also click to choose a file.',
                browse: 'Select file',
                clear: 'Remove',
                waiting: 'Select a file to continue.',
                preparing: 'Preparing file',
                uploading: 'Uploading',
                processing: 'Processing upload',
                processingAction: 'Processing',
                processingAudio: 'Processing audio',
                processingSlides: 'Processing slides',
                backgroundProcessing:
                  'Audio mastering will continue in the background. You can close this dialog while it finishes.',
                backgroundProcessingSlides:
                  'Slide conversion will continue in the background. You can close this dialog while it finishes.',
                success: 'Upload completed.',
                failure: 'Upload failed. Please try again.',
                progress: 'Upload progress',
                fileProgress: 'File {{current}} of {{total}}',
                filesSelected: '{{count}} files selected',
                filesSummary: '{{count}} files  {{size}} total',
                listHelp: 'Drag to reorder files before uploading.',
                uploadingFile: 'Uploading {{name}} ({{current}} of {{total}})',
                action: 'Upload',
                assetTitle: 'Upload {{asset}}',
                assetDescription: 'Choose a new file to attach to this resource.',
                archiveTitle: 'Import archive',
                archiveDescription: 'Select a Lecture Tools export (.zip) to import.',
              },
              descriptionOptional: 'Description (optional)',
              descriptionPlaceholder: 'Add a short summary',
            },
            dropdowns: {
              selectModule: 'Select module',
              noModules: 'No modules available',
            },
            placeholders: {
              noLectures: 'No lectures',
              noLecturesFilter: 'No lectures match the current filter.',
              noClasses: 'No classes available yet.',
              noModules: 'No modules yet.',
            },
            curriculum: {
              addClass: 'Add class',
              addModule: 'Add module',
              manageHeading: 'Manage syllabus',
              classMeta: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
              moduleMeta: '{{lectureCount}} {{lectureWord}}',
              editorHeading: 'Edit syllabus structure',
              editorHint:
                'Each line represents a class, module, or lecture. Use - for modules and -- for lectures. Include IDs in square brackets to keep existing items.',
              editorLineError: 'Line {{line}}: {{message}}',
              editorErrors: {
                missingClass: 'Modules must appear after a class.',
                missingModule: 'Lectures must appear after a module.',
                unknownClass: 'Class ID {{id}} was not found.',
                unknownModule: 'Module ID {{id}} was not found.',
                unknownLecture: 'Lecture ID {{id}} was not found.',
                duplicateClass: 'Class ID {{id}} appears more than once.',
                duplicateModule: 'Module ID {{id}} appears more than once.',
                duplicateLecture: 'Lecture ID {{id}} appears more than once.',
                nameRequired: 'A name is required.',
              },
            },
            common: {
              actions: {
                create: 'Create',
                save: 'Save',
                skip: 'Skip',
                delete: 'Delete',
                open: 'Open',
                upload: 'Upload',
                exit: 'Exit',
                close: 'Close',
                ok: 'OK',
                reveal: 'Reveal',
              },
            },
            viewer: {
              loading: 'Loading',
              failed: 'Unable to load file.',
              unsupported: 'This file type cannot be viewed inline.',
              types: {
                pdf: 'PDF',
                text: 'Plain text',
                markdown: 'Markdown',
              },
            },
            status: {
              requireEdit: 'Enable edit mode to manage the curriculum.',
              requireEditLecture: 'Enable edit mode to update lecture details.',
              curriculumSaved: 'Syllabus updated.',
              curriculumSaveFailed: 'Unable to update the syllabus.',
              curriculumLoadFailed: 'Unable to load the syllabus.',
              classCreated: 'Class created.',
              classRemoved: 'Class removed.',
              moduleCreated: 'Module created.',
              moduleRemoved: 'Module removed.',
              lectureCreated: 'Lecture created.',
              lectureRemoved: 'Lecture removed.',
              lectureUpdated: 'Lecture updated.',
              lectureTitleRequired: 'Lecture title is required.',
              createLectureRequirements: 'Select a module and enter a title.',
              slidesProcessed: 'Slides processed into a Markdown bundle with images.',
              slidesUploaded: 'Slides uploaded. PDFs can be processed into a Markdown bundle.',
              slidesUploadRequired: 'Upload a PDF before processing slides. Other document formats are stored as-is.',
              slidePreviewFailed: 'Unable to prepare the slide preview. Ensure the file is a PDF and try again.',
              processingSlides: 'Processing slides',
              audioProcessingQueued: 'Audio uploaded. Mastering will continue in the background.',
              assetUploaded: 'Asset uploaded successfully.',
              assetRemoved: 'Asset removed.',
              transcriptionPreparing: '====> Preparing transcription',
              transcriptionCompleted: 'Transcription completed.',
              processing: 'Processing',
              storageLoadFailed: 'Unable to load storage contents.',
              storageUsageFailed: 'Unable to load storage usage.',
              storagePurged: 'Removed processed audio files.',
              storagePurgeFailed: 'Unable to remove processed audio files.',
              storageDeleted: 'Storage item deleted.',
              storageDeleteFailed: 'Unable to delete storage item.',
              storageDownloadReady: 'Download ready.',
              storageDownloadFailed: 'Unable to prepare download.',
              storageDownloadNone: 'Select at least one item to download.',
              storageRepairing: 'Scanning storage for temporary files',
              storageRepairComplete:
                'Storage repair removed {{count}} {{itemWord}} and freed {{freed}}.',
              storageRepairNoChanges: 'Storage repair completed. No temporary items found.',
              storageRepairFailed: 'Unable to repair storage.',
              gpuChecking: '====> Checking GPU Whisper support',
              gpuConfirmed: 'GPU Whisper support confirmed.',
              gpuUnavailable: 'GPU acceleration is unavailable on this platform.',
              gpuUnsupported: 'GPU Whisper is not supported on this platform.',
              gpuNotAvailable: 'GPU acceleration is not available on this platform.',
              updateStarted: 'Update started.',
              updateRunning: 'Update in progress. Keep this window open.',
              updateCompleted: 'Update completed successfully.',
              updateFailed: 'Update failed. Review the log for details.',
              updateConflict: 'An update is already running.',
              shuttingDown: 'Shutting down application',
              settingsSaved: 'Settings saved.',
              gpuFallback: 'Falling back to {{model}} model.',
              lectureReordered: 'Lecture order updated.',
              exporting: 'Preparing archive',
              exportReady: 'Archive ready to download.',
              exportFailed: 'Unable to create archive.',
              importing: 'Importing archive',
              importSuccess: 'Imported {{count}} lectures.',
              importNoChanges: 'Archive imported (no new lectures).',
            },
              counts: {
                module: { one: 'module', other: 'modules' },
                lecture: { one: 'lecture', other: 'lectures' },
                task: { one: 'task', other: 'tasks' },
                item: { one: 'item', other: 'items' },
              },
          },
          zh: {
            document: {
              title: '',
            },
            sidebar: {
              heading: '',
              tagline: '',
              overview: '',
              syllabusTitle: '',
              searchLabel: '',
              searchPlaceholder: '',
              loading: '',
              miniConsoleTitle: '',
              miniConsoleEmpty: '',
            },
            topBar: {
              details: '',
              enableEdit: '',
              exitEdit: '',
              tasks: '',
              create: '',
              storage: '',
              settings: '',
            },
            details: {
              title: '',
              deleteLecture: '',
              editModeBanner: '',
              summaryPlaceholder: '',
              edit: {
                titleLabel: '',
                moduleLabel: '',
                descriptionLabel: '',
                save: '',
              },
              noDescription: '',
            },
            assets: {
              title: '',
              transcribe: '',
              modelLabel: '',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU',
              },
              labels: {
                audio: '.wav.mp3.mp4.m4a.aac.flac.ogg.opus',
                masteredAudio: '',
                slides: 'PDF ',
                transcript: '',
                notes: '',
                slideBundle: 'Markdown + ZIP',
              },
              status: {
                notLinked: '',
                slidesHint: ' PDF  Markdown ',
                noSlideImages: ' PDF ',
                linked: '{{name}}',
                slidesUploaded: '{{name}}',
                slidesStoredOnly: ' PDF',
                archiveCreated: '{{name}}',
                mastered: '{{name}}',
                audioPending: ' {{count}} ',
                slidesPending: ' {{count}} ',
              },
              actions: {
                upload: '',
                processSlides: '',
                view: '',
                download: '',
                remove: '',
              },
            },
            tasks: {
              title: '',
              description: '',
              empty: '',
              refresh: '',
              clearDone: '',
              sections: {
                current: '',
                queued: '',
                done: '',
                empty: '',
              },
              actions: {
                open: '',
                retry: '',
                dismiss: '',
              },
              bulkProcess: {
                button: '',
                title: '',
                subtitle: '',
                selectAll: '',
                clear: '',
                empty: '',
                cancel: '',
                submit: '',
                summaryEmpty: '',
                summarySelected: ' {{count}} {{taskWord}}',
                summaryBreakdown: ' PDF{{merge}}  {{transcription}}  {{slides}}',
                status: {
                  unavailable: '',
                  empty: '',
                  completed: '',
                  selected: '',
                },
              },
              bulkUpload: {
                button: '',
                title: '',
                fileProgress: ' {{current}}  {{total}} ',
                lectureLabel: '',
                typeLabel: '',
                selectLecture: '',
                selectType: '',
                next: '',
                complete: '',
                skip: '',
                skipAll: '',
                cancel: '',
                uploading: ' {{name}}',
                success: ' {{name}}',
                failure: ' {{name}} ',
                disposed: ' {{name}}',
                finished: ' {{uploaded}}  {{skipped}} ',
                noLectures: '',
                noTypes: '',
              },
              bulkDownload: {
                button: '',
                title: '',
                subtitle: '',
                selectAll: '',
                clear: '',
                empty: '',
                cancel: '',
                submit: '',
                summaryEmpty: '',
                summarySelected: ' {{count}} {{assetWord}}',
                summaryBreakdown: '{{audio}}   (TXT){{txt}}   (PDF){{pdf}}   (MD){{md}}   (ZIP){{zip}}',
                assetSingular: '',
                assetPlural: '',
                status: {
                  available: '',
                  selected: '',
                  unavailable: '',
                },
                assets: {
                  audio: '',
                  txt: ' (TXT)',
                  pdf: ' (PDF)',
                  md: ' (MD)',
                  zip: ' (ZIP)',
                },
                preparing: '',
                ready: '{{filename}}',
                failure: '',
                noneSelected: '',
              },
              status: {
                pending: '',
                running: '',
                finished: '',
                failed: '',
              },
              labels: {
                transcription: '',
                slideBundle: '',
                slideMerge: ' PDF ',
                generic: '',
                untitled: '',
              },
              messages: {
                pending: '',
                completed: '',
              },
              retryUnavailable: '',
              form: {
                lectureLabel: '',
                placeholder: '',
                operationLabel: '',
                operation: {
                  transcription: '',
                  slideBundle: '',
                  slideMerge: ' PDF',
                },
                pageStartLabel: '',
                pageEndLabel: '',
                submit: '',
              },
              notifications: {
                queued: '',
                cleared: ' {{count}} ',
              },
            },
            create: {
              title: '',
              moduleLabel: '',
              titleLabel: '',
              descriptionLabel: '',
              submit: '',
            },
            settings: {
              title: '',
              appearance: {
                legend: '',
                displayModeLabel: '',
                displayMode: {
                  system: '',
                  bright: '',
                  dark: '',
                },
                themeLabel: '',
                theme: {
                  vibrant: '',
                  serene: '',
                  noir: '',
                  solar: '',
                  cyber: '',
                  pastel: '',
                  obsidian: '',
                  ethereal: '',
                },
                effectsLabel: '',
                effects: {
                  none: '',
                  low: '',
                  mid: '',
                  high: '',
                },
              },
              language: {
                label: '',
                choices: {
                  en: 'English',
                  zh: '',
                  es: 'Espaol',
                  fr: 'Franais',
                },
              },
              debug: {
                legend: '',
                enable: '',
                description: '',
              },
              whisper: {
                legend: 'Whisper ',
                modelLabel: '',
                model: {
                  tiny: 'Tiny',
                  base: 'Base',
                  small: 'Small',
                  medium: 'Medium',
                  large: 'Large',
                  gpu: 'GPU',
                },
                computeLabel: '',
                beamLabel: '',
                gpu: {
                  label: 'GPU ',
                  status: ' GPU ',
                  test: '',
                  retry: '',
                },
              },
              cloudConnection: {
                legend: '',
                enable: '',
                urlLabel: '',
                autoConnect: '',
                processingLabel: '',
                processing: {
                  cloud: '',
                  local: '',
                },
                statusLabel: '',
                status: {
                  idle: '',
                  connected: '',
                  disconnected: '',
                  disabled: '',
                },
                test: '',
                description:
                  '',
                cancelReason: '',
                notifications: {
                  connected: '',
                },
                errors: {
                  unavailable: '',
                  disconnected: '',
                },
              },
              audio: {
                legend: '',
                masteringLabel: '',
                masteringDescription: '',
              },
              slides: {
                legend: '',
                dpiLabel: ' DPI',
                forceOcrLabel: ' OCR',
                forceOcrDescription: ' PDF  OCR',
                dpi: {
                  150: '150 dpi',
                  200: '200 dpi',
                  300: '300 dpi',
                  400: '400 dpi',
                  600: '600 dpi',
                },
              },
              update: {
                legend: '',
                description: ' Lecture Tools',
                passwordLabel: 'Sudo ',
                passwordHelp: '',
                passwordSaved: '',
                passwordClear: '',
                run: '',
                refresh: '',
                status: {
                  idle: '',
                  running: '',
                  success: '',
                  failure: '',
                },
                startedAt: ' {{time}}',
                finishedAt: ' {{time}}',
                exitCode: ' {{code}}',
                logLabel: '',
                logEmpty: '',
              },
              archive: {
                legend: '',
                description: '',
                export: '',
                import: '',
                modeLabel: '',
                modes: {
                  merge: '',
                  replace: '',
                },
                hint: '',
              },
              save: '',
              exit: '',
            },
            storage: {
              title: '',
              subtitle: '',
              loading: '',
              empty: '',
              usage: {
                used: '',
                available: '',
                total: '',
                library: '',
              },
              actions: {
                refresh: '',
                repair: '',
                downloadSelected: '',
                purge: '',
              },
              browser: {
                root: '',
                up: '',
                loading: '',
                empty: '',
                select: '',
                name: '',
                type: '',
                size: '',
                modified: '',
                actions: '',
                directory: '',
                file: '',
                unnamed: '',
                selectAction: '{{name}}',
              },
              purge: {
                none: '',
                available: ' {{count}} {{lectureWord}}',
                working: '',
                readyCount: '{{count}} {{lectureWord}}',
              },
              repair: {
                working: '',
                summary: ' {{count}} {{itemWord}}   {{freed}} ',
                none: '',
                noChange: '',
              },
              reveal: {
                unavailable: '',
              },
              classes: {
                summary: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
                empty: '',
                masteredCount: '{{count}} {{lectureWord}}',
              },
              modules: {
                summary: '{{lectureCount}} {{lectureWord}}',
                empty: '',
                masteredCount: '{{count}} {{lectureWord}}',
              },
              lecture: {
                audio: '',
                processedAudio: '',
                transcript: '',
                notes: '',
                slides: '',
                empty: '',
                eligible: '',
                processedBadge: '',
              },
              dialogs: {
                purgeTitle: '',
                purgeMessage: ' {{count}} {{lectureWord}}',
                deleteTitle: '',
                deleteMessage: '{{name}}',
                deleteConfirm: '',
              },
              unnamedClass: '',
              unnamedModule: '',
              unnamedLecture: '',
            },
            debug: {
              title: '',
              live: '',
              empty: '',
              error: '',
              stream: {
                title: '',
                empty: '',
              },
            },
            dialog: {
              cancel: '',
              confirm: '',
            },
            stats: {
              classes: '',
              modules: '',
              lectures: '',
              transcripts: '',
              slideDecks: '',
              audio: '',
              processedAudio: '',
              notes: '',
              slideArchives: '',
            },
            dialogs: {
              createClass: {
                title: '',
                message: '',
                placeholder: '',
              },
              createModule: {
                title: '',
                message: ' {{className}} ',
                placeholder: '',
              },
              createLecture: {
                title: '',
                message: ' {{context}} ',
                placeholder: '',
              },
              lectureDescription: {
                title: '',
                placeholder: '',
              },
              deleteClass: {
                title: '',
                message: '{{className}}',
                cancel: '',
                summary: ' {{moduleCount}} {{moduleWord}} {{lectureCount}} {{lectureWord}}',
              },
              deleteModule: {
                title: '',
                message: '{{moduleName}}{{classContext}}',
                cancel: '',
                summary: ' {{lectureCount}} {{lectureWord}}',
                classContext: '{{className}}',
              },
              deleteLecture: {
                title: '',
                message: '{{context}}',
                cancel: '',
              },
              removeAsset: {
                title: ' {{asset}}',
                message: '{{asset}}',
                confirm: '',
              },
              confirmDeletion: {
                title: '',
                message: '',
                confirm: '',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: '',
                message: ' Lecture Tools ',
              },
              slideRange: {
                title: '',
                description: '',
                loading: '',
                error: '',
                startLabel: '',
                endLabel: '',
                rangeHint: '',
                zoomLabel: '',
                zoomValue: '{{value}}% ',
                fallbackMessage: ' PDF',
                fallbackLink: ' PDF',
                fallbackFrameTitle: ' PDF ',
                summary: ' {{start}}{{end}}  {{total}} ',
                summarySingle: ' {{start}}  {{total}} ',
                summaryUnknown: ' {{start}}{{end}} ',
                summarySingleUnknown: ' {{start}} ',
                allPages: '',
                pageLabel: ' {{page}} ',
                selectAll: '',
                confirm: '',
              },
              upload: {
                title: '',
                description: '',
                prompt: '',
                help: '',
                browse: '',
                clear: '',
                waiting: '',
                preparing: '',
                uploading: '',
                processing: '',
                processingAction: '',
                processingAudio: '',
                processingSlides: '',
                backgroundProcessing: '',
                backgroundProcessingSlides: '',
                success: '',
                failure: '',
                progress: '',
                fileProgress: ' {{current}}  {{total}} ',
                filesSelected: ' {{count}} ',
                filesSummary: ' {{count}}  {{size}}',
                listHelp: '',
                uploadingFile: ' {{name}} {{current}}  {{total}} ',
                action: '',
                assetTitle: ' {{asset}}',
                assetDescription: '',
                archiveTitle: '',
                archiveDescription: ' Lecture Tools .zip',
              },
              descriptionOptional: '',
              descriptionPlaceholder: '',
            },
            dropdowns: {
              selectModule: '',
              noModules: '',
            },
            placeholders: {
              noLectures: '',
              noLecturesFilter: '',
              noClasses: '',
              noModules: '',
            },
            curriculum: {
              addClass: '',
              addModule: '',
              manageHeading: '',
              classMeta: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
              moduleMeta: '{{lectureCount}} {{lectureWord}}',
              editorHeading: 'Edit syllabus structure',
              editorHint:
                'Each line represents a class, module, or lecture. Use - for modules and -- for lectures. Include IDs in square brackets to keep existing items.',
              editorLineError: 'Line {{line}}: {{message}}',
              editorErrors: {
                missingClass: 'Modules must appear after a class.',
                missingModule: 'Lectures must appear after a module.',
                unknownClass: 'Class ID {{id}} was not found.',
                unknownModule: 'Module ID {{id}} was not found.',
                unknownLecture: 'Lecture ID {{id}} was not found.',
                duplicateClass: 'Class ID {{id}} appears more than once.',
                duplicateModule: 'Module ID {{id}} appears more than once.',
                duplicateLecture: 'Lecture ID {{id}} appears more than once.',
                nameRequired: 'A name is required.',
              },
            },
            common: {
              actions: {
                create: '',
                save: '',
                skip: '',
                delete: '',
                open: '',
                upload: '',
                exit: '',
                close: '',
                ok: '',
                reveal: '',
              },
            },
            viewer: {
              loading: '',
              failed: '',
              unsupported: '',
              types: {
                pdf: 'PDF',
                text: '',
                markdown: 'Markdown',
              },
            },
            status: {
              requireEdit: '',
              requireEditLecture: '',
              curriculumSaved: 'Syllabus updated.',
              curriculumSaveFailed: 'Unable to update the syllabus.',
              curriculumLoadFailed: '',
              classCreated: '',
              classRemoved: '',
              moduleCreated: '',
              moduleRemoved: '',
              lectureCreated: '',
              lectureRemoved: '',
              lectureUpdated: '',
              lectureTitleRequired: '',
              createLectureRequirements: '',
              slidesProcessed: ' Markdown ',
              slidesUploaded: 'PDF  Markdown ',
              slidesUploadRequired: ' PDF',
              slidePreviewFailed: ' PDF ',
              processingSlides: '',
              audioProcessingQueued: '',
              assetUploaded: '',
              assetRemoved: '',
              transcriptionPreparing: '====> ',
              transcriptionCompleted: '',
              processing: '',
              storageLoadFailed: '',
              storageUsageFailed: '',
              storagePurged: '',
              storagePurgeFailed: '',
              storageDeleted: '',
              storageDeleteFailed: '',
              storageDownloadReady: '',
              storageDownloadFailed: '',
              storageDownloadNone: '',
              storageRepairing: '',
              storageRepairComplete: ' {{count}} {{itemWord}} {{freed}} ',
              storageRepairNoChanges: '',
              storageRepairFailed: '',
              gpuChecking: '====>  GPU Whisper ',
              gpuConfirmed: 'GPU Whisper ',
              gpuUnavailable: ' GPU ',
              gpuUnsupported: ' GPU Whisper',
              gpuNotAvailable: ' GPU ',
              updateStarted: '',
              updateRunning: '',
              updateCompleted: '',
              updateFailed: '',
              updateConflict: '',
              shuttingDown: '',
              settingsSaved: '',
              gpuFallback: ' {{model}} ',
              lectureReordered: '',
              exporting: '',
              exportReady: '',
              exportFailed: '',
              importing: '',
              importSuccess: ' {{count}} ',
              importNoChanges: '',
            },
              counts: {
                module: { one: '', other: '' },
                lecture: { one: '', other: '' },
                task: { one: '', other: '' },
                item: { one: '', other: '' },
              },
          },
          es: {
            document: {
              title: 'Herramientas de clases',
            },
            sidebar: {
              heading: 'Herramientas de clases',
              tagline: 'Revisa, organiza y procesa recursos de clases rpidamente.',
              overview: 'Resumen',
              syllabusTitle: 'Programa del curso',
              searchLabel: 'Buscar en el programa',
              searchPlaceholder: 'Buscar por nombre',
              loading: 'Cargando',
              miniConsoleTitle: 'Mini consola',
              miniConsoleEmpty: 'Sin actividad reciente.',
            },
            topBar: {
              details: 'Detalles',
              enableEdit: 'Editar programa',
              exitEdit: 'Guardar programa',
              tasks: 'Tareas',
              create: 'Crear',
              storage: 'Almacenamiento',
              settings: 'Configuracin',
            },
            details: {
              title: 'Detalles de la clase',
              deleteLecture: 'Eliminar clase',
              editModeBanner: 'El modo edicin est activo. Actualiza o elimina elementos mientras est activo.',
              summaryPlaceholder: 'Selecciona una clase del plan de estudios.',
              edit: {
                titleLabel: 'Ttulo',
                moduleLabel: 'Mdulo',
                descriptionLabel: 'Descripcin',
                save: 'Guardar cambios',
              },
              noDescription: 'Sin descripcin registrada todava.',
            },
            assets: {
              title: 'Recursos',
              transcribe: 'Transcribir audio',
              modelLabel: 'Modelo',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU (acelerado por hardware)',
              },
              labels: {
                audio: 'Audio (.wav, .mp3, .mp4, .m4a, .aac, .flac, .ogg, .opus)',
                masteredAudio: 'Audio masterizado',
                slides: 'Diapositivas (PDF o documento)',
                transcript: 'Transcripcin',
                notes: 'Notas',
                slideBundle: 'Paquete de diapositivas (Markdown + ZIP)',
              },
              status: {
                notLinked: 'Sin vincular',
                slidesHint: 'Carga un PDF para generar el paquete Markdown. Otros documentos se almacenan tal cual.',
                noSlideImages: 'An no hay paquete de diapositivas. Sube un PDF y usa Procesar diapositivas para generarlo.',
                linked: 'Vinculado: {{name}}',
                slidesUploaded: 'Diapositivas subidas: {{name}}',
                slidesStoredOnly: 'Documento almacenado. El procesamiento solo est disponible para PDFs.',
                archiveCreated: 'Paquete creado: {{name}}',
                mastered: 'Masterizado: {{name}}',
                audioPending: 'Se cargaron {{count}} archivo(s) de audio pendientes de combinar.',
                slidesPending: 'Se cargaron {{count}} archivo(s) de diapositivas pendientes de combinar.',
              },
              actions: {
                upload: 'Subir',
                processSlides: 'Procesar diapositivas',
                view: 'Ver',
                download: 'Descargar',
                remove: 'Eliminar',
              },
            },
            tasks: {
              title: 'Tareas',
              description: 'Programa trabajos de transcripcin y procesamiento de diapositivas en secuencia.',
              empty: 'No hay tareas en la cola.',
              refresh: 'Actualizar',
              clearDone: 'Limpiar completadas',
              sections: {
                current: 'En curso',
                queued: 'En cola',
                done: 'Completadas',
                empty: 'No hay tareas en esta seccin.',
              },
              actions: {
                open: 'Abrir clase',
                retry: 'Reintentar',
                dismiss: 'Descartar',
              },
              bulkProcess: {
                button: 'Procesar en lote',
                title: 'Procesar en lote',
                subtitle: 'Selecciona clases y recursos para aadir a la cola de procesamiento.',
                selectAll: 'Seleccionar todo',
                clear: 'Limpiar seleccin',
                empty: 'No hay clases disponibles para procesar.',
                cancel: 'Cancelar',
                submit: 'Aadir a la cola',
                summaryEmpty: 'No hay tareas seleccionadas.',
                summarySelected: '{{count}} {{taskWord}} seleccionadas.',
                summaryBreakdown:
                  'Combinar PDFs de diapositivas: {{merge}}  Transcribir audio: {{transcription}}  Procesar diapositivas: {{slides}}.',
                status: {
                  unavailable: 'Se requiere subir el archivo',
                  empty: 'No seleccionado',
                  completed: 'Ya procesado',
                  selected: 'Se volver a procesar',
                },
              },
              bulkUpload: {
                button: 'Carga masiva',
                title: 'Carga masiva',
                fileProgress: 'Archivo {{current}} de {{total}}',
                lectureLabel: 'Clase',
                typeLabel: 'Tipo de archivo',
                selectLecture: 'Seleccione una clase',
                selectType: 'Seleccione un tipo de archivo',
                next: 'Subir y continuar',
                complete: 'Subir y finalizar',
                skip: 'Descartar',
                skipAll: 'Descartar todo',
                cancel: 'Cancelar',
                uploading: 'Subiendo {{name}}',
                success: '{{name}} subido.',
                failure: 'Error al subir {{name}}.',
                disposed: 'Se omiti {{name}}.',
                finished: 'Carga masiva completada: {{uploaded}} subidos, {{skipped}} omitidos.',
                noLectures: 'Agregue una clase antes de iniciar la carga masiva.',
                noTypes: 'No hay tipos de archivo disponibles para subir.',
              },
              bulkDownload: {
                button: 'Descarga masiva',
                title: 'Descarga masiva de recursos',
                subtitle: 'Selecciona clases y formatos para descargar.',
                selectAll: 'Seleccionar todo',
                clear: 'Limpiar seleccin',
                empty: 'No hay recursos disponibles para descargar.',
                cancel: 'Cancelar',
                submit: 'Preparar descarga',
                summaryEmpty: 'No hay recursos seleccionados.',
                summarySelected: '{{count}} {{assetWord}} seleccionados.',
                summaryBreakdown:
                  'Audio: {{audio}}  Transcripcin (TXT): {{txt}}  Diapositivas (PDF): {{pdf}}  Notas (MD): {{md}}  Paquetes (ZIP): {{zip}}.',
                assetSingular: 'recurso',
                assetPlural: 'recursos',
                status: {
                  available: 'Disponible',
                  selected: 'Seleccionado',
                  unavailable: 'No disponible',
                },
                assets: {
                  audio: 'Audio',
                  txt: 'Transcripcin (TXT)',
                  pdf: 'Diapositivas (PDF)',
                  md: 'Notas (MD)',
                  zip: 'Paquete (ZIP)',
                },
                preparing: 'Preparando archivo',
                ready: 'Archivo listo: {{filename}}.',
                failure: 'No se pudo preparar la descarga.',
                noneSelected: 'Selecciona al menos un recurso.',
              },
              status: {
                pending: 'Pendiente',
                running: 'En progreso',
                finished: 'Completado',
                failed: 'Fallido',
              },
              labels: {
                transcription: 'Transcripcin',
                slideBundle: 'Paquete de diapositivas',
                slideMerge: 'Fusin de PDF de diapositivas',
                generic: 'Tarea',
                untitled: 'Clase sin ttulo',
              },
              messages: {
                pending: 'Esperando recursos disponibles',
                completed: 'Completado correctamente.',
              },
              retryUnavailable: 'No es posible reintentar esta tarea.',
              form: {
                lectureLabel: 'Clase',
                placeholder: 'Selecciona una clase',
                operationLabel: 'Accin',
                operation: {
                  transcription: 'Transcribir audio',
                  slideBundle: 'Procesar diapositivas',
                  slideMerge: 'Combinar PDFs de diapositivas',
                },
                pageStartLabel: 'Pgina inicial',
                pageEndLabel: 'Pgina final',
                submit: 'Agregar tarea',
              },
              notifications: {
                queued: 'Tarea agregada a la cola.',
                cleared: 'Se quitaron {{count}} tareas completadas.',
              },
            },
            create: {
              title: 'Crear clase',
              moduleLabel: 'Mdulo',
              titleLabel: 'Ttulo',
              descriptionLabel: 'Descripcin',
              submit: 'Agregar clase',
            },
            settings: {
              title: 'Configuracin',
              appearance: {
                legend: 'Apariencia',
                displayModeLabel: 'Modo de visualizacin',
                displayMode: {
                  system: 'Seguir sistema',
                  bright: 'Claro',
                  dark: 'Oscuro',
                },
                themeLabel: 'Paleta de tema',
                theme: {
                  vibrant: 'Vibrante',
                  serene: 'Sereno',
                  noir: 'Noir',
                  solar: 'Solar',
                  cyber: 'Ciberntico',
                  pastel: 'Pastel',
                  obsidian: 'Obsidiana',
                  ethereal: 'Etreo',
                },
                effectsLabel: 'Nivel de efectos visuales',
                effects: {
                  none: 'Ninguno',
                  low: 'Bajo',
                  mid: 'Medio',
                  high: 'Alto',
                },
              },
              language: {
                label: 'Idioma',
                choices: {
                  en: 'English (Ingls)',
                  zh: ' (Chino)',
                  es: 'Espaol',
                  fr: 'Franais (Francs)',
                },
              },
              debug: {
                legend: 'Depuracin',
                enable: 'Activar modo de depuracin',
                description:
                  'Muestra en la derecha una consola en vivo con la salida detallada del programa.',
              },
              whisper: {
                legend: 'Transcripcin Whisper',
                modelLabel: 'Modelo predeterminado',
                model: {
                  tiny: 'Tiny (ms rpido)',
                  base: 'Base (equilibrado)',
                  small: 'Small (preciso)',
                  medium: 'Medium (detallado)',
                  large: 'Large (mxima precisin)',
                  gpu: 'GPU (acelerado por hardware)',
                },
                computeLabel: 'Tipo de cmputo',
                beamLabel: 'Tamao de haz',
                gpu: {
                  label: 'Compatibilidad con GPU',
                  status: 'Aceleracin GPU no probada.',
                  test: 'Probar compatibilidad',
                  retry: 'Volver a probar',
                },
              },
              cloudConnection: {
                legend: 'Conexin a la nube',
                enable: 'Conectarse al servidor en la nube',
                urlLabel: 'URL del servidor en la nube',
                autoConnect: 'Conectar automticamente al iniciar',
                processingLabel: 'Procesar tareas',
                processing: {
                  cloud: 'En la nube',
                  local: 'En esta mquina',
                },
                statusLabel: 'Estado de conexin',
                status: {
                  idle: 'No probado.',
                  connected: 'Conectado.',
                  disconnected: 'Desconectado.',
                  disabled: 'Desactivado.',
                },
                test: 'Probar conexin',
                description:
                  'Conecta la interfaz local a un servidor en la nube. El modo en la nube transmite estructuras y recursos bajo demanda y limpia los archivos al desconectar o reiniciar.',
                cancelReason: 'La sesin de conexin a la nube termin.',
                notifications: {
                  connected: 'Conexin a la nube establecida.',
                },
                errors: {
                  unavailable: 'El servidor en la nube no est disponible.',
                  disconnected: 'La conexin a la nube est activada pero el servidor no est disponible.',
                },
              },
              audio: {
                legend: 'Audio',
                masteringLabel: 'Habilitar audio masterizado',
                masteringDescription: 'Mejora automticamente el audio subido para mayor claridad.',
              },
              slides: {
                legend: 'Diapositivas',
                dpiLabel: 'DPI de renderizado',
                forceOcrLabel: 'Forzar OCR incluso cuando se detecta texto',
                forceOcrDescription: 'Siempre ejecuta OCR en PDFs de diapositivas, incluso si hay una capa de texto.',
                dpi: {
                  150: '150 dpi (ms rpido)',
                  200: '200 dpi (equilibrado)',
                  300: '300 dpi (detallado)',
                  400: '400 dpi (alto detalle)',
                  600: '600 dpi (mximo)',
                },
              },
              update: {
                legend: 'Actualizaciones del sistema',
                description: 'Actualiza Lecture Tools sin salir del navegador.',
                passwordLabel: 'Contrasea de sudo',
                passwordHelp:
                  'Las contraseas se ocultan despus de guardar. Ingresa una nueva para reemplazar la guardada.',
                passwordSaved: 'Contrasea guardada.',
                passwordClear: 'Borrar contrasea guardada',
                run: 'Ejecutar actualizacin',
                refresh: 'Actualizar estado',
                status: {
                  idle: 'No hay ninguna actualizacin en curso.',
                  running: 'Actualizacin en curso. Mantn esta ventana abierta hasta que termine.',
                  success: 'La actualizacin ms reciente se complet correctamente.',
                  failure: 'La actualizacin ms reciente tuvo un error.',
                },
                startedAt: 'Inici {{time}}.',
                finishedAt: 'Finaliz {{time}}.',
                exitCode: 'Cdigo de salida {{code}}.',
                logLabel: 'Registro de actividad',
                logEmpty: 'An no hay actividad de actualizacin.',
              },
              archive: {
                legend: 'Archivo',
                description:
                  'Exporta tus clases y recursos o importa un archivo desde otro equipo.',
                export: 'Exportar archivo',
                import: 'Importar archivo',
                modeLabel: 'Modo de importacin',
                modes: {
                  merge: 'Agregar al contenido existente',
                  replace: 'Borrar el contenido actual y sobrescribir',
                },
                hint: 'Los archivos exportados se guardan temporalmente y se eliminan al iniciar la aplicacin.',
              },
              save: 'Guardar configuracin',
              exit: 'Salir de la aplicacin',
            },
            storage: {
              title: 'Administrador de almacenamiento',
              subtitle: 'Revisa los recursos almacenados segn la estructura de clases.',
              loading: 'Cargando',
              empty: 'No se encontraron clases con almacenamiento.',
              usage: {
                used: 'En uso',
                available: 'Disponible',
                total: 'Total',
                library: 'Tamao de la biblioteca',
              },
              actions: {
                refresh: 'Actualizar',
                repair: 'Reparar almacenamiento',
                downloadSelected: 'Descargar seleccionados',
                purge: 'Quitar audio procesado',
              },
              browser: {
                root: 'Raz',
                up: 'Subir',
                loading: 'Cargando',
                empty: 'No hay archivos ni carpetas en esta ubicacin.',
                select: 'Seleccionar',
                name: 'Nombre',
                type: 'Tipo',
                size: 'Tamao',
                modified: 'Modificado',
                actions: 'Acciones',
                directory: 'Carpeta',
                file: 'Archivo',
                unnamed: 'Elemento sin nombre',
                selectAction: 'Seleccionar {{name}}',
              },
              purge: {
                none: 'No hay audio procesado para eliminar.',
                available: '{{count}} {{lectureWord}} listos para limpiar.',
                working: 'Eliminando audio',
                readyCount: '{{count}} {{lectureWord}} listos para limpiar',
              },
              repair: {
                working: 'Reparando',
                summary: 'Se eliminaron {{count}} {{itemWord}}  Se liberaron {{freed}}',
                none: 'An no se ha ejecutado la reparacin de almacenamiento.',
                noChange: 'No se liber espacio',
              },
              reveal: {
                unavailable: 'No se pudo localizar este elemento en el almacenamiento.',
              },
              classes: {
                summary: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
                empty: 'Esta clase no tiene mdulos almacenados.',
                masteredCount: '{{count}} {{lectureWord}} con audio masterizado',
              },
              modules: {
                summary: '{{lectureCount}} {{lectureWord}}',
                empty: 'Este mdulo no tiene clases almacenadas.',
                masteredCount: '{{count}} {{lectureWord}} con audio masterizado',
              },
              lecture: {
                audio: 'Audio',
                processedAudio: 'Audio masterizado',
                transcript: 'Transcripcin',
                notes: 'Notas',
                slides: 'Diapositivas',
                empty: 'Sin recursos vinculados.',
                eligible: 'Audio listo para eliminarse',
                processedBadge: 'Audio masterizado',
              },
              dialogs: {
                purgeTitle: 'Quitar audio procesado',
                purgeMessage:
                  'Eliminar los archivos de audio de {{count}} {{lectureWord}} que ya tienen transcripcin? Esta accin no se puede deshacer.',
                deleteTitle: 'Eliminar elemento de almacenamiento',
                deleteMessage: 'Eliminar {{name}}? Esta accin no se puede deshacer.',
                deleteConfirm: 'Eliminar',
              },
              unnamedClass: 'Clase sin nombre',
              unnamedModule: 'Mdulo sin nombre',
              unnamedLecture: 'Sesin sin nombre',
            },
            debug: {
              title: 'Consola de depuracin',
              live: 'En vivo',
              empty:
                'Activa el modo de depuracin para ver la actividad del programa en tiempo real.',
              error: 'No se pudo cargar la salida de depuracin.',
              stream: {
                title: 'Actividad del servidor',
                empty: 'Esperando actividad del servidor',
              },
            },
            dialog: {
              cancel: 'Cancelar',
              confirm: 'Confirmar',
            },
            stats: {
              classes: 'Cursos',
              modules: 'Mdulos',
              lectures: 'Clases',
              transcripts: 'Transcripciones',
              slideDecks: 'Presentaciones',
              audio: 'Archivos de audio',
              processedAudio: 'Audio masterizado',
              notes: 'Notas',
              slideArchives: 'Paquetes de diapositivas',
            },
            dialogs: {
              createClass: {
                title: 'Crear curso',
                message: 'Ingresa un nombre de curso.',
                placeholder: 'Introduccin a la astronoma',
              },
              createModule: {
                title: 'Crear mdulo',
                message: 'Nombre del mdulo para {{className}}',
                placeholder: 'Fundamentos',
              },
              createLecture: {
                title: 'Crear clase',
                message: 'Ttulo de la clase para {{context}}',
                placeholder: 'Ttulo de la clase',
              },
              lectureDescription: {
                title: 'Descripcin de la clase',
                placeholder: 'Agrega un esquema breve',
              },
              deleteClass: {
                title: 'Eliminar curso',
                message: 'Eliminar el curso "{{className}}"?',
                cancel: 'Conservar curso',
                summary: 'Esto eliminar {{moduleCount}} {{moduleWord}} y {{lectureCount}} {{lectureWord}}.',
              },
              deleteModule: {
                title: 'Eliminar mdulo',
                message: 'Eliminar el mdulo "{{moduleName}}"{{classContext}}?',
                cancel: 'Conservar mdulo',
                summary: 'Esto eliminar {{lectureCount}} {{lectureWord}}.',
                classContext: ' del curso "{{className}}"',
              },
              deleteLecture: {
                title: 'Eliminar clase',
                message: 'Eliminar la clase "{{context}}" y todos los recursos vinculados?',
                cancel: 'Conservar clase',
              },
              removeAsset: {
                title: 'Eliminar {{asset}}',
                message: 'Quieres eliminar el {{asset}} actual de esta clase? Esta accin no se puede deshacer.',
                confirm: 'Eliminar recurso',
              },
              confirmDeletion: {
                title: 'Confirmar eliminacin',
                message: 'Esta accin no se puede deshacer. Deseas eliminarla permanentemente?',
                confirm: 'S, eliminar',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: 'Salir de la aplicacin',
                message: 'Detener el servidor de Lecture Tools y cerrar esta pestaa?',
              },
              slideRange: {
                title: 'Seleccionar pginas a procesar',
                description:
                  'Revisa las miniaturas de las diapositivas y elige qu pginas convertir.',
                loading: 'Cargando vista previa',
                error:
                  'Se muestran abajo las previsualizaciones generadas en el servidor; ajusta el rango manualmente si es necesario.',
                startLabel: 'Pgina inicial',
                endLabel: 'Pgina final',
                rangeHint:
                  'Usa los campos o la vista previa para ajustar la seleccin.',
                zoomLabel: 'Zoom de la vista previa',
                zoomValue: 'Vista al {{value}}%',
                fallbackMessage:
                  'Abre el PDF de abajo en una pestaa nueva si necesitas revisarlo directamente.',
                fallbackLink: 'Abrir PDF en una pestaa nueva',
                fallbackFrameTitle: 'Vista previa de PDF alternativa',
                summary: 'Se procesarn las pginas {{start}}{{end}} de {{total}}.',
                summarySingle: 'Se procesar la pgina {{start}} de {{total}}.',
                summaryUnknown: 'Procesando las pginas {{start}}{{end}}.',
                summarySingleUnknown: 'Procesando la pgina {{start}}.',
                allPages: 'Se procesarn todas las pginas del documento.',
                pageLabel: 'Pgina {{page}}',
                selectAll: 'Seleccionar todo',
                confirm: 'Confirmar y continuar',
              },
              upload: {
                title: 'Subir archivo',
                description: 'Arrastra un archivo aqu o examina tu equipo para seleccionarlo.',
                prompt: 'Arrastra y suelta un archivo',
                help: 'Tambin puedes hacer clic para elegir un archivo.',
                browse: 'Seleccionar archivo',
                clear: 'Quitar',
                waiting: 'Selecciona un archivo para continuar.',
                preparing: 'Preparando archivo',
                uploading: 'Subiendo',
                processing: 'Procesando carga',
                processingAction: 'Procesando',
                processingAudio: 'Procesando audio',
                processingSlides: 'Procesando diapositivas',
                backgroundProcessing:
                  'El procesamiento de audio continuar en segundo plano. Puedes cerrar este cuadro de dilogo con seguridad.',
                backgroundProcessingSlides:
                  'La conversin de diapositivas continuar en segundo plano. Puedes cerrar este cuadro de dilogo mientras finaliza.',
                success: 'Subida completada.',
                failure: 'La subida fall. Vuelve a intentarlo.',
                progress: 'Progreso de subida',
                fileProgress: 'Archivo {{current}} de {{total}}',
                filesSelected: '{{count}} archivos seleccionados',
                filesSummary: '{{count}} archivos  {{size}} en total',
                listHelp: 'Arrastra para reordenar los archivos antes de subirlos.',
                uploadingFile: 'Subiendo {{name}} ({{current}} de {{total}})',
                action: 'Subir',
                assetTitle: 'Subir {{asset}}',
                assetDescription: 'Elige un archivo nuevo para este recurso.',
                archiveTitle: 'Importar archivo comprimido',
                archiveDescription: 'Selecciona un archivo exportado de Lecture Tools (.zip).',
              },
              descriptionOptional: 'Descripcin (opcional)',
              descriptionPlaceholder: 'Agrega un breve resumen',
            },
            dropdowns: {
              selectModule: 'Seleccionar mdulo',
              noModules: 'No hay mdulos disponibles',
            },
            placeholders: {
              noLectures: 'Sin clases',
              noLecturesFilter: 'Ninguna clase coincide con el filtro actual.',
              noClasses: 'An no hay cursos disponibles.',
              noModules: 'Sin mdulos por ahora.',
            },
            curriculum: {
              addClass: 'Agregar curso',
              addModule: 'Agregar mdulo',
              manageHeading: 'Administrar programa',
              classMeta: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
              moduleMeta: '{{lectureCount}} {{lectureWord}}',
              editorHeading: 'Edit syllabus structure',
              editorHint:
                'Each line represents a class, module, or lecture. Use - for modules and -- for lectures. Include IDs in square brackets to keep existing items.',
              editorLineError: 'Line {{line}}: {{message}}',
              editorErrors: {
                missingClass: 'Modules must appear after a class.',
                missingModule: 'Lectures must appear after a module.',
                unknownClass: 'Class ID {{id}} was not found.',
                unknownModule: 'Module ID {{id}} was not found.',
                unknownLecture: 'Lecture ID {{id}} was not found.',
                duplicateClass: 'Class ID {{id}} appears more than once.',
                duplicateModule: 'Module ID {{id}} appears more than once.',
                duplicateLecture: 'Lecture ID {{id}} appears more than once.',
                nameRequired: 'A name is required.',
              },
            },
            common: {
              actions: {
                create: 'Crear',
                save: 'Guardar',
                skip: 'Omitir',
                delete: 'Eliminar',
                open: 'Abrir',
                upload: 'Subir',
                exit: 'Salir',
                close: 'Cerrar',
                ok: 'Aceptar',
                reveal: 'Mostrar',
              },
            },
            viewer: {
              loading: 'Cargando',
              failed: 'No se pudo cargar el archivo.',
              unsupported: 'Este tipo de archivo no se puede visualizar en lnea.',
              types: {
                pdf: 'PDF',
                text: 'Texto sin formato',
                markdown: 'Markdown',
              },
            },
            status: {
              requireEdit: 'Activa el modo edicin para gestionar el plan de estudios.',
              requireEditLecture: 'Activa el modo edicin para actualizar los detalles.',
              curriculumSaved: 'Syllabus updated.',
              curriculumSaveFailed: 'Unable to update the syllabus.',
              curriculumLoadFailed: 'No se pudo cargar el programa del curso.',
              classCreated: 'Curso creado.',
              classRemoved: 'Curso eliminado.',
              moduleCreated: 'Mdulo creado.',
              moduleRemoved: 'Mdulo eliminado.',
              lectureCreated: 'Clase creada.',
              lectureRemoved: 'Clase eliminada.',
              lectureUpdated: 'Clase actualizada.',
              lectureTitleRequired: 'El ttulo de la clase es obligatorio.',
              createLectureRequirements: 'Selecciona un mdulo e ingresa un ttulo.',
              slidesProcessed: 'Diapositivas convertidas en un paquete Markdown con imgenes.',
              slidesUploaded: 'Diapositivas subidas. Los PDFs pueden procesarse para generar el paquete Markdown.',
              slidesUploadRequired: 'Sube un PDF antes de procesar las diapositivas. Otros documentos se guardan tal cual.',
              slidePreviewFailed:
                'No se pudo preparar la vista previa de las diapositivas. Asegrate de que el archivo sea un PDF e intntalo de nuevo.',
              processingSlides: 'Procesando diapositivas',
              audioProcessingQueued: 'Audio subido. La masterizacin continuar en segundo plano.',
              assetUploaded: 'Recurso subido correctamente.',
              assetRemoved: 'Recurso eliminado.',
              transcriptionPreparing: '====> Preparando transcripcin',
              transcriptionCompleted: 'Transcripcin completada.',
              processing: 'Procesando',
              storageLoadFailed: 'No se pudieron cargar los contenidos del almacenamiento.',
              storageUsageFailed: 'No se pudo cargar el uso del almacenamiento.',
              storagePurged: 'Audio procesado eliminado.',
              storagePurgeFailed: 'No se pudo eliminar el audio procesado.',
              storageDeleted: 'Elemento de almacenamiento eliminado.',
              storageDeleteFailed: 'No se pudo eliminar el elemento de almacenamiento.',
              storageDownloadReady: 'Descarga preparada.',
              storageDownloadFailed: 'No se pudo preparar la descarga.',
              storageDownloadNone: 'Selecciona al menos un elemento.',
              storageRepairing: 'Buscando archivos temporales en el almacenamiento',
              storageRepairComplete:
                'Reparacin completada. Se eliminaron {{count}} {{itemWord}} y se liberaron {{freed}}.',
              storageRepairNoChanges: 'Reparacin completada. No se encontraron elementos temporales.',
              storageRepairFailed: 'No se pudo reparar el almacenamiento.',
              gpuChecking: '====> Comprobando compatibilidad con GPU Whisper',
              gpuConfirmed: 'Compatibilidad con GPU Whisper confirmada.',
              gpuUnavailable: 'GPU no disponible en esta plataforma.',
              gpuUnsupported: 'GPU Whisper no es compatible con esta plataforma.',
              gpuNotAvailable: 'La aceleracin GPU no est disponible en esta plataforma.',
              updateStarted: 'Actualizacin iniciada.',
              updateRunning: 'Actualizacin en curso. Mantn esta ventana abierta.',
              updateCompleted: 'Actualizacin completada correctamente.',
              updateFailed: 'La actualizacin fall. Revisa el registro para ms detalles.',
              updateConflict: 'Ya hay una actualizacin en curso.',
              shuttingDown: 'Cerrando la aplicacin',
              settingsSaved: 'Configuracin guardada.',
              gpuFallback: 'Se usar el modelo {{model}}.',
              lectureReordered: 'El orden de las clases se actualiz.',
              exporting: 'Preparando archivo',
              exportReady: 'Archivo listo para descargar.',
              exportFailed: 'No se pudo crear el archivo.',
              importing: 'Importando archivo',
              importSuccess: 'Se importaron {{count}} clases.',
              importNoChanges: 'Archivo importado (sin clases nuevas).',
            },
              counts: {
                module: { one: 'mdulo', other: 'mdulos' },
                lecture: { one: 'clase', other: 'clases' },
                task: { one: 'tarea', other: 'tareas' },
                item: { one: 'elemento', other: 'elementos' },
              },
          },
          fr: {
            document: {
              title: 'Outils de cours',
            },
            sidebar: {
              heading: 'Outils de cours',
              tagline: 'Passez en revue, organisez et traitez rapidement les ressources de cours.',
              overview: 'Vue densemble',
              syllabusTitle: 'Plan de cours',
              searchLabel: 'Rechercher dans le plan',
              searchPlaceholder: 'Rechercher par nom',
              loading: 'Chargement',
              miniConsoleTitle: 'Mini console',
              miniConsoleEmpty: 'Aucune activit rcente.',
            },
            topBar: {
              details: 'Dtails',
              enableEdit: 'Modifier le programme',
              exitEdit: 'Enregistrer le programme',
              tasks: 'Tches',
              create: 'Crer',
              storage: 'Stockage',
              settings: 'Paramtres',
            },
            details: {
              title: 'Dtails du cours',
              deleteLecture: 'Supprimer le cours',
              editModeBanner:
                'Le mode dition est activ. Mettez  jour les informations ou supprimez des lments pendant quil est actif.',
              summaryPlaceholder: 'Slectionnez un cours dans le programme.',
              edit: {
                titleLabel: 'Titre',
                moduleLabel: 'Module',
                descriptionLabel: 'Description',
                save: 'Enregistrer les modifications',
              },
              noDescription: 'Aucune description enregistre pour le moment.',
            },
            assets: {
              title: 'Ressources',
              transcribe: 'Transcrire laudio',
              modelLabel: 'Modle',
              model: {
                tiny: 'tiny',
                base: 'base',
                small: 'small',
                medium: 'medium',
                large: 'large',
                gpu: 'GPU (acclration matrielle)',
              },
              labels: {
                audio: 'Audio (.wav, .mp3, .mp4, .m4a, .aac, .flac, .ogg, .opus)',
                masteredAudio: 'Audio masteris',
                slides: 'Diapositives (PDF ou document)',
                transcript: 'Transcription',
                notes: 'Notes',
                slideBundle: 'Archive de diapositives (Markdown + ZIP)',
              },
              status: {
                notLinked: 'Non li',
                slidesHint:
                  'Importez un PDF pour gnrer larchive Markdown. Les autres documents sont conservs tels quels.',
                noSlideImages:
                  'Aucune archive de diapositives. Importez un PDF puis utilisez Traiter les diapositives pour la gnrer.',
                linked: 'Li: {{name}}',
                slidesUploaded: 'Diapositives importes: {{name}}',
                slidesStoredOnly: 'Document enregistr. Le traitement est rserv aux PDF.',
                archiveCreated: 'Archive cre: {{name}}',
                mastered: 'Masteris: {{name}}',
                audioPending: '{{count}} fichier(s) audio en attente de combinaison.',
                slidesPending: '{{count}} fichier(s) de diapositives en attente de combinaison.',
              },
              actions: {
                upload: 'Importer',
                processSlides: 'Traiter les diapositives',
                view: 'Voir',
                download: 'Tlcharger',
                remove: 'Supprimer',
              },
            },
            tasks: {
              title: 'Tches',
              description:
                'Planifiez les transcriptions audio et les conversions de diapositives  excuter lune aprs lautre.',
              empty: 'Aucune tche dans la file.',
              refresh: 'Actualiser',
              clearDone: 'Effacer termines',
              sections: {
                current: 'En cours',
                queued: 'En file',
                done: 'Termines',
                empty: 'Aucune tche dans cette section.',
              },
              actions: {
                open: 'Ouvrir la leon',
                retry: 'Ressayer',
                dismiss: 'Ignorer',
              },
              bulkProcess: {
                button: 'Traitement group',
                title: 'Traitement group',
                subtitle: 'Slectionnez les cours et lments  ajouter  la file de traitement.',
                selectAll: 'Tout slectionner',
                clear: 'Effacer la slection',
                empty: 'Aucun cours disponible pour le traitement.',
                cancel: 'Annuler',
                submit: 'Ajouter  la file',
                summaryEmpty: 'Aucune tche slectionne.',
                summarySelected: '{{count}} {{taskWord}} slectionne(s).',
                summaryBreakdown:
                  'Fusionner les PDF de diapositives: {{merge}}  Transcrire laudio: {{transcription}}  Traiter les diapositives: {{slides}}.',
                status: {
                  unavailable: 'Tlversement requis',
                  empty: 'Non slectionn',
                  completed: 'Dj trait',
                  selected: 'Sera retrait',
                },
              },
              bulkUpload: {
                button: 'Tlversement group',
                title: 'Tlversement group',
                fileProgress: 'Fichier {{current}} sur {{total}}',
                lectureLabel: 'Cours',
                typeLabel: 'Type de fichier',
                selectLecture: 'Slectionnez un cours',
                selectType: 'Slectionnez un type de fichier',
                next: 'Tlverser et suivant',
                complete: 'Tlverser et terminer',
                skip: 'Ignorer',
                skipAll: 'Tout ignorer',
                cancel: 'Annuler',
                uploading: 'Tlversement de {{name}}',
                success: '{{name}} tlvers.',
                failure: 'chec du tlversement de {{name}}.',
                disposed: '{{name}} ignor.',
                finished:
                  'Tlversement group termin: {{uploaded}} tlverss, {{skipped}} ignors.',
                noLectures: 'Ajoutez un cours avant de lancer un tlversement group.',
                noTypes: 'Aucun type de fichier tlversable nest disponible.',
              },
              bulkDownload: {
                button: 'Tlchargement group',
                title: 'Tlchargement group de ressources',
                subtitle: 'Slectionnez les cours et formats  tlcharger.',
                selectAll: 'Tout slectionner',
                clear: 'Effacer la slection',
                empty: 'Aucune ressource disponible pour le tlchargement.',
                cancel: 'Annuler',
                submit: 'Prparer le tlchargement',
                summaryEmpty: 'Aucune ressource slectionne.',
                summarySelected: '{{count}} {{assetWord}} slectionn(s).',
                summaryBreakdown:
                  'Audio: {{audio}}  Transcription (TXT): {{txt}}  Diapositives (PDF): {{pdf}}  Notes (MD): {{md}}  Archives (ZIP): {{zip}}.',
                assetSingular: 'ressource',
                assetPlural: 'ressources',
                status: {
                  available: 'Disponible',
                  selected: 'Slectionn',
                  unavailable: 'Manquant',
                },
                assets: {
                  audio: 'Audio',
                  txt: 'Transcription (TXT)',
                  pdf: 'Diapositives (PDF)',
                  md: 'Notes (MD)',
                  zip: 'Archive (ZIP)',
                },
                preparing: 'Prparation de larchive',
                ready: 'Archive prte: {{filename}}.',
                failure: 'Impossible de prparer le tlchargement.',
                noneSelected: 'Slectionnez au moins une ressource.',
              },
              status: {
                pending: 'En attente',
                running: 'En cours',
                finished: 'Termin',
                failed: 'chou',
              },
              labels: {
                transcription: 'Transcription',
                slideBundle: 'Archive de diapositives',
                slideMerge: 'Fusion de PDF de diapositives',
                generic: 'Tche',
                untitled: 'Leon sans titre',
              },
              messages: {
                pending: 'En attente de ressources disponibles',
                completed: 'Termin avec succs.',
              },
              retryUnavailable: 'Impossible de relancer cette tche.',
              form: {
                lectureLabel: 'Leon',
                placeholder: 'Slectionnez une leon',
                operationLabel: 'Action',
                operation: {
                  transcription: 'Transcrire laudio',
                  slideBundle: 'Traiter les diapositives',
                  slideMerge: 'Fusionner les PDF tlverss',
                },
                pageStartLabel: 'Page de dbut',
                pageEndLabel: 'Page de fin',
                submit: 'Ajouter la tche',
              },
              notifications: {
                queued: 'Tche ajoute  la file.',
                cleared: '{{count}} tches termines ont t supprimes.',
              },
            },
            create: {
              title: 'Crer un cours',
              moduleLabel: 'Module',
              titleLabel: 'Titre',
              descriptionLabel: 'Description',
              submit: 'Ajouter le cours',
            },
            settings: {
              title: 'Paramtres',
              appearance: {
                legend: 'Apparence',
                displayModeLabel: 'Mode daffichage',
                displayMode: {
                  system: 'Suivre le systme',
                  bright: 'Clair',
                  dark: 'Sombre',
                },
                themeLabel: 'Palette de thme',
                theme: {
                  vibrant: 'Vibrant',
                  serene: 'Serein',
                  noir: 'Noir',
                  solar: 'Solaire',
                  cyber: 'Cyber',
                  pastel: 'Pastel',
                  obsidian: 'Obsidienne',
                  ethereal: 'thr',
                },
                effectsLabel: 'Effets visuels',
                effects: {
                  none: 'Aucun',
                  low: 'Faible',
                  mid: 'Moyen',
                  high: 'lev',
                },
              },
              language: {
                label: 'Langue',
                choices: {
                  en: 'English (Anglais)',
                  zh: ' (Chinois)',
                  es: 'Espaol (Espagnol)',
                  fr: 'Franais',
                },
              },
              debug: {
                legend: 'Dbogage',
                enable: 'Activer le mode dbogage',
                description:
                  'Affiche sur la droite une console en direct avec la sortie dtaille du programme.',
              },
              whisper: {
                legend: 'Transcription Whisper',
                modelLabel: 'Modle par dfaut',
                model: {
                  tiny: 'Tiny (plus rapide)',
                  base: 'Base (quilibr)',
                  small: 'Small (prcis)',
                  medium: 'Medium (dtaill)',
                  large: 'Large (prcision maximale)',
                  gpu: 'GPU (acclration matrielle)',
                },
                computeLabel: 'Type de calcul',
                beamLabel: 'Taille du faisceau',
                gpu: {
                  label: 'Prise en charge GPU',
                  status: 'Acclration GPU non teste.',
                  test: 'Tester la prise en charge',
                  retry: 'Relancer le test',
                },
              },
              cloudConnection: {
                legend: 'Connexion cloud',
                enable: 'Se connecter au serveur cloud',
                urlLabel: 'URL du serveur cloud',
                autoConnect: 'Connexion automatique au dmarrage',
                processingLabel: 'Traiter les tches',
                processing: {
                  cloud: 'Dans le cloud',
                  local: 'Sur cette machine',
                },
                statusLabel: 'tat de connexion',
                status: {
                  idle: 'Non test.',
                  connected: 'Connect.',
                  disconnected: 'Dconnect.',
                  disabled: 'Dsactiv.',
                },
                test: 'Tester la connexion',
                description:
                  'Connecte linterface locale  un serveur cloud. Le mode cloud diffuse les structures et ressources  la demande et nettoie les fichiers lors de la dconnexion ou du redmarrage.',
                cancelReason: 'La session de connexion cloud est termine.',
                notifications: {
                  connected: 'Connexion cloud tablie.',
                },
                errors: {
                  unavailable: 'Le serveur cloud est indisponible.',
                  disconnected: 'La connexion cloud est active mais le serveur est indisponible.',
                },
              },
              audio: {
                legend: 'Audio',
                masteringLabel: 'Activer laudio optimis',
                masteringDescription: 'Amliore automatiquement laudio import pour une meilleure clart.',
              },
              slides: {
                legend: 'Diapositives',
                dpiLabel: 'DPI de rendu',
                forceOcrLabel: 'Forcer lOCR mme si du texte est dtect',
                forceOcrDescription:
                  'Toujours excuter lOCR sur les PDF de diapositives, mme sune couche de texte est prsente.',
                dpi: {
                  150: '150 dpi (plus rapide)',
                  200: '200 dpi (quilibr)',
                  300: '300 dpi (dtaill)',
                  400: '400 dpi (trs dtaill)',
                  600: '600 dpi (maximum)',
                },
              },
              update: {
                legend: 'Mises  jour du systme',
                description: 'Mettez Lecture Tools  jour sans quitter le navigateur.',
                passwordLabel: 'Mot de passe sudo',
                passwordHelp:
                  'Les mots de passe sont masqus aprs lenregistrement. Saisissez-en un nouveau pour remplacer celui enregistr.',
                passwordSaved: 'Mot de passe enregistr.',
                passwordClear: 'Supprimer le mot de passe enregistr',
                run: 'Lancer la mise  jour',
                refresh: 'Actualiser ltat',
                status: {
                  idle: 'Aucune mise  jour en cours.',
                  running: 'Mise  jour en cours. Laissez cette fentre ouverte jusqu la fin.',
                  success: 'La dernire mise  jour sest termine avec succs.',
                  failure: 'La dernire mise  jour a rencontr une erreur.',
                },
                startedAt: 'Dmarre {{time}}.',
                finishedAt: 'Termine {{time}}.',
                exitCode: 'Code de sortie {{code}}.',
                logLabel: 'Journal dactivit',
                logEmpty: 'Aucune activit de mise  jour pour le moment.',
              },
              archive: {
                legend: 'Archive',
                description:
                  'Exportez vos cours et ressources ou importez une archive depuis une autre machine.',
                export: 'Exporter larchive',
                import: 'Importer une archive',
                modeLabel: 'Mode dimportation',
                modes: {
                  merge: 'Ajouter au contenu existant',
                  replace: 'Effacer le contenu actuel puis craser',
                },
                hint: 'Les archives exportes sont conserves temporairement et supprimes au dmarrage de lapplication.',
              },
              save: 'Enregistrer les paramtres',
              exit: 'Quitter lapplication',
            },
            storage: {
              title: 'Gestionnaire de stockage',
              subtitle: 'Consultez les ressources stockes selon la structure des cours.',
              loading: 'Chargement',
              empty: 'Aucune classe stocke trouve.',
              usage: {
                used: 'Utilis',
                available: 'Disponible',
                total: 'Total',
                library: 'Taille de la bibliothque',
              },
              actions: {
                refresh: 'Actualiser',
                repair: 'Rparer le stockage',
                downloadSelected: 'Tlcharger la slection',
                purge: 'Supprimer laudio trait',
              },
              browser: {
                root: 'Racine',
                up: 'Dossier parent',
                loading: 'Chargement',
                empty: 'Aucun fichier ou dossier  cet emplacement.',
                select: 'Slectionner',
                name: 'Nom',
                type: 'Type',
                size: 'Taille',
                modified: 'Modifi',
                actions: 'Actions',
                directory: 'Dossier',
                file: 'Fichier',
                unnamed: 'lment sans nom',
                selectAction: 'Slectionner {{name}}',
              },
              purge: {
                none: 'Aucun audio trait  supprimer.',
                available: '{{count}} {{lectureWord}} prts  nettoyer.',
                working: 'Suppression des audios',
                readyCount: '{{count}} {{lectureWord}} prts  nettoyer',
              },
              repair: {
                working: 'Rparation',
                summary: '{{count}} {{itemWord}} supprims  {{freed}} librs',
                none: 'Aucune rparation de stockage na encore t effectue.',
                noChange: 'Aucun espace libr',
              },
              reveal: {
                unavailable: 'Impossible de localiser cet lment dans le stockage.',
              },
              classes: {
                summary: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
                empty: 'Ce cours na pas encore de modules stocks.',
                masteredCount: '{{count}} {{lectureWord}} avec audio masteris',
              },
              modules: {
                summary: '{{lectureCount}} {{lectureWord}}',
                empty: 'Ce module na pas encore de sances stockes.',
                masteredCount: '{{count}} {{lectureWord}} avec audio masteris',
              },
              lecture: {
                audio: 'Audio',
                processedAudio: 'Audio masteris',
                transcript: 'Transcription',
                notes: 'Notes',
                slides: 'Diapositives',
                empty: 'Aucune ressource lie.',
                eligible: 'Audio prt  tre supprim',
                processedBadge: 'Audio masteris',
              },
              dialogs: {
                purgeTitle: 'Supprimer laudio trait',
                purgeMessage:
                  'Supprimer les fichiers audio de {{count}} {{lectureWord}} dj transcrites? Cette action est irrversible.',
                deleteTitle: 'Supprimer llment de stockage',
                deleteMessage: 'Supprimer  {{name}}  ? Cette action est irrversible.',
                deleteConfirm: 'Supprimer',
              },
              unnamedClass: 'Cours sans nom',
              unnamedModule: 'Module sans nom',
              unnamedLecture: 'Sance sans nom',
            },
            debug: {
              title: 'Console de dbogage',
              live: 'En direct',
              empty:
                "Activez le mode dbogage pour suivre lactivit du programme en temps rel.",
              error: 'Impossible de charger la sortie de dbogage.',
              stream: {
                title: 'Activit du serveur',
                empty: 'En attente dactivit du serveur',
              },
            },
            dialog: {
              cancel: 'Annuler',
              confirm: 'Confirmer',
            },
            stats: {
              classes: 'Cours',
              modules: 'Modules',
              lectures: 'Leons',
              transcripts: 'Transcriptions',
              slideDecks: 'Prsentations',
              audio: 'Fichiers audio',
              processedAudio: 'Audio masteris',
              notes: 'Notes',
              slideArchives: 'Paquets de diapositives',
            },
            dialogs: {
              createClass: {
                title: 'Crer un cours',
                message: 'Saisissez le nom du cours.',
                placeholder: 'Introduction  lastronomie',
              },
              createModule: {
                title: 'Crer un module',
                message: 'Nom du module pour {{className}}',
                placeholder: 'Fondements',
              },
              createLecture: {
                title: 'Crer une leon',
                message: 'Titre de la leon pour {{context}}',
                placeholder: 'Titre de la leon',
              },
              lectureDescription: {
                title: 'Description de la leon',
                placeholder: 'Ajoutez un court aperu',
              },
              deleteClass: {
                title: 'Supprimer le cours',
                message: 'Supprimer le cours {{className}}?',
                cancel: 'Conserver le cours',
                summary: 'Cette action supprimera {{moduleCount}} {{moduleWord}} et {{lectureCount}} {{lectureWord}}.',
              },
              deleteModule: {
                title: 'Supprimer le module',
                message: 'Supprimer le module {{moduleName}}{{classContext}}?',
                cancel: 'Conserver le module',
                summary: 'Cette action supprimera {{lectureCount}} {{lectureWord}}.',
                classContext: ' du cours {{className}}',
              },
              deleteLecture: {
                title: 'Supprimer la leon',
                message: 'Supprimer la leon {{context}} et toutes les ressources associes?',
                cancel: 'Conserver la leon',
              },
              removeAsset: {
                title: 'Supprimer {{asset}}',
                message: 'Supprimer la ressource {{asset}} de cette leon? Cette action est irrversible.',
                confirm: 'Supprimer la ressource',
              },
              confirmDeletion: {
                title: 'Confirmer la suppression',
                message: 'Cette action est irrversible. Souhaitez-vous la supprimer dfinitivement?',
                confirm: 'Oui, supprimer',
              },
              gpuWhisper: {
                title: 'GPU Whisper',
              },
              exitApp: {
                title: 'Quitter lapplication',
                message: 'Arrter le serveur Lecture Tools et fermer cet onglet?',
              },
              slideRange: {
                title: 'Slectionner les pages  traiter',
                description:
                  'Parcourez les miniatures des diapositives ci-dessous et choisissez les pages  convertir en images.',
                loading: 'Chargement de laperu',
                error:
                  'Les aperus gnrs par le serveur sont affichs ci-dessous; ajustez la plage manuellement si ncessaire.',
                startLabel: 'Page de dbut',
                endLabel: 'Page de fin',
                rangeHint: 'Utilisez les champs ou laperu pour ajuster la slection.',
                zoomLabel: 'Zoom de laperu',
                zoomValue: 'Vue  {{value}}%',
                fallbackMessage:
                  'Ouvrez le PDF ci-dessous dans un nouvel onglet si vous devez lexaminer directement.',
                fallbackLink: 'Ouvrir le PDF dans un nouvel onglet',
                fallbackFrameTitle: 'Aperu PDF de secours',
                summary: 'Traitement des pages {{start}}  {{end}} sur {{total}}.',
                summarySingle: 'Traitement de la page {{start}} sur {{total}}.',
                summaryUnknown: 'Traitement des pages {{start}}  {{end}}.',
                summarySingleUnknown: 'Traitement de la page {{start}}.',
                allPages: 'Traitement de toutes les pages du document.',
                pageLabel: 'Page {{page}}',
                selectAll: 'Tout slectionner',
                confirm: 'Confirmer et continuer',
              },
              upload: {
                title: 'Tlverser un fichier',
                description:
                  'Glissez un fichier ici ou parcourez votre ordinateur pour le slectionner.',
                prompt: 'Glissez-dposez un fichier',
                help: 'Vous pouvez aussi cliquer pour choisir un fichier.',
                browse: 'Slectionner un fichier',
                clear: 'Retirer',
                waiting: 'Slectionnez un fichier pour continuer.',
                preparing: 'Prparation du fichier',
                uploading: 'Tlversement',
                processing: 'Traitement du tlversement',
                processingAction: 'Traitement',
                processingAudio: 'Traitement de laudio',
                processingSlides: 'Traitement des diapositives',
                backgroundProcessing:
                  'Le traitement audio se poursuit en arrire-plan. Vous pouvez fermer cette bote de dialogue en toute scurit.',
                backgroundProcessingSlides:
                  'La conversion des diapositives se poursuit en arrire-plan. Vous pouvez fermer cette bote de dialogue pendant le traitement.',
                success: 'Tlversement termin.',
                failure: 'Le tlversement a chou. Ressayez.',
                progress: 'Progression du tlversement',
                fileProgress: 'Fichier {{current}} sur {{total}}',
                filesSelected: '{{count}} fichiers slectionns',
                filesSummary: '{{count}} fichiers  {{size}} au total',
                listHelp: 'Faites glisser pour rorganiser les fichiers avant le tlversement.',
                uploadingFile: 'Tlversement de {{name}} ({{current}} sur {{total}})',
                action: 'Tlverser',
                assetTitle: 'Tlverser {{asset}}',
                assetDescription: 'Choisissez un nouveau fichier  associer  cette ressource.',
                archiveTitle: 'Importer une archive',
                archiveDescription: 'Slectionnez une archive Lecture Tools exporte (.zip).',
              },
              descriptionOptional: 'Description (optionnel)',
              descriptionPlaceholder: 'Ajoutez un court rsum',
            },
            dropdowns: {
              selectModule: 'Slectionner un module',
              noModules: 'Aucun module disponible',
            },
            placeholders: {
              noLectures: 'Aucune leon',
              noLecturesFilter: 'Aucune leon ne correspond au filtre actuel.',
              noClasses: 'Aucun cours disponible pour le moment.',
              noModules: 'Aucun module pour le moment.',
            },
            curriculum: {
              addClass: 'Ajouter un cours',
              addModule: 'Ajouter un module',
              manageHeading: 'Grer le plan de cours',
              classMeta: '{{moduleCount}} {{moduleWord}}  {{lectureCount}} {{lectureWord}}',
              moduleMeta: '{{lectureCount}} {{lectureWord}}',
              editorHeading: 'Edit syllabus structure',
              editorHint:
                'Each line represents a class, module, or lecture. Use - for modules and -- for lectures. Include IDs in square brackets to keep existing items.',
              editorLineError: 'Line {{line}}: {{message}}',
              editorErrors: {
                missingClass: 'Modules must appear after a class.',
                missingModule: 'Lectures must appear after a module.',
                unknownClass: 'Class ID {{id}} was not found.',
                unknownModule: 'Module ID {{id}} was not found.',
                unknownLecture: 'Lecture ID {{id}} was not found.',
                duplicateClass: 'Class ID {{id}} appears more than once.',
                duplicateModule: 'Module ID {{id}} appears more than once.',
                duplicateLecture: 'Lecture ID {{id}} appears more than once.',
                nameRequired: 'A name is required.',
              },
            },
            common: {
              actions: {
                create: 'Crer',
                save: 'Enregistrer',
                skip: 'Ignorer',
                delete: 'Supprimer',
                open: 'Ouvrir',
                upload: 'Importer',
                exit: 'Quitter',
                close: 'Fermer',
                ok: 'OK',
                reveal: 'Afficher',
              },
            },
            viewer: {
              loading: 'Chargement',
              failed: 'Impossible de charger le fichier.',
              unsupported: 'Ce type de fichier ne peut pas tre affich en ligne.',
              types: {
                pdf: 'PDF',
                text: 'Texte brut',
                markdown: 'Markdown',
              },
            },
            status: {
              requireEdit: 'Activez le mode dition pour grer le programme.',
              requireEditLecture: 'Activez le mode dition pour mettre  jour les dtails.',
              curriculumSaved: 'Syllabus updated.',
              curriculumSaveFailed: 'Unable to update the syllabus.',
              curriculumLoadFailed: 'Impossible de charger le plan de cours.',
              classCreated: 'Cours cr.',
              classRemoved: 'Cours supprim.',
              moduleCreated: 'Module cr.',
              moduleRemoved: 'Module supprim.',
              lectureCreated: 'Leon cre.',
              lectureRemoved: 'Leon supprime.',
              lectureUpdated: 'Leon mise  jour.',
              lectureTitleRequired: 'Le titre de la leon est requis.',
              createLectureRequirements: 'Slectionnez un module et saisissez un titre.',
              slidesProcessed: 'Diapositives converties en archive Markdown avec images.',
              slidesUploaded: 'Diapositives importes. Les PDF peuvent tre traits pour gnrer larchive Markdown.',
              slidesUploadRequired:
                'Importez un PDF avant de traiter les diapositives. Les autres documents sont conservs tels quels.',
              slidePreviewFailed:
                'Impossible de prparer laperu des diapositives. Vrifiez que le fichier est un PDF et ressayez.',
              processingSlides: 'Traitement des diapositives',
              audioProcessingQueued: 'Audio tlvers. Le mastering se poursuit en arrire-plan.',
              assetUploaded: 'Ressource importe avec succs.',
              assetRemoved: 'Ressource supprime.',
              transcriptionPreparing: '====> Prparation de la transcription',
              transcriptionCompleted: 'Transcription termine.',
              processing: 'Traitement',
              storageLoadFailed: 'Impossible de charger le contenu du stockage.',
              storageUsageFailed: 'Impossible de charger lutilisation du stockage.',
              storagePurged: 'Audios traits supprims.',
              storagePurgeFailed: 'Impossible de supprimer les audios traits.',
              storageDeleted: 'lment de stockage supprim.',
              storageDeleteFailed: 'Impossible de supprimer llment de stockage.',
              storageDownloadReady: 'Tlchargement prt.',
              storageDownloadFailed: 'Impossible de prparer le tlchargement.',
              storageDownloadNone: 'Slectionnez au moins un lment.',
              storageRepairing: 'Analyse du stockage  la recherche de fichiers temporaires',
              storageRepairComplete:
                'Rparation termine. {{count}} {{itemWord}} supprims pour {{freed}} librs.',
              storageRepairNoChanges: 'Rparation termine. Aucun lment temporaire dtect.',
              storageRepairFailed: 'Impossible de rparer le stockage.',
              gpuChecking: '====> Vrification de la compatibilit GPU Whisper',
              gpuConfirmed: 'Compatibilit GPU Whisper confirme.',
              gpuUnavailable: 'GPU indisponible sur cette plateforme.',
              gpuUnsupported: 'GPU Whisper nest pas pris en charge sur cette plateforme.',
              gpuNotAvailable: 'Lacclration GPU nest pas disponible sur cette plateforme.',
              updateStarted: 'Mise  jour lance.',
              updateRunning: 'Mise  jour en cours. Laissez cette fentre ouverte.',
              updateCompleted: 'Mise  jour termine avec succs.',
              updateFailed: 'chec de la mise  jour. Consultez le journal pour plus de dtails.',
              updateConflict: 'Une mise  jour est dj en cours.',
              shuttingDown: 'Fermeture de lapplication',
              settingsSaved: 'Paramtres enregistrs.',
              gpuFallback: 'Bascule vers le modle {{model}}.',
              lectureReordered: 'Lordre des cours a t mis  jour.',
              exporting: 'Prparation de larchive',
              exportReady: 'Archive prte au tlchargement.',
              exportFailed: 'Impossible de crer larchive.',
              importing: 'Importation de larchive',
              importSuccess: '{{count}} cours imports.',
              importNoChanges: 'Archive importe (aucun nouveau cours).',
            },
            counts: {
              module: { one: 'module', other: 'modules' },
              lecture: { one: 'leon', other: 'leons' },
              task: { one: 'tche', other: 'tches' },
              item: { one: 'lment', other: 'lments' },
            },
          },
        };

        const DEFAULT_LANGUAGE = 'en';

        function normalizeServerPath(value) {
          if (typeof value !== 'string') {
            return null;
          }
          const sentinel = '__LECTURE_TOOLS_ROOT_PATH__';
          if (value === sentinel) {
            return null;
          }
          let normalized = value.trim();
          if (!normalized || normalized === '/') {
            return '';
          }
          if (!normalized.startsWith('/')) {
            normalized = `/${normalized}`;
          }
          return normalized.replace(/\/+$/, '') || '';
        }

        const BASE_PATH = (() => {
          const serverPath = normalizeServerPath(
            window.__LECTURE_TOOLS_SERVER_ROOT_PATH__,
          );
          if (serverPath !== null) {
            return serverPath;
          }
          const { pathname } = window.location;
          if (!pathname || pathname === '/' || pathname === '/index.html') {
            return '';
          }
          const withoutIndex = pathname.replace(/\/index\.html?$/, '');
          const trimmed = withoutIndex.endsWith('/')
            ? withoutIndex.slice(0, -1)
            : withoutIndex;
          return trimmed === '/' ? '' : trimmed;
        })();

        window.__LECTURE_TOOLS_BASE_PATH__ = BASE_PATH;

        function resolveAppUrl(target) {
          if (!target || typeof target !== 'string') {
            return target;
          }
          if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(target) || target.startsWith('//')) {
            return target;
          }
          if (target.startsWith('#') || target.startsWith('?')) {
            return target;
          }
          const normalized = target.startsWith('/') ? target : `/${target}`;
          if (!BASE_PATH) {
            return normalized;
          }
          if (normalized === '/') {
            return BASE_PATH || '/';
          }
          return `${BASE_PATH}${normalized}`;
        }

        function resolveTranslation(locale, key) {
          if (!locale || !key) {
            return undefined;
          }
          const segments = key.split('.');
          let value = locale;
          for (const segment of segments) {
            if (value && Object.prototype.hasOwnProperty.call(value, segment)) {
              value = value[segment];
            } else {
              return undefined;
            }
          }
          return typeof value === 'string' || (typeof value === 'object' && value !== null)
            ? value
            : undefined;
        }

        function formatTemplate(template, params) {
          if (!params) {
            return template;
          }
          return template.replace(/\{\{(.*?)\}\}/g, (match, name) => {
            const key = String(name).trim();
            return Object.prototype.hasOwnProperty.call(params, key)
              ? String(params[key])
              : match;
          });
        }

        function getLocale(language) {
          return translations[language] ?? translations[DEFAULT_LANGUAGE];
        }

        let currentLanguage = DEFAULT_LANGUAGE;

        function t(key, params = undefined) {
          if (!key) {
            return '';
          }
          const locale = getLocale(currentLanguage);
          const fallback = translations[DEFAULT_LANGUAGE];
          const template =
            resolveTranslation(locale, key) ?? resolveTranslation(fallback, key) ?? key;
          return formatTemplate(template, params);
        }

        const pluralRules = {
          en: new Intl.PluralRules('en'),
          zh: new Intl.PluralRules('zh'),
          es: new Intl.PluralRules('es'),
          fr: new Intl.PluralRules('fr'),
        };

        function pluralize(language, key, count) {
          const locale = getLocale(language);
          const fallback = translations[DEFAULT_LANGUAGE];
          const rule = (pluralRules[language] ?? pluralRules[DEFAULT_LANGUAGE]).select(
            Number(count),
          );
          const target = resolveTranslation(locale, key);
          const fallbackTarget = resolveTranslation(fallback, key);
          if (target && typeof target === 'string') {
            return target;
          }
          if (target && typeof target === 'object' && target !== null) {
            return target[rule] ?? target.other ?? target.one ?? String(count);
          }
          if (fallbackTarget && typeof fallbackTarget === 'object' && fallbackTarget !== null) {
            return (
              fallbackTarget[rule] ??
              fallbackTarget.other ??
              fallbackTarget.one ??
              String(count)
            );
          }
          return String(count);
        }

        let activeSlideRangeDialog = null;

        function applyTranslations(language) {
          currentLanguage = language && translations[language] ? language : DEFAULT_LANGUAGE;
          const locale = getLocale(currentLanguage);
          const fallback = translations[DEFAULT_LANGUAGE];
          document.documentElement.lang = currentLanguage;

          document.querySelectorAll('[data-i18n]').forEach((element) => {
            const key = element.getAttribute('data-i18n');
            if (!key) {
              return;
            }
            const attr = element.getAttribute('data-i18n-attr');
            const template = resolveTranslation(locale, key) ?? resolveTranslation(fallback, key);
            if (typeof template !== 'string') {
              return;
            }
            if (attr) {
              attr.split(',').forEach((attributeName) => {
                const name = attributeName.trim();
                if (name) {
                  element.setAttribute(name, formatTemplate(template, {}));
                }
              });
            } else {
              element.textContent = formatTemplate(template, {});
            }
          });

          const titleTranslation = resolveTranslation(locale, 'document.title') ??
            resolveTranslation(fallback, 'document.title');
          if (typeof titleTranslation === 'string') {
            document.title = titleTranslation;
          }

          if (activeSlideRangeDialog) {
            activeSlideRangeDialog.updateTexts();
            activeSlideRangeDialog.updateRangeSummary();
          }

          renderTasks();
          renderSystemUpdate();
          if (state.selectedLectureDetail) {
            renderAssets(state.selectedLectureDetail.lecture);
          }
          updateTaskLectureOptions();
          renderMiniConsole();
        }

        const DISPLAY_MODE_CHOICES = new Set(['system', 'bright', 'dark']);
        const THEME_CHOICES = new Set([
          'vibrant',
          'serene',
          'noir',
          'solar',
          'cyber',
          'pastel',
          'obsidian',
          'ethereal',
        ]);
        const THEME_ALIASES = new Map([
          ['bright-vibrant', 'vibrant'],
          ['bright-serene', 'serene'],
          ['bright-kawaii', 'pastel'],
          ['dark-cool', 'vibrant'],
          ['dark-aurora', 'serene'],
          ['dark-midnight', 'obsidian'],
          ['light', 'vibrant'],
          ['dark', 'obsidian'],
        ]);
        const DISPLAY_MODE_ALIASES = new Map([
          ['light', 'bright'],
          ['bright', 'bright'],
          ['dark', 'dark'],
          ['night', 'dark'],
        ]);
        const EFFECTS_CHOICES = new Set(['none', 'low', 'mid', 'high']);
        const EFFECTS_ALIASES = new Map([
          ['medium', 'mid'],
          ['default', 'mid'],
          ['off', 'none'],
          ['disable', 'none'],
          ['disabled', 'none'],
          ['no', 'none'],
          ['no-effects', 'none'],
          ['zero', 'none'],
          ['flat', 'none'],
        ]);
        const LEGACY_THEME_TO_MODE = new Map([
          ['bright-vibrant', 'bright'],
          ['bright-serene', 'bright'],
          ['bright-kawaii', 'bright'],
          ['dark-cool', 'dark'],
          ['dark-aurora', 'dark'],
          ['dark-midnight', 'dark'],
          ['light', 'bright'],
          ['dark', 'dark'],
        ]);
        const DEFAULT_DISPLAY_MODE = 'system';
        const DEFAULT_THEME = 'vibrant';
        const DEFAULT_VISUAL_EFFECTS = 'mid';
        const DEFAULT_CLOUD_SERVER_URL = 'http://localhost:8000';
        const VIEW_SEQUENCE = ['details', 'tasks', 'create', 'storage', 'settings'];
        const WHISPER_MODEL_CHOICES = new Set([
          'tiny',
          'base',
          'small',
          'medium',
          'large',
          'gpu',
        ]);
        const GPU_MODEL = 'gpu';
        const DEFAULT_WHISPER_MODEL = 'base';
        const SLIDE_DPI_CHOICES = new Set(['150', '200', '300', '400', '600']);
        const DEFAULT_SLIDE_DPI = '200';
        const LANGUAGE_CHOICES = new Set(['en', 'zh', 'es', 'fr']);
        const DEBUG_POLL_INTERVAL_MS = 2000;
        const MAX_DEBUG_LOG_ENTRIES = 500;
        const MAX_SERVER_STREAM_ENTRIES = 20;
        const SERVER_LOG_CATEGORY = 'server';
        const UPDATE_POLL_INTERVAL_MS = 3000;

        function getPendingSlideUploadCount(lecture) {
          if (!lecture || typeof lecture !== 'object') {
            return 0;
          }
          const count = Number(lecture.raw_slide_file_count);
          if (Number.isFinite(count) && count > 0) {
            return count;
          }
          return 0;
        }

        const BULK_PROCESS_OPERATIONS = [
          {
            key: 'slide_merge',
            operation: 'slide_merge',
            labelKey: 'tasks.form.operation.slideMerge',
            isAvailable(lecture) {
              return getPendingSlideUploadCount(lecture) > 0;
            },
            isCompleted(lecture) {
              return Boolean(lecture?.slide_path);
            },
          },
          {
            key: 'transcription',
            operation: 'transcription',
            labelKey: 'tasks.form.operation.transcription',
            isAvailable(lecture) {
              if (!lecture || typeof lecture !== 'object') {
                return false;
              }
              return Boolean(lecture.audio_path || lecture.processed_audio_path);
            },
            isCompleted(lecture) {
              return Boolean(lecture?.transcript_path);
            },
            buildOptions(_lecture, settings) {
              const preferred = normalizeWhisperModel(
                settings?.whisper_model_requested || settings?.whisper_model || DEFAULT_WHISPER_MODEL,
              );
              return { model: preferred };
            },
          },
          {
            key: 'slides',
            operation: 'slide_bundle',
            labelKey: 'tasks.form.operation.slideBundle',
            isAvailable(lecture) {
              return Boolean(lecture?.slide_path) || getPendingSlideUploadCount(lecture) > 0;
            },
            isCompleted(lecture) {
              return Boolean(lecture?.slide_image_dir);
            },
          },
        ];

        const BULK_DOWNLOAD_ASSETS = [
          {
            key: 'audio',
            labelKey: 'tasks.bulkDownload.assets.audio',
            resolvePath(lecture) {
              if (!lecture || typeof lecture !== 'object') {
                return null;
              }
              return lecture.processed_audio_path || lecture.audio_path || null;
            },
          },
          {
            key: 'txt',
            labelKey: 'tasks.bulkDownload.assets.txt',
            resolvePath(lecture) {
              return lecture?.transcript_path || null;
            },
          },
          {
            key: 'pdf',
            labelKey: 'tasks.bulkDownload.assets.pdf',
            resolvePath(lecture) {
              return lecture?.slide_path || null;
            },
          },
          {
            key: 'md',
            labelKey: 'tasks.bulkDownload.assets.md',
            resolvePath(lecture) {
              return lecture?.notes_path || null;
            },
          },
          {
            key: 'zip',
            labelKey: 'tasks.bulkDownload.assets.zip',
            resolvePath(lecture) {
              return lecture?.slide_image_dir || null;
            },
          },
        ];

        const BULK_PROCESS_OPERATION_PRIORITY = new Map([
          ['slide_merge', 0],
          ['transcription', 1],
          ['slide_bundle', 2],
        ]);

        function normalizeDisplayMode(value, themeHint = null) {
          if (typeof value === 'string') {
            const trimmed = value.trim().toLowerCase();
            if (DISPLAY_MODE_CHOICES.has(trimmed)) {
              return trimmed;
            }
            if (DISPLAY_MODE_ALIASES.has(trimmed)) {
              return DISPLAY_MODE_ALIASES.get(trimmed) || DEFAULT_DISPLAY_MODE;
            }
          }
          if (typeof themeHint === 'string') {
            const mapped = LEGACY_THEME_TO_MODE.get(themeHint.trim().toLowerCase());
            if (mapped) {
              return mapped;
            }
          }
          return DEFAULT_DISPLAY_MODE;
        }

        function normalizeTheme(value) {
          if (typeof value === 'string') {
            const trimmed = value.trim().toLowerCase();
            if (THEME_CHOICES.has(trimmed)) {
              return trimmed;
            }
            if (THEME_ALIASES.has(trimmed)) {
              return THEME_ALIASES.get(trimmed) || DEFAULT_THEME;
            }
          }
          return DEFAULT_THEME;
        }

        function normalizeVisualEffects(value) {
          if (typeof value === 'string') {
            const trimmed = value.trim().toLowerCase();
            if (EFFECTS_CHOICES.has(trimmed)) {
              return trimmed;
            }
            if (EFFECTS_ALIASES.has(trimmed)) {
              return EFFECTS_ALIASES.get(trimmed) || DEFAULT_VISUAL_EFFECTS;
            }
          }
          return DEFAULT_VISUAL_EFFECTS;
        }

        function normalizeWhisperModel(value) {
          const candidate =
            typeof value === 'string' ? value.trim() : String(value ?? '');
          return WHISPER_MODEL_CHOICES.has(candidate)
            ? candidate
            : DEFAULT_WHISPER_MODEL;
        }

        function normalizeSlideDpi(value) {
          let candidate;
          if (typeof value === 'number' && Number.isFinite(value)) {
            candidate = String(Math.trunc(value));
          } else if (typeof value === 'string') {
            candidate = value.trim();
          } else {
            candidate = String(value ?? '');
          }
          return SLIDE_DPI_CHOICES.has(candidate) ? candidate : DEFAULT_SLIDE_DPI;
        }

        function normalizeLanguage(value) {
          if (typeof value === 'string') {
            const trimmed = value.trim().toLowerCase();
            return LANGUAGE_CHOICES.has(trimmed) ? trimmed : DEFAULT_LANGUAGE;
          }
          return DEFAULT_LANGUAGE;
        }

        function normalizeCloudServerUrl(value) {
          if (typeof value !== 'string') {
            return DEFAULT_CLOUD_SERVER_URL;
          }
          let trimmed = value.trim();
          if (!trimmed) {
            return DEFAULT_CLOUD_SERVER_URL;
          }
          if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(trimmed)) {
            trimmed = `http://${trimmed}`;
          }
          return trimmed.replace(/\/+$/, '');
        }

        const state = {
          classes: [],
          stats: {},
          query: '',
          selectedLectureId: null,
          selectedLectureDetail: null,
          buttonMap: new Map(),
          expandedClasses: new Map(),
          expandedModules: new Map(),
          editMode: false,
          activeView: 'details',
          viewDirection: 1,
          settings: null,
          draggingLectureId: null,
          draggingSourceModuleId: null,
          draggedElement: null,
          curriculumEditorIdMap: createCurriculumEditorIdMap(),
          gpuWhisper: {
            supported: false,
            checked: false,
            message: t('settings.whisper.gpu.status'),
            output: '',
            lastChecked: null,
            unavailable: false,
          },
          cloudConnection: {
            enabled: false,
            connected: false,
            url: DEFAULT_CLOUD_SERVER_URL,
            autoConnect: false,
            processingTarget: 'cloud',
            statusKey: 'idle',
          },
          transcriptionProgressTimer: null,
          transcriptionProgressLectureId: null,
          processingProgressTimer: null,
          processingProgressLectureId: null,
          lastProgressMessage: '',
          lastProgressRatio: null,
          miniConsole: {
            entries: [],
            maxEntries: 4,
            sequence: 0,
          },
          storage: {
            usage: null,
            detail: null,
            loading: false,
            overview: null,
            purging: false,
            initialized: false,
            repairing: false,
            repairSummary: null,
            browser: {
              path: '',
              parent: null,
              entries: [],
              loading: false,
              initialized: false,
              deleting: new Set(),
              error: null,
              selected: new Set(),
            },
          },
          tasks: {
            queue: [],
            active: [],
            loading: false,
            timer: null,
          },
          bulkUpload: {
            lastLectureId: null,
            lastType: null,
          },
          bulkProcess: {
            selections: new Map(),
            meta: new Map(),
            checkboxMap: new Map(),
            expandedClasses: new Map(),
            expandedModules: new Map(),
            availableCount: 0,
            lectureCount: 0,
          },
          bulkDownload: {
            selections: new Map(),
            meta: new Map(),
            checkboxMap: new Map(),
            expandedClasses: new Map(),
            expandedModules: new Map(),
            availableCount: 0,
            lectureCount: 0,
          },
          systemUpdate: {
            running: false,
            startedAt: null,
            finishedAt: null,
            success: null,
            exitCode: null,
            error: null,
            log: [],
            pollTimer: null,
          },
          transcribeControls: {
            button: null,
            model: null,
            gpuOption: null,
          },
          viewer: {
            active: false,
            loadId: 0,
            url: null,
            filename: '',
            type: null,
            previousActive: null,
          },
          debug: {
            enabled: false,
            timer: null,
            lastId: 0,
            pending: false,
            autoScroll: true,
            serverEntries: [],
            tasks: [],
            entries: [],
            filters: {
              severity: 'all',
              category: 'all',
              correlationId: '',
              taskId: '',
              query: '',
            },
          },
        };

        const dialogState = {
          active: false,
          uploadActive: false,
          bulkUploadActive: false,
          bulkProcessActive: false,
          bulkDownloadActive: false,
          viewerActive: false,
        };

        function getTranscribeButton() {
          return state.transcribeControls.button;
        }

        function getTranscribeModelSelect() {
          return state.transcribeControls.model;
        }

        function setTranscribeControls(button, model, gpuOption) {
          const current = state.transcribeControls;
          if (current.button && current.button !== button) {
            current.button.removeEventListener('click', handleTranscribeClick);
          }

          if (dom.gpuModelOptions) {
            const existingOption = current.gpuOption;
            if (existingOption && existingOption !== gpuOption) {
              if (dom.gpuModelOptions instanceof Set) {
                dom.gpuModelOptions.delete(existingOption);
              } else if (Array.isArray(dom.gpuModelOptions)) {
                dom.gpuModelOptions = dom.gpuModelOptions.filter(
                  (option) => option !== existingOption,
                );
              }
            }
          }

          state.transcribeControls = {
            button: button || null,
            model: model || null,
            gpuOption: gpuOption || null,
          };

          if (button && current.button !== button) {
            button.addEventListener('click', handleTranscribeClick);
          }

          if (dom.gpuModelOptions && gpuOption) {
            if (dom.gpuModelOptions instanceof Set) {
              dom.gpuModelOptions.add(gpuOption);
            } else if (Array.isArray(dom.gpuModelOptions)) {
              dom.gpuModelOptions.push(gpuOption);
            }
          }

          updateGpuWhisperUI({ ...state.gpuWhisper });
        }

        function setTranscribeButtonDisabled(disabled) {
          const button = getTranscribeButton();
          if (button) {
            button.disabled = Boolean(disabled);
          }
        }

        function setTranscribeModelValue(value) {
          const select = getTranscribeModelSelect();
          if (!select) {
            return;
          }
          select.value = normalizeWhisperModel(value);
        }

        function getTranscribeModelValue() {
          const select = getTranscribeModelSelect();
          if (select && select.value) {
            return normalizeWhisperModel(select.value);
          }
          return state.settings?.whisper_model || DEFAULT_WHISPER_MODEL;
        }

        const dom = {
          stats: document.getElementById('stats'),
          curriculum: document.getElementById('curriculum'),
          curriculumEditorHost: document.getElementById('curriculum-editor-host'),
          curriculumEditor: null,
          search: document.getElementById('search-input'),
          summary: document.getElementById('lecture-summary'),
          editForm: document.getElementById('lecture-edit-form'),
          editName: document.getElementById('edit-lecture-name'),
          editModule: document.getElementById('edit-lecture-module'),
          editDescription: document.getElementById('edit-lecture-description'),
          deleteButton: document.getElementById('delete-lecture'),
          editToggle: document.getElementById('toggle-edit-mode'),
          editBanner: document.getElementById('edit-mode-banner'),
          assetSection: document.getElementById('asset-section'),
          assetList: document.getElementById('asset-list'),
          createForm: document.getElementById('lecture-create-form'),
          createModule: document.getElementById('create-module'),
          createName: document.getElementById('create-name'),
          createDescription: document.getElementById('create-description'),
          createSubmit: document.getElementById('create-submit'),
          viewButtons: Array.from(document.querySelectorAll('.top-bar [data-view]')),
          viewStack: document.getElementById('view-stack'),
          views: {
            details: document.getElementById('view-details'),
            tasks: document.getElementById('view-tasks'),
            create: document.getElementById('view-create'),
            storage: document.getElementById('view-storage'),
            settings: document.getElementById('view-settings'),
          },
          sidebarOverview: document.getElementById('sidebar-overview'),
          miniConsole: {
            container: document.getElementById('mini-console-panel'),
            entries: document.getElementById('mini-console-entries'),
            empty: document.getElementById('mini-console-empty'),
          },
          settingsForm: document.getElementById('settings-form'),
          settingsDisplayMode: document.getElementById('settings-display-mode'),
          settingsTheme: document.getElementById('settings-theme'),
          settingsVisualEffects: document.getElementById('settings-visual-effects'),
          settingsLanguage: document.getElementById('settings-language'),
          settingsWhisperModel: document.getElementById('settings-whisper-model'),
          settingsWhisperCompute: document.getElementById('settings-whisper-compute'),
          settingsWhisperBeam: document.getElementById('settings-whisper-beam'),
          settingsWhisperGpuStatus: document.getElementById('settings-whisper-gpu-status'),
          settingsWhisperGpuTest: document.getElementById('settings-whisper-gpu-test'),
          settingsCloudConnectionEnabled: document.getElementById(
            'settings-cloud-connection-enabled',
          ),
          settingsCloudServerUrl: document.getElementById('settings-cloud-server-url'),
          settingsCloudAutoConnect: document.getElementById('settings-cloud-auto-connect'),
          settingsCloudProcessingTarget: document.getElementById(
            'settings-cloud-processing-target',
          ),
          settingsCloudConnectionStatus: document.getElementById(
            'settings-cloud-connection-status',
          ),
          settingsCloudConnectionTest: document.getElementById(
            'settings-cloud-connection-test',
          ),
          settingsSlideDpi: document.getElementById('settings-slide-dpi'),
          settingsSlideForceOcr: document.getElementById('settings-slide-force-ocr'),
          settingsAudioMastering: document.getElementById('settings-audio-mastering'),
          settingsDebugEnabled: document.getElementById('settings-debug-enabled'),
          settingsExitApp: document.getElementById('settings-exit-app'),
          settingsExport: document.getElementById('settings-export'),
          settingsImport: document.getElementById('settings-import'),
          settingsImportMode: document.getElementById('settings-import-mode'),
          settingsUpdatePassword: document.getElementById('settings-update-password'),
          settingsUpdatePasswordClear: document.getElementById('settings-update-password-clear'),
          settingsUpdatePasswordStatus: document.getElementById('settings-update-password-status'),
          settingsUpdateRun: document.getElementById('settings-update-run'),
          settingsUpdateRefresh: document.getElementById('settings-update-refresh'),
          settingsUpdateStatus: document.getElementById('settings-update-status'),
          settingsUpdateMeta: document.getElementById('settings-update-meta'),
          settingsUpdateLogWrapper: document.getElementById('settings-update-log-wrapper'),
          settingsUpdateLog: document.getElementById('settings-update-log'),
          settingsUpdateLogEmpty: document.getElementById('settings-update-log-empty'),
          gpuModelOptions: new Set(Array.from(document.querySelectorAll('option.gpu-only'))),
          debugPane: document.getElementById('debug-pane'),
          debugLog: document.getElementById('debug-log-window'),
          debugEmpty: document.getElementById('debug-log-empty'),
          debugStatus: document.getElementById('debug-log-status'),
          debugHeartbeat: document.getElementById('debug-heartbeat'),
          debugHeartbeatTrack: document.querySelector('#debug-heartbeat .debug-heartbeat-track'),
          debugStream: document.getElementById('debug-stream-window'),
          debugStreamEntries: document.getElementById('debug-stream-entries'),
          debugStreamEmpty: document.getElementById('debug-stream-empty'),
          debugFilterSeverity: document.getElementById('debug-filter-severity'),
          debugFilterCategory: document.getElementById('debug-filter-category'),
          debugFilterCorrelation: document.getElementById('debug-filter-correlation'),
          debugFilterTask: document.getElementById('debug-filter-task'),
          debugFilterQuery: document.getElementById('debug-filter-query'),
          debugFilterClear: document.getElementById('debug-filter-clear'),
          debugDownloadLog: document.getElementById('debug-download-log'),
            storage: {
              container: document.getElementById('view-storage'),
              path: document.getElementById('storage-path'),
              refresh: document.getElementById('storage-refresh'),
              repair: document.getElementById('storage-repair'),
              downloadSelected: document.getElementById('storage-download-selected'),
              used: document.getElementById('storage-used'),
              available: document.getElementById('storage-available'),
              total: document.getElementById('storage-total'),
              library: document.getElementById('storage-library'),
              loading: document.getElementById('storage-loading'),
              empty: document.getElementById('storage-empty'),
            wrapper: document.getElementById('storage-class-wrapper'),
            list: document.getElementById('storage-class-list'),
            purge: document.getElementById('storage-purge'),
            purgeSummary: document.getElementById('storage-purge-summary'),
            repairSummary: document.getElementById('storage-repair-summary'),
            browser: {
              navRoot: document.getElementById('storage-nav-root'),
              navUp: document.getElementById('storage-nav-up'),
              loading: document.getElementById('storage-browser-loading'),
              empty: document.getElementById('storage-browser-empty'),
              tableWrapper: document.getElementById('storage-browser-table-wrapper'),
              tableBody: document.getElementById('storage-browser-body'),
              selectAll: document.getElementById('storage-select-all'),
            },
          },
          tasks: {
            container: document.getElementById('view-tasks'),
            list: document.getElementById('tasks-list'),
            empty: document.getElementById('tasks-empty'),
            refresh: document.getElementById('tasks-refresh'),
            clearDone: document.getElementById('tasks-clear-done'),
            description: document.getElementById('tasks-description'),
            bulkProcess: document.getElementById('task-bulk-process'),
            bulkUpload: document.getElementById('task-bulk-upload'),
            bulkDownload: document.getElementById('task-bulk-download'),
            bulkInput: document.getElementById('task-bulk-input'),
          },
          dialog: {
            root: document.getElementById('dialog-root'),
            backdrop: document.getElementById('dialog-backdrop'),
            window: document.getElementById('dialog-window'),
            title: document.getElementById('dialog-title'),
            message: document.getElementById('dialog-message'),
            inputWrapper: document.getElementById('dialog-input-wrapper'),
            input: document.getElementById('dialog-input'),
            confirm: document.getElementById('dialog-confirm'),
            cancel: document.getElementById('dialog-cancel'),
          },
          pendingDialog: {
            root: document.getElementById('dialog-pending'),
            message: document.getElementById('dialog-pending-message'),
          },
          slideRangeDialog: {
            root: document.getElementById('slide-range-dialog'),
            backdrop: document.getElementById('slide-range-backdrop'),
            window: document.getElementById('slide-range-window'),
            title: document.getElementById('slide-range-title'),
            description: document.getElementById('slide-range-description'),
            preview: document.getElementById('slide-range-preview'),
            loading: document.getElementById('slide-range-loading'),
            error: document.getElementById('slide-range-error'),
            fallback: document.getElementById('slide-range-fallback'),
            fallbackFrame: document.getElementById('slide-range-fallback-frame'),
            fallbackLink: document.getElementById('slide-range-fallback-link'),
            fallbackMessage: document.getElementById('slide-range-fallback-message'),
            pages: document.getElementById('slide-range-pages'),
            startLabel: document.getElementById('slide-range-start-label'),
            endLabel: document.getElementById('slide-range-end-label'),
            startInput: document.getElementById('slide-range-start'),
            endInput: document.getElementById('slide-range-end'),
            selectAll: document.getElementById('slide-range-select-all'),
            zoomLabel: document.getElementById('slide-range-zoom-label'),
            zoomValue: document.getElementById('slide-range-zoom-value'),
            zoomSlider: document.getElementById('slide-range-zoom'),
            hint: document.getElementById('slide-range-hint'),
            summary: document.getElementById('slide-range-summary'),
            confirm: document.getElementById('slide-range-confirm'),
            cancel: document.getElementById('slide-range-cancel'),
          },
          viewer: {
            root: document.getElementById('asset-viewer'),
            backdrop: document.getElementById('asset-viewer-backdrop'),
            window: document.getElementById('asset-viewer-window'),
            title: document.getElementById('asset-viewer-title'),
            meta: document.getElementById('asset-viewer-meta'),
            status: document.getElementById('asset-viewer-status'),
            content: document.getElementById('asset-viewer-content'),
            download: document.getElementById('asset-viewer-download'),
            close: document.getElementById('asset-viewer-close'),
          },
          uploadDialog: {
            root: document.getElementById('upload-dialog'),
            backdrop: document.getElementById('upload-dialog-backdrop'),
            window: document.getElementById('upload-dialog-window'),
            title: document.getElementById('upload-dialog-title'),
            description: document.getElementById('upload-dialog-description'),
            dropzone: document.getElementById('upload-dropzone'),
            input: document.getElementById('upload-dialog-input'),
            prompt: document.getElementById('upload-dropzone-prompt'),
            help: document.getElementById('upload-dropzone-help'),
            browse: document.getElementById('upload-browse-button'),
            fileInfo: document.getElementById('upload-file-info'),
            fileName: document.getElementById('upload-file-name'),
            fileList: document.getElementById('upload-file-list'),
            fileSize: document.getElementById('upload-file-size'),
            clear: document.getElementById('upload-clear'),
            progressContainer: document.getElementById('upload-progress-container'),
            progress: document.getElementById('upload-progress'),
            progressFill: document.getElementById('upload-progress-fill'),
            progressText: document.getElementById('upload-progress-text'),
            status: document.getElementById('upload-status-message'),
            cancel: document.getElementById('upload-cancel'),
            confirm: document.getElementById('upload-confirm'),
          },
          bulkUploadDialog: {
            root: document.getElementById('bulk-upload-dialog'),
            backdrop: document.getElementById('bulk-upload-backdrop'),
            window: document.getElementById('bulk-upload-window'),
            title: document.getElementById('bulk-upload-title'),
            subtitle: document.getElementById('bulk-upload-subtitle'),
            fileName: document.getElementById('bulk-upload-file-name'),
            fileSize: document.getElementById('bulk-upload-file-size'),
            lectureLabel: document.getElementById('bulk-upload-lecture-label'),
            lecture: document.getElementById('bulk-upload-lecture'),
            typeLabel: document.getElementById('bulk-upload-type-label'),
            type: document.getElementById('bulk-upload-type'),
            status: document.getElementById('bulk-upload-status'),
            dispose: document.getElementById('bulk-upload-dispose'),
            disposeAll: document.getElementById('bulk-upload-dispose-all'),
            cancel: document.getElementById('bulk-upload-cancel'),
            next: document.getElementById('bulk-upload-next'),
          },
          bulkProcessDialog: {
            root: document.getElementById('bulk-process-dialog'),
            backdrop: document.getElementById('bulk-process-backdrop'),
            window: document.getElementById('bulk-process-window'),
            title: document.getElementById('bulk-process-title'),
            subtitle: document.getElementById('bulk-process-subtitle'),
            content: document.getElementById('bulk-process-content'),
            empty: document.getElementById('bulk-process-empty'),
            status: document.getElementById('bulk-process-status'),
            summary: document.getElementById('bulk-process-summary'),
            selectAll: document.getElementById('bulk-process-select-all'),
            clear: document.getElementById('bulk-process-clear'),
            cancel: document.getElementById('bulk-process-cancel'),
            submit: document.getElementById('bulk-process-submit'),
          },
          bulkDownloadDialog: {
            root: document.getElementById('bulk-download-dialog'),
            backdrop: document.getElementById('bulk-download-backdrop'),
            window: document.getElementById('bulk-download-window'),
            title: document.getElementById('bulk-download-title'),
            subtitle: document.getElementById('bulk-download-subtitle'),
            content: document.getElementById('bulk-download-content'),
            empty: document.getElementById('bulk-download-empty'),
            status: document.getElementById('bulk-download-status'),
            summary: document.getElementById('bulk-download-summary'),
            selectAll: document.getElementById('bulk-download-select-all'),
            clear: document.getElementById('bulk-download-clear'),
            cancel: document.getElementById('bulk-download-cancel'),
            submit: document.getElementById('bulk-download-submit'),
          },
        };

        const DEFAULT_DEBUG_EMPTY_TEXT = dom.debugEmpty
          ? dom.debugEmpty.textContent || ''
          : '';
        const FILTERED_DEBUG_EMPTY_TEXT = 'No log entries match the current filters.';

        if (dom.viewer?.close) {
          dom.viewer.close.addEventListener('click', (event) => {
            event.preventDefault();
            closeAssetViewer();
          });
        }

        if (dom.viewer?.backdrop) {
          dom.viewer.backdrop.addEventListener('click', () => {
            closeAssetViewer();
          });
        }

        if (dom.viewer?.download) {
          dom.viewer.download.addEventListener('click', (event) => {
            event.preventDefault();
            const url = state.viewer.url;
            if (!url) {
              return;
            }
            const anchor = document.createElement('a');
            anchor.href = url;
            anchor.download = state.viewer.filename || 'asset.bin';
            anchor.rel = 'noopener';
            anchor.style.display = 'none';
            document.body.appendChild(anchor);
            anchor.click();
            anchor.remove();
          });
        }

        if (dom.viewer?.window) {
          dom.viewer.window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
              event.preventDefault();
              closeAssetViewer();
            }
          });
        }

        document.addEventListener('keydown', (event) => {
          if (dialogState.viewerActive && event.key === 'Escape') {
            event.preventDefault();
            closeAssetViewer();
          }
        });

        const assetDefinitions = [
          {
            key: 'audio_path',
            labelKey: 'assets.labels.audio',
            accept: 'audio/*,video/mp4,.wav,.mp3,.mp4,.m4a,.aac,.flac,.ogg,.oga,.opus',
            type: 'audio',
          },
          {
            key: 'processed_audio_path',
            labelKey: 'assets.labels.masteredAudio',
            accept: null,
            type: 'processed_audio',
          },
          {
            key: 'slide_path',
            labelKey: 'assets.labels.slides',
            accept:
              'application/pdf,.pdf,.doc,.docx,.txt,.md,text/plain,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            type: 'slides',
          },
          {
            key: 'transcript_path',
            labelKey: 'assets.labels.transcript',
            accept: '.txt,.md,text/plain',
            type: 'transcript',
          },
          {
            key: 'notes_path',
            labelKey: 'assets.labels.notes',
            accept:
              '.txt,.md,.doc,.docx,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            type: 'notes',
          },
          {
            key: 'slide_image_dir',
            labelKey: 'assets.labels.slideBundle',
            accept: null,
            type: 'slide_bundle',
          },
        ];

        const uploadableAssetDefinitions = assetDefinitions.filter(
          (definition) =>
            definition && typeof definition.accept === 'string' && definition.accept.trim().length > 0,
        );

        const bulkUploadAccept = Array.from(
          new Set(
            uploadableAssetDefinitions.flatMap((definition) =>
              definition.accept
                .split(',')
                .map((value) => value.trim())
                .filter(Boolean),
            ),
          ),
        ).join(',');

        if (dom.tasks) {
          if (dom.tasks.bulkInput && bulkUploadAccept) {
            dom.tasks.bulkInput.setAttribute('accept', bulkUploadAccept);
          }
          if (dom.tasks.bulkProcess) {
            dom.tasks.bulkProcess.disabled = true;
          }
          if (dom.tasks.bulkUpload) {
            dom.tasks.bulkUpload.disabled = true;
          }
        }

        if (dom.debugLog) {
          dom.debugLog.addEventListener('scroll', () => {
            const element = dom.debugLog;
            const remaining = element.scrollHeight - element.scrollTop - element.clientHeight;
            state.debug.autoScroll = remaining <= 40;
          });
        }

        if (dom.debugFilterSeverity) {
          dom.debugFilterSeverity.addEventListener('change', (event) => {
            const value = event.target.value || 'all';
            setDebugFilter('severity', value);
          });
        }

        if (dom.debugFilterCategory) {
          dom.debugFilterCategory.addEventListener('change', (event) => {
            const value = event.target.value || 'all';
            setDebugFilter('category', value);
          });
        }

        if (dom.debugFilterCorrelation) {
          dom.debugFilterCorrelation.addEventListener('input', (event) => {
            setDebugFilter('correlationId', event.target.value || '');
          });
        }

        if (dom.debugFilterTask) {
          dom.debugFilterTask.addEventListener('input', (event) => {
            setDebugFilter('taskId', event.target.value || '');
          });
        }

        if (dom.debugFilterQuery) {
          let queryTimer = null;
          dom.debugFilterQuery.addEventListener('input', (event) => {
            window.clearTimeout(queryTimer);
            const value = event.target.value || '';
            queryTimer = window.setTimeout(() => {
              setDebugFilter('query', value);
            }, 120);
          });
        }

        if (dom.debugFilterClear) {
          dom.debugFilterClear.addEventListener('click', () => {
            state.debug.filters = {
              severity: 'all',
              category: 'all',
              correlationId: '',
              taskId: '',
              query: '',
            };
            if (dom.debugFilterSeverity) {
              dom.debugFilterSeverity.value = 'all';
            }
            if (dom.debugFilterCategory) {
              dom.debugFilterCategory.value = 'all';
            }
            if (dom.debugFilterCorrelation) {
              dom.debugFilterCorrelation.value = '';
            }
            if (dom.debugFilterTask) {
              dom.debugFilterTask.value = '';
            }
            if (dom.debugFilterQuery) {
              dom.debugFilterQuery.value = '';
            }
            renderDebugLogs();
          });
        }

        if (dom.debugDownloadLog) {
          dom.debugDownloadLog.addEventListener('click', async () => {
            if (dom.debugDownloadLog.disabled) {
              return;
            }
            dom.debugDownloadLog.disabled = true;
            updateDebugStatus('Preparing log download');
            try {
              const response = await fetch('/api/debug/logs/download', { cache: 'no-store' });
              if (!response.ok) {
                throw new Error(`Request failed with status ${response.status}`);
              }
              const blob = await response.blob();
              const disposition = response.headers.get('Content-Disposition') || '';
              let filename = '';
              const match = disposition.match(/filename\*=UTF-8''([^;]+)|filename="?([^";]+)"?/i);
              if (match) {
                filename = decodeURIComponent(match[1] || match[2] || '').replace(/\r|\n/g, '');
              }
              if (!filename) {
                filename = `debug-${new Date().toISOString().replace(/[:.]/g, '-')}.log`;
              }
              const downloadUrl = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = downloadUrl;
              link.download = filename;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              window.setTimeout(() => {
                URL.revokeObjectURL(downloadUrl);
              }, 1000);
              updateDebugStatus('Debug log download ready');
              window.setTimeout(() => updateDebugStatus(''), 2500);
            } catch (error) {
              console.error('Failed to download debug log', error);
              updateDebugStatus('Unable to download debug log');
            } finally {
              dom.debugDownloadLog.disabled = false;
            }
          });
        }


        function renderStorageUsage() {
          if (!dom.storage) {
            return;
          }
          const usage = state.storage.usage;
          const detail = state.storage.detail;
          if (dom.storage.used) {
            dom.storage.used.textContent =
              usage && typeof usage.used === 'number' ? formatBytes(usage.used) : '';
          }
          if (dom.storage.available) {
            dom.storage.available.textContent =
              usage && typeof usage.free === 'number' ? formatBytes(usage.free) : '';
          }
          if (dom.storage.total) {
            dom.storage.total.textContent =
              usage && typeof usage.total === 'number' ? formatBytes(usage.total) : '';
          }
          if (dom.storage.library) {
            dom.storage.library.textContent =
              detail && typeof detail.size === 'number' ? formatBytes(detail.size) : '';
          }
        }

        function renderStoragePurgeSummary() {
          if (!dom.storage || !dom.storage.purgeSummary) {
            return;
          }
          if (state.storage.loading) {
            dom.storage.purgeSummary.textContent = t('storage.loading');
            return;
          }
          const overview = state.storage.overview;
          const eligible = Number(overview?.eligible_audio_total) || 0;
          if (eligible > 0) {
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', eligible);
            dom.storage.purgeSummary.textContent = t('storage.purge.available', {
              count: eligible,
              lectureWord,
            });
          } else {
            dom.storage.purgeSummary.textContent = t('storage.purge.none');
          }
        }

        function renderStorageRepairSummary() {
          if (!dom.storage || !dom.storage.repairSummary) {
            return;
          }
          const summary = state.storage.repairSummary;
          if (!summary) {
            dom.storage.repairSummary.textContent = t('storage.repair.none');
            return;
          }
          const count = Number(summary.count) || 0;
          const freedBytes = Number(summary.freed) || 0;
          if (count <= 0) {
            dom.storage.repairSummary.textContent = t('storage.repair.none');
            return;
          }
          const itemWord = pluralize(currentLanguage, 'counts.item', count);
          const freedLabel = freedBytes > 0 ? formatBytes(freedBytes) : t('storage.repair.noChange');
          dom.storage.repairSummary.textContent = t('storage.repair.summary', {
            count,
            itemWord,
            freed: freedLabel,
          });
        }

        function renderStoragePurgeControls() {
          if (!dom.storage || !dom.storage.purge) {
            return;
          }
          const overview = state.storage.overview;
          const eligible = Number(overview?.eligible_audio_total) || 0;
          dom.storage.purge.disabled =
            state.storage.loading || state.storage.purging || eligible === 0;
          if (state.storage.purging) {
            dom.storage.purge.textContent = t('storage.purge.working');
          } else {
            dom.storage.purge.textContent = t('storage.actions.purge');
          }
        }

        function renderStorageRepairControls() {
          if (!dom.storage || !dom.storage.repair) {
            return;
          }
          const disabled = state.storage.loading || state.storage.repairing;
          dom.storage.repair.disabled = disabled;
          if (state.storage.repairing) {
            dom.storage.repair.textContent = t('storage.repair.working');
          } else {
            dom.storage.repair.textContent = t('storage.actions.repair');
          }
        }

        function findLectureAssetRecord(lectureId) {
          if (!Number.isFinite(lectureId)) {
            return null;
          }
          for (const klass of state.classes) {
            if (!klass || typeof klass !== 'object') {
              continue;
            }
            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            for (const module of modules) {
              if (!module || typeof module !== 'object') {
                continue;
              }
              const lectures = Array.isArray(module.lectures) ? module.lectures : [];
              for (const lecture of lectures) {
                if (Number(lecture?.id) === lectureId) {
                  return lecture;
                }
              }
            }
          }
          return null;
        }

        function createRevealButton(path, type = 'directory') {
          const normalized = typeof path === 'string' && path.trim().length > 0 ? path : '';
          if (!normalized) {
            return null;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'storage-reveal-button';
          button.textContent = t('common.actions.reveal');
          button.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            revealStoragePath(normalized, { type });
          });
          return button;
        }

        function buildLectureResourceList(lecture) {
          if (!lecture || typeof lecture !== 'object') {
            return null;
          }
          const lectureId = Number(lecture.id);
          if (!Number.isFinite(lectureId)) {
            return null;
          }
          const assetRecord = findLectureAssetRecord(lectureId);
          if (!assetRecord || typeof assetRecord !== 'object') {
            return null;
          }
          const resources = [];
          if (assetRecord.audio_path) {
            resources.push({ label: t('storage.lecture.audio'), path: assetRecord.audio_path, type: 'file' });
          }
          if (assetRecord.processed_audio_path) {
            resources.push({
              label: t('storage.lecture.processedAudio'),
              path: assetRecord.processed_audio_path,
              type: 'file',
            });
          }
          if (assetRecord.transcript_path) {
            resources.push({ label: t('storage.lecture.transcript'), path: assetRecord.transcript_path, type: 'file' });
          }
          if (assetRecord.notes_path) {
            resources.push({ label: t('storage.lecture.notes'), path: assetRecord.notes_path, type: 'file' });
          }
          if (assetRecord.slide_path) {
            resources.push({ label: t('storage.lecture.slides'), path: assetRecord.slide_path, type: 'file' });
          }
          if (!resources.length) {
            return null;
          }
          const list = document.createElement('ul');
          list.className = 'storage-resource-list';
          resources.forEach((resource) => {
            if (!resource.path) {
              return;
            }
            const item = document.createElement('li');
            item.className = 'storage-resource-item';
            const label = document.createElement('span');
            label.className = 'storage-resource-label';
            label.textContent = resource.label;
            item.appendChild(label);
            const button = createRevealButton(resource.path, resource.type);
            if (button) {
              item.appendChild(button);
            }
            list.appendChild(item);
          });
          return list.childElementCount > 0 ? list : null;
        }

        function revealStoragePath(path, options = {}) {
          const rawPath = typeof path === 'string' ? path : '';
          if (!rawPath) {
            showStatus(t('storage.reveal.unavailable'), 'info');
            return;
          }
          let normalized = rawPath.replace(/\\/g, '/').replace(/^\/+/, '').trim();
          if (!normalized) {
            normalized = '';
          }
          const type = options?.type === 'file' ? 'file' : 'directory';
          if (type === 'file') {
            const segments = normalized.split('/').filter(Boolean);
            if (segments.length > 0) {
              segments.pop();
            }
            normalized = segments.join('/');
          }
          void refreshStorage({ includeOverview: false, path: normalized, force: true });
        }

        function renderStorageClasses() {
          if (!dom.storage || !dom.storage.list) {
            return;
          }
          const container = dom.storage.list;
          container.innerHTML = '';
          if (state.storage.loading) {
            return;
          }
          const overview = state.storage.overview;
          const classes = Array.isArray(overview?.classes) ? overview.classes : [];
          classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const listItem = document.createElement('li');
            const classDetails = document.createElement('details');
            classDetails.className = 'storage-class-card';
            classDetails.open = false;

            const classSummary = document.createElement('summary');
            classSummary.className = 'storage-toggle storage-class-summary';

            const header = document.createElement('div');
            header.className = 'storage-class-header';

            const title = document.createElement('h3');
            title.className = 'storage-class-title';
            title.textContent = klass.name || t('storage.unnamedClass');
            header.appendChild(title);

            const classSize = document.createElement('span');
            classSize.className = 'storage-class-size';
            classSize.textContent =
              typeof klass.size === 'number' && klass.size >= 0 ? formatBytes(klass.size) : '';
            header.appendChild(classSize);

            classSummary.appendChild(header);

            const classReveal = createRevealButton(klass.storage_path, 'directory');
            if (classReveal) {
              classSummary.appendChild(classReveal);
            }

            classDetails.appendChild(classSummary);

            const moduleCount = Number(klass.module_count) || 0;
            const lectureCount = Number(klass.lecture_count) || 0;
            const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            const classSummaryParts = [
              t('storage.classes.summary', {
                moduleCount,
                moduleWord,
                lectureCount,
                lectureWord,
              }),
            ];
            const classEligible = Number(klass.eligible_audio_count) || 0;
            if (classEligible > 0) {
              classSummaryParts.push(
                t('storage.purge.readyCount', {
                  count: classEligible,
                  lectureWord: pluralize(currentLanguage, 'counts.lecture', classEligible),
                }),
              );
            }
            const classMastered = Number(klass.processed_audio_count) || 0;
            if (classMastered > 0) {
              classSummaryParts.push(
                t('storage.classes.masteredCount', {
                  count: classMastered,
                  lectureWord: pluralize(currentLanguage, 'counts.lecture', classMastered),
                }),
              );
            }
            const classMeta = document.createElement('p');
            classMeta.className = 'storage-class-meta';
            classMeta.textContent = classSummaryParts.filter(Boolean).join('  ');

            const body = document.createElement('div');
            body.className = 'storage-class-body';
            body.appendChild(classMeta);

            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            if (!modules.length) {
              const empty = document.createElement('p');
              empty.className = 'storage-class-meta';
              empty.textContent = t('storage.classes.empty');
              body.appendChild(empty);
            } else {
              const moduleList = document.createElement('ul');
              moduleList.className = 'storage-module-list';
              modules.forEach((module) => {
                if (!module || typeof module !== 'object') {
                  return;
                }
                const moduleItem = document.createElement('li');
                const moduleDetails = document.createElement('details');
                moduleDetails.className = 'storage-module-card';
                moduleDetails.open = false;

                const moduleSummary = document.createElement('summary');
                moduleSummary.className = 'storage-toggle storage-module-summary';

                const moduleHeader = document.createElement('div');
                moduleHeader.className = 'storage-module-header';

                const moduleTitle = document.createElement('h4');
                moduleTitle.className = 'storage-module-title';
                moduleTitle.textContent = module.name || t('storage.unnamedModule');
                moduleHeader.appendChild(moduleTitle);

                const moduleSize = document.createElement('span');
                moduleSize.className = 'storage-module-size';
                moduleSize.textContent =
                  typeof module.size === 'number' && module.size >= 0
                    ? formatBytes(module.size)
                    : '';
                moduleHeader.appendChild(moduleSize);

                moduleSummary.appendChild(moduleHeader);

                const moduleReveal = createRevealButton(module.storage_path, 'directory');
                if (moduleReveal) {
                  moduleSummary.appendChild(moduleReveal);
                }

                moduleDetails.appendChild(moduleSummary);

                const moduleLectureCount = Number(module.lecture_count) || 0;
                const moduleLectureWord = pluralize(
                  currentLanguage,
                  'counts.lecture',
                  moduleLectureCount,
                );
                const moduleSummaryParts = [
                  t('storage.modules.summary', {
                    lectureCount: moduleLectureCount,
                    lectureWord: moduleLectureWord,
                  }),
                ];
                const moduleEligible = Number(module.eligible_audio_count) || 0;
                if (moduleEligible > 0) {
                  moduleSummaryParts.push(
                    t('storage.purge.readyCount', {
                      count: moduleEligible,
                      lectureWord: pluralize(currentLanguage, 'counts.lecture', moduleEligible),
                    }),
                  );
                }
                const moduleMastered = Number(module.processed_audio_count) || 0;
                if (moduleMastered > 0) {
                  moduleSummaryParts.push(
                    t('storage.modules.masteredCount', {
                      count: moduleMastered,
                      lectureWord: pluralize(currentLanguage, 'counts.lecture', moduleMastered),
                    }),
                  );
                }
                const moduleMeta = document.createElement('p');
                moduleMeta.className = 'storage-module-meta';
                moduleMeta.textContent = moduleSummaryParts.filter(Boolean).join('  ');

                const moduleBody = document.createElement('div');
                moduleBody.className = 'storage-module-body';
                moduleBody.appendChild(moduleMeta);

                const lectures = Array.isArray(module.lectures) ? module.lectures : [];
                if (!lectures.length) {
                  const emptyLecture = document.createElement('p');
                  emptyLecture.className = 'storage-module-meta';
                  emptyLecture.textContent = t('storage.modules.empty');
                  moduleBody.appendChild(emptyLecture);
                } else {
                  const lectureList = document.createElement('ul');
                  lectureList.className = 'storage-lecture-list';
                  lectures.forEach((lecture) => {
                    if (!lecture || typeof lecture !== 'object') {
                      return;
                    }
                    const lectureEntry = document.createElement('li');
                    const lectureDetails = document.createElement('details');
                    lectureDetails.className = 'storage-lecture-item';
                    lectureDetails.open = false;

                    const lectureSummary = document.createElement('summary');
                    lectureSummary.className = 'storage-toggle storage-lecture-summary';

                    const lectureHeader = document.createElement('div');
                    lectureHeader.className = 'storage-lecture-header';

                    const lectureTitle = document.createElement('p');
                    lectureTitle.className = 'storage-lecture-title';
                    lectureTitle.textContent = lecture.name || t('storage.unnamedLecture');
                    lectureHeader.appendChild(lectureTitle);

                    const lectureSize = document.createElement('span');
                    lectureSize.className = 'storage-lecture-size';
                    lectureSize.textContent =
                      typeof lecture.size === 'number' && lecture.size >= 0
                        ? formatBytes(lecture.size)
                        : '';
                    lectureHeader.appendChild(lectureSize);

                    lectureSummary.appendChild(lectureHeader);

                    const lectureReveal = createRevealButton(lecture.storage_path, 'directory');
                    if (lectureReveal) {
                      lectureSummary.appendChild(lectureReveal);
                    }

                    lectureDetails.appendChild(lectureSummary);

                    const lectureMeta = document.createElement('p');
                    lectureMeta.className = 'storage-lecture-meta';
                    const assetLabels = [];
                    if (lecture.has_audio) {
                      assetLabels.push(t('storage.lecture.audio'));
                    }
                    if (lecture.has_processed_audio) {
                      assetLabels.push(t('storage.lecture.processedAudio'));
                    }
                    if (lecture.has_transcript) {
                      assetLabels.push(t('storage.lecture.transcript'));
                    }
                    if (lecture.has_notes) {
                      assetLabels.push(t('storage.lecture.notes'));
                    }
                    if (lecture.has_slides) {
                      assetLabels.push(t('storage.lecture.slides'));
                    }
                    lectureMeta.textContent = assetLabels.length
                      ? assetLabels.join('  ')
                      : t('storage.lecture.empty');

                    const lectureBody = document.createElement('div');
                    lectureBody.className = 'storage-lecture-body';
                    lectureBody.appendChild(lectureMeta);

                    const badgeContainer = document.createElement('div');
                    badgeContainer.className = 'storage-lecture-badges';

                    if (lecture.has_processed_audio) {
                      const processedBadge = document.createElement('span');
                      processedBadge.className = 'storage-lecture-processed';
                      processedBadge.textContent = t('storage.lecture.processedBadge');
                      badgeContainer.appendChild(processedBadge);
                    }

                    if (lecture.eligible_audio) {
                      const eligibleBadge = document.createElement('span');
                      eligibleBadge.className = 'storage-lecture-eligible';
                      eligibleBadge.textContent = t('storage.lecture.eligible');
                      badgeContainer.appendChild(eligibleBadge);
                    }

                    if (badgeContainer.childElementCount > 0) {
                      lectureBody.appendChild(badgeContainer);
                    }

                    const resourceList = buildLectureResourceList(lecture);
                    if (resourceList) {
                      lectureBody.appendChild(resourceList);
                    }

                    lectureDetails.appendChild(lectureBody);
                    lectureEntry.appendChild(lectureDetails);
                    lectureList.appendChild(lectureEntry);
                  });
                  moduleBody.appendChild(lectureList);
                }

                moduleDetails.appendChild(moduleBody);
                moduleItem.appendChild(moduleDetails);
                moduleList.appendChild(moduleItem);
              });
              body.appendChild(moduleList);
            }

            classDetails.appendChild(body);
            listItem.appendChild(classDetails);
            container.appendChild(listItem);
          });
        }

        function getStorageBrowserState() {
          const storageState = state.storage;
          if (!storageState || typeof storageState !== 'object') {
            return {
              path: '',
              parent: null,
              entries: [],
              loading: false,
              initialized: false,
              deleting: new Set(),
              error: null,
            };
          }
          if (!storageState.browser || typeof storageState.browser !== 'object') {
            storageState.browser = {
              path: '',
              parent: null,
              entries: [],
              loading: false,
              initialized: false,
              deleting: new Set(),
              error: null,
            };
          }
          const browserState = storageState.browser;
          if (!(browserState.deleting instanceof Set)) {
            const existing = browserState.deleting;
            browserState.deleting = new Set(
              Array.isArray(existing)
                ? existing
                : existing && typeof existing === 'string'
                ? [existing]
                : [],
            );
          }
          if (!(browserState.selected instanceof Set)) {
            const existingSelected = browserState.selected;
            browserState.selected = new Set(
              Array.isArray(existingSelected)
                ? existingSelected
                : existingSelected && typeof existingSelected === 'string'
                ? [existingSelected]
                : [],
            );
          }
          if (browserState.error !== null && typeof browserState.error !== 'string') {
            browserState.error = null;
          }
          return browserState;
        }

        function renderStorageBrowser() {
          if (!dom.storage || !dom.storage.browser) {
            return;
          }
          const browserState = getStorageBrowserState();
          const pathElement = dom.storage.path;
          if (pathElement) {
            const displayPath = browserState.path ? `/${browserState.path}` : '/';
            pathElement.textContent = displayPath;
            pathElement.setAttribute('title', displayPath);
          }

          const navRoot = dom.storage.browser.navRoot;
          if (navRoot) {
            navRoot.disabled = browserState.loading || !browserState.path;
          }
          const navUp = dom.storage.browser.navUp;
          if (navUp) {
            navUp.disabled = browserState.loading || browserState.parent === null;
          }

          const loadingElement = dom.storage.browser.loading;
          const emptyElement = dom.storage.browser.empty;
          const tableWrapper = dom.storage.browser.tableWrapper;
          const tableBody = dom.storage.browser.tableBody;
          const downloadButton = dom.storage.downloadSelected;
          const selectAllControl = dom.storage.browser.selectAll;

          const isLoading = Boolean(browserState.loading);
          const entries = Array.isArray(browserState.entries) ? browserState.entries : [];
          const hasEntries = entries.length > 0;

          if (loadingElement) {
            loadingElement.hidden = !isLoading;
          }

          if (emptyElement) {
            const defaultMessage = t('storage.browser.empty');
            const message = browserState.error ? browserState.error : defaultMessage;
            emptyElement.textContent = message;
            emptyElement.hidden = isLoading || hasEntries;
          }

          if (tableWrapper) {
            tableWrapper.hidden = isLoading || !hasEntries;
          }

          if (tableBody) {
            tableBody.innerHTML = '';
            let visibleSelectableCount = 0;
            let visibleSelectedCount = 0;
            if (!isLoading && hasEntries) {
              entries.forEach((entry) => {
                if (!entry || typeof entry !== 'object') {
                  return;
                }
                const row = document.createElement('tr');
                const entryPath = typeof entry.path === 'string' ? entry.path : '';
                const entryName = typeof entry.name === 'string' && entry.name
                  ? entry.name
                  : entryPath;
                const isDirectory = Boolean(entry.is_dir);
                const isDeleting = browserState.deleting.has(entryPath);
                const isSelected = browserState.selected.has(entryPath);
                if (isSelected) {
                  row.classList.add('is-selected');
                }
                row.dataset.storagePath = entryPath;
                row.dataset.storageType = isDirectory ? 'directory' : 'file';

                const selectCell = document.createElement('td');
                selectCell.className = 'storage-select-cell';
                if (entryPath) {
                  const checkbox = document.createElement('input');
                  checkbox.type = 'checkbox';
                  checkbox.className = 'storage-select-checkbox';
                  checkbox.dataset.storageSelect = entryPath;
                  checkbox.checked = isSelected;
                  checkbox.disabled = browserState.loading || isDeleting;
                  const labelName = entryName || t('storage.browser.unnamed');
                  checkbox.setAttribute(
                    'aria-label',
                    t('storage.browser.selectAction', { name: labelName }),
                  );
                  selectCell.appendChild(checkbox);
                  visibleSelectableCount += 1;
                  if (isSelected) {
                    visibleSelectedCount += 1;
                  }
                }
                row.appendChild(selectCell);

                const nameCell = document.createElement('td');
                if (isDirectory) {
                  const button = document.createElement('button');
                  button.type = 'button';
                  button.className = 'storage-entry-name';
                  button.dataset.storageAction = 'open';
                  button.dataset.storagePath = entryPath;
                  button.textContent = entryName || t('storage.browser.unnamed');
                  nameCell.appendChild(button);
                } else {
                  const link = document.createElement('a');
                  link.className = 'storage-entry-name';
                  link.href = buildStorageURL(entryPath);
                  link.textContent = entryName || t('storage.browser.unnamed');
                  link.target = '_blank';
                  link.rel = 'noopener noreferrer';
                  nameCell.appendChild(link);
                }
                row.appendChild(nameCell);

                const typeCell = document.createElement('td');
                typeCell.className = 'storage-entry-type';
                typeCell.textContent = isDirectory
                  ? t('storage.browser.directory')
                  : t('storage.browser.file');
                row.appendChild(typeCell);

                const sizeCell = document.createElement('td');
                const sizeValue = Number.isFinite(entry?.size)
                  ? Number(entry.size)
                  : Number(entry?.size);
                if (Number.isFinite(sizeValue) && sizeValue >= 0) {
                  sizeCell.textContent = formatBytes(sizeValue);
                } else {
                  sizeCell.textContent = '';
                }
                row.appendChild(sizeCell);

                const modifiedCell = document.createElement('td');
                const modifiedText = entry?.modified ? formatDate(entry.modified) : '';
                modifiedCell.textContent = modifiedText || '';
                row.appendChild(modifiedCell);

                const actionsCell = document.createElement('td');
                actionsCell.className = 'storage-entry-actions';
                const deleteButton = document.createElement('button');
                deleteButton.type = 'button';
                deleteButton.dataset.storageAction = 'delete';
                deleteButton.dataset.storagePath = entryPath;
                deleteButton.dataset.storageName = entryName || entryPath || '';
                deleteButton.textContent = t('common.actions.delete');
                deleteButton.disabled = !entryPath || browserState.loading || isDeleting;
                actionsCell.appendChild(deleteButton);
                row.appendChild(actionsCell);

                tableBody.appendChild(row);
              });
            }
            if (selectAllControl) {
              selectAllControl.disabled =
                browserState.loading || isLoading || visibleSelectableCount === 0;
              selectAllControl.indeterminate =
                visibleSelectedCount > 0 && visibleSelectedCount < visibleSelectableCount;
              selectAllControl.checked =
                visibleSelectableCount > 0 &&
                visibleSelectedCount === visibleSelectableCount &&
                !selectAllControl.indeterminate;
            }
            if (downloadButton) {
              downloadButton.disabled =
                browserState.loading || isLoading || browserState.selected.size === 0;
            }
          }
        }

        function renderStorage() {
          if (!dom.storage) {
            return;
          }
          const browserState = getStorageBrowserState();
          if (dom.storage.loading) {
            const showLoading = Boolean(
              state.storage.loading || (!browserState.initialized && browserState.loading),
            );
            dom.storage.loading.hidden = !showLoading;
          }
          const overview = state.storage.overview;
          const classes = Array.isArray(overview?.classes) ? overview.classes : [];
          if (dom.storage.empty) {
            dom.storage.empty.hidden = state.storage.loading || classes.length > 0;
          }
          if (dom.storage.wrapper) {
            dom.storage.wrapper.hidden = state.storage.loading || classes.length === 0;
          }
          renderStorageBrowser();
          renderStorageUsage();
          renderStoragePurgeSummary();
          renderStoragePurgeControls();
          renderStorageRepairSummary();
          renderStorageRepairControls();
          renderStorageClasses();
        }

        function parseIsoDate(value) {
          if (typeof value !== 'string' || !value) {
            return null;
          }
          const date = new Date(value);
          if (Number.isNaN(date.getTime())) {
            return null;
          }
          return date;
        }

        function formatDateTime(date) {
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
            return '';
          }
          try {
            const locale = getLocale(currentLanguage);
            return new Intl.DateTimeFormat(locale, {
              dateStyle: 'medium',
              timeStyle: 'medium',
            }).format(date);
          } catch (error) {
            return date.toLocaleString();
          }
        }

        function startUpdatePolling() {
          if (state.systemUpdate.pollTimer) {
            return;
          }
          state.systemUpdate.pollTimer = window.setInterval(() => {
            void fetchSystemUpdateStatus();
          }, UPDATE_POLL_INTERVAL_MS);
        }

        function stopUpdatePolling() {
          if (state.systemUpdate.pollTimer) {
            window.clearInterval(state.systemUpdate.pollTimer);
            state.systemUpdate.pollTimer = null;
          }
        }

        function renderSystemUpdate() {
          if (!dom.settingsUpdateStatus) {
            return;
          }
          const update = state.systemUpdate;
          const statusKey = update.running
            ? 'running'
            : update.success === true
            ? 'success'
            : update.success === false
            ? 'failure'
            : 'idle';
          dom.settingsUpdateStatus.textContent = t(`settings.update.status.${statusKey}`);

          if (dom.settingsUpdateMeta) {
            const parts = [];
            if (update.startedAt) {
              parts.push(t('settings.update.startedAt', { time: formatDateTime(update.startedAt) }));
            }
            if (update.finishedAt && !update.running) {
              parts.push(t('settings.update.finishedAt', { time: formatDateTime(update.finishedAt) }));
            }
            if (typeof update.exitCode === 'number' && Number.isFinite(update.exitCode)) {
              parts.push(t('settings.update.exitCode', { code: update.exitCode }));
            }
            if (update.error && !update.running) {
              parts.push(update.error);
            }
            if (parts.length > 0) {
              dom.settingsUpdateMeta.textContent = parts.join(' ');
              dom.settingsUpdateMeta.hidden = false;
            } else {
              dom.settingsUpdateMeta.textContent = '';
              dom.settingsUpdateMeta.hidden = true;
            }
          }

          if (dom.settingsUpdateRun) {
            dom.settingsUpdateRun.disabled = update.running;
          }
          if (dom.settingsUpdateRefresh) {
            dom.settingsUpdateRefresh.disabled = update.running;
          }

          if (dom.settingsUpdateLogWrapper) {
            const entries = Array.isArray(update.log) ? update.log : [];
            const hasEntries = entries.length > 0;
            const shouldShowWrapper = update.running || hasEntries;
            dom.settingsUpdateLogWrapper.hidden = !shouldShowWrapper;
            if (dom.settingsUpdateLog) {
              if (hasEntries) {
                const formatted = entries
                  .map((entry) => {
                    const stamp = parseIsoDate(entry.timestamp);
                    const prefix = stamp ? `[${formatDateTime(stamp)}] ` : '';
                    const message = typeof entry.message === 'string' ? entry.message : '';
                    return `${prefix}${message}`.trimEnd();
                  })
                  .join('\n');
                dom.settingsUpdateLog.textContent = formatted;
                dom.settingsUpdateLog.hidden = false;
                dom.settingsUpdateLog.scrollTop = dom.settingsUpdateLog.scrollHeight;
              } else {
                dom.settingsUpdateLog.textContent = '';
                dom.settingsUpdateLog.hidden = true;
              }
            }
            if (dom.settingsUpdateLogEmpty) {
              dom.settingsUpdateLogEmpty.hidden = hasEntries;
            }
          }
        }

        function applySystemUpdate(update) {
          if (!update || typeof update !== 'object') {
            return;
          }
          const previousRunning = state.systemUpdate.running;
          state.systemUpdate.running = Boolean(update.running);
          state.systemUpdate.startedAt = parseIsoDate(update.started_at);
          state.systemUpdate.finishedAt = parseIsoDate(update.finished_at);
          state.systemUpdate.success =
            typeof update.success === 'boolean' ? update.success : null;
          state.systemUpdate.exitCode =
            typeof update.exit_code === 'number' && Number.isFinite(update.exit_code)
              ? update.exit_code
              : null;
          state.systemUpdate.error =
            typeof update.error === 'string' && update.error ? update.error : null;
          state.systemUpdate.log = Array.isArray(update.log) ? update.log : [];
          renderSystemUpdate();
          if (state.systemUpdate.running) {
            if (!previousRunning) {
              showStatus(t('status.updateRunning'), 'info', { persist: true });
            }
            startUpdatePolling();
          } else {
            stopUpdatePolling();
            if (previousRunning) {
              if (state.systemUpdate.success) {
                showStatus(t('status.updateCompleted'), 'success');
              } else if (state.systemUpdate.success === false) {
                const message = state.systemUpdate.error || t('status.updateFailed');
                showStatus(message, 'error');
              }
            }
          }
        }

        async function fetchSystemUpdateStatus() {
          try {
            const payload = await request('/api/system/update');
            applySystemUpdate(payload?.update);
          } catch (error) {
            if (state.systemUpdate.running) {
              const message = error instanceof Error ? error.message : String(error);
              showStatus(message || t('status.updateFailed'), 'error');
              stopUpdatePolling();
            }
          } finally {
            renderSystemUpdate();
          }
        }

        async function triggerSystemUpdate() {
          if (!dom.settingsUpdateRun) {
            return;
          }
          if (dom.settingsUpdateRun.disabled) {
            return;
          }
          showStatus(t('status.updateStarted'), 'info');
          dom.settingsUpdateRun.disabled = true;
          if (dom.settingsUpdateRefresh) {
            dom.settingsUpdateRefresh.disabled = true;
          }
          try {
            const payload = await request('/api/system/update', { method: 'POST' });
            applySystemUpdate(payload?.update);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            if (typeof message === 'string' && message.toLowerCase().includes('already')) {
              showStatus(t('status.updateConflict'), 'info');
            } else {
              showStatus(message || t('status.updateFailed'), 'error');
            }
            await fetchSystemUpdateStatus();
          } finally {
            renderSystemUpdate();
          }
        }

        async function loadStorageBrowser(path, options = {}) {
          const browserState = getStorageBrowserState();
          const previousPath = browserState.path || '';
          const targetPath = typeof path === 'string' ? path : previousPath;
          if (targetPath !== previousPath) {
            browserState.selected.clear();
          }
          try {
            const payload = await request(buildStorageListUrl(targetPath));
            const entries = Array.isArray(payload?.entries) ? payload.entries : [];
            browserState.path = typeof payload?.path === 'string' ? payload.path : '';
            if (typeof payload?.parent === 'string') {
              browserState.parent = payload.parent;
            } else if (payload?.parent === null) {
              browserState.parent = null;
            } else {
              browserState.parent = null;
            }
            browserState.entries = entries;
            browserState.error = null;
            browserState.deleting.clear();
            const validPaths = new Set(
              entries
                .map((entry) => (typeof entry?.path === 'string' ? entry.path : ''))
                .filter((value) => typeof value === 'string' && value),
            );
            Array.from(browserState.selected).forEach((value) => {
              if (!validPaths.has(value)) {
                browserState.selected.delete(value);
              }
            });
            browserState.initialized = true;
            return browserState.path;
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            browserState.error = message || t('status.storageLoadFailed');
            browserState.entries = [];
            browserState.parent = null;
            if (typeof targetPath === 'string') {
              browserState.path = targetPath;
            }
            if (!options?.silent) {
              showStatus(browserState.error, 'error');
            }
            browserState.initialized = true;
            return browserState.path;
          }
        }

        async function refreshStorage(options = {}) {
          if (!dom.storage) {
            return;
          }
          const includeOverview = options.includeOverview !== false;
          const force = options.force === true;
          const browserState = getStorageBrowserState();
          if (!force && (state.storage.loading || browserState.loading)) {
            return;
          }
          const targetPath =
            typeof options.path === 'string' ? options.path : browserState.path || '';

          if (includeOverview) {
            state.storage.loading = true;
          }
          browserState.loading = true;
          renderStorage();

          if (includeOverview) {
            try {
              const overviewPayload = await request('/api/storage/overview');
              state.storage.overview = overviewPayload ?? null;
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              showStatus(message || t('status.storageLoadFailed'), 'error');
              state.storage.overview = null;
            }
            try {
              const usagePayload = await request('/api/storage/usage');
              state.storage.usage = usagePayload?.usage ?? usagePayload ?? null;
              state.storage.detail = usagePayload?.storage ?? null;
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              showStatus(message || t('status.storageUsageFailed'), 'error');
              state.storage.detail = null;
            }
            state.storage.initialized = true;
            state.storage.loading = false;
          }

          await loadStorageBrowser(targetPath, { silent: options.silent === true });
          browserState.loading = false;
          browserState.initialized = true;
          renderStorage();
        }

        async function handleStorageEntryDeletion(path, name) {
          const browserState = getStorageBrowserState();
          const targetPath = typeof path === 'string' ? path : '';
          if (!targetPath) {
            return;
          }
          const fallbackName = targetPath.split('/').pop() || targetPath;
          const displayName = name || fallbackName || t('storage.browser.unnamed');
          const confirmed = await confirmDialog({
            title: t('storage.dialogs.deleteTitle'),
            message: t('storage.dialogs.deleteMessage', { name: displayName }),
            confirmText: t('storage.dialogs.deleteConfirm'),
            cancelText: t('dialog.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          browserState.deleting.add(targetPath);
          browserState.selected.delete(targetPath);
          renderStorageBrowser();
          try {
            await request('/api/storage', {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: targetPath }),
            });
            browserState.deleting.delete(targetPath);
            showStatus(t('status.storageDeleted'), 'success');
            const currentPath = browserState.path || '';
            await refreshStorage({ includeOverview: true, path: currentPath, force: true });
          } catch (error) {
            browserState.deleting.delete(targetPath);
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message || t('status.storageDeleteFailed'), 'error');
            renderStorageBrowser();
          }
        }

        async function handleStorageBrowserAction(event) {
          const target = event.target;
          if (!(target instanceof Element)) {
            return;
          }
          const actionElement = target.closest('[data-storage-action]');
          if (!actionElement) {
            return;
          }
          const action = actionElement.dataset.storageAction;
          const path = actionElement.dataset.storagePath || '';
          if (action === 'open') {
            event.preventDefault();
            if (!path) {
              return;
            }
            await refreshStorage({ includeOverview: false, path, force: true });
            return;
          }
          if (action === 'delete') {
            event.preventDefault();
            if (!path) {
              return;
            }
            const name = actionElement.dataset.storageName || '';
            await handleStorageEntryDeletion(path, name);
          }
        }

        function handleStorageSelectionChange(event) {
          const target = event.target;
          if (!(target instanceof HTMLInputElement)) {
            return;
          }
          if (target.type !== 'checkbox') {
            return;
          }
          const entryPath = target.dataset.storageSelect || '';
          if (!entryPath) {
            return;
          }
          const browserState = getStorageBrowserState();
          if (target.checked) {
            browserState.selected.add(entryPath);
          } else {
            browserState.selected.delete(entryPath);
          }
          renderStorageBrowser();
        }

        function handleStorageSelectAll(event) {
          const target = event.target;
          if (!(target instanceof HTMLInputElement)) {
            return;
          }
          if (target.disabled) {
            return;
          }
          const browserState = getStorageBrowserState();
          browserState.selected.clear();
          if (target.checked) {
            const entries = Array.isArray(browserState.entries) ? browserState.entries : [];
            entries.forEach((entry) => {
              if (!entry || typeof entry !== 'object') {
                return;
              }
              const entryPath = typeof entry.path === 'string' ? entry.path : '';
              if (entryPath) {
                browserState.selected.add(entryPath);
              }
            });
          }
          renderStorageBrowser();
        }

        async function handleStorageDownloadSelected() {
          if (!dom.storage || !dom.storage.downloadSelected) {
            return;
          }
          const browserState = getStorageBrowserState();
          const selected = Array.from(browserState.selected);
          if (selected.length === 0) {
            showStatus(t('status.storageDownloadNone'), 'info');
            return;
          }
          dom.storage.downloadSelected.disabled = true;
          let success = false;
          try {
            const response = await request('/api/storage/download', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ paths: selected }),
            });
            const archive = response?.archive;
            if (!archive || typeof archive.path !== 'string' || !archive.path) {
              throw new Error(t('status.storageDownloadFailed'));
            }
            const downloadUrl = buildStorageURL(archive.path);
            const fileName =
              typeof archive.filename === 'string' && archive.filename
                ? archive.filename
                : 'storage-selection.zip';
            const anchor = document.createElement('a');
            anchor.href = downloadUrl;
            anchor.download = fileName;
            anchor.rel = 'noopener noreferrer';
            document.body.appendChild(anchor);
            anchor.click();
            anchor.remove();
            success = true;
            showStatus(t('status.storageDownloadReady'), 'success');
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message || t('status.storageDownloadFailed'), 'error');
          } finally {
            if (dom.storage && dom.storage.downloadSelected) {
              dom.storage.downloadSelected.disabled = false;
            }
            if (success) {
              browserState.selected.clear();
            }
            renderStorageBrowser();
          }
        }

        async function handleStorageRepair() {
          if (!dom.storage || state.storage.repairing) {
            return;
          }
          state.storage.repairing = true;
          renderStorageRepairControls();
          showStatus(t('status.storageRepairing'), 'info');
          try {
            const payload = await request('/api/storage/repair', { method: 'POST' });
            const removed = Array.isArray(payload?.removed) ? payload.removed : [];
            const freed = Number(payload?.freed_bytes) || 0;
            state.storage.repairSummary = {
              count: removed.length,
              freed,
            };
            renderStorageRepairSummary();
            if (removed.length > 0) {
              const itemWord = pluralize(currentLanguage, 'counts.item', removed.length);
              const freedLabel = freed > 0 ? formatBytes(freed) : t('storage.repair.noChange');
              showStatus(
                t('status.storageRepairComplete', {
                  count: removed.length,
                  itemWord,
                  freed: freedLabel,
                }),
                'success',
              );
            } else {
              showStatus(t('status.storageRepairNoChanges'), 'info');
            }
            const skipped = Array.isArray(payload?.skipped) ? payload.skipped : [];
            if (removed.length > 0 || skipped.length > 0) {
              try {
                console.groupCollapsed('[storage] repair summary');
                if (removed.length > 0) {
                  console.table(
                    removed.map((entry) => ({
                      path: entry?.path ?? '',
                      size: formatBytes(Number(entry?.size) || 0),
                      kind: entry?.kind ?? '',
                      description: entry?.description ?? '',
                    })),
                  );
                }
                if (skipped.length > 0) {
                  console.table(
                    skipped.map((entry) => ({
                      path: entry?.path ?? '',
                      reason: entry?.reason ?? '',
                      kind: entry?.kind ?? '',
                    })),
                  );
                }
                console.groupEnd();
              } catch (error) {
                // eslint-disable-next-line no-console
                console.error('Failed to render storage repair summary', error);
              }
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message || t('status.storageRepairFailed'), 'error');
          } finally {
            state.storage.repairing = false;
            renderStorageRepairControls();
            await refreshStorage({ includeOverview: true, force: true, silent: true });
            renderStorageRepairSummary();
          }
        }

        function resolveTaskOperationLabel(entry) {
          if (!entry) {
            return '';
          }
          const operation =
            entry.operation || entry?.context?.operation || entry?.context?.type || entry?.type || '';
          if (operation === 'transcription') {
            return t('tasks.labels.transcription');
          }
          if (operation === 'slide_merge') {
            return t('tasks.labels.slideMerge');
          }
          if (operation === 'slide_bundle') {
            return t('tasks.labels.slideBundle');
          }
          return t('tasks.labels.generic');
        }

        function createActiveTaskElement(entry) {
          if (!entry || typeof entry !== 'object') {
            return null;
          }
          const lectureId = Number(entry?.lecture_id);
          const listItem = document.createElement('div');
          listItem.className = 'task-entry';
          listItem.dataset.taskSection = 'current';
          listItem.setAttribute('role', 'listitem');
          const statusKey = entry?.error
            ? 'failed'
            : entry?.finished
            ? 'finished'
            : entry?.active
            ? 'running'
            : 'pending';
          listItem.dataset.status = entry?.error
            ? 'error'
            : entry?.finished
            ? 'finished'
            : 'running';
          listItem.dataset.taskType = entry?.type || '';
          listItem.dataset.lectureId = Number.isFinite(lectureId) ? String(lectureId) : '';

          const title = document.createElement('div');
          title.className = 'task-entry-title';
          const heading = document.createElement('h3');
          const lectureName = entry?.lecture?.name || t('tasks.labels.untitled');
          heading.textContent = lectureName;
          const statusLabel = document.createElement('span');
          statusLabel.className = 'task-entry-status';
          statusLabel.textContent = t(`tasks.status.${statusKey}`);
          title.appendChild(heading);
          title.appendChild(statusLabel);
          listItem.appendChild(title);

          const meta = document.createElement('div');
          meta.className = 'task-entry-meta';
          const typeLabel = document.createElement('span');
          typeLabel.textContent = resolveTaskOperationLabel(entry);
          meta.appendChild(typeLabel);
          const locationParts = [];
          if (entry?.lecture?.class) {
            locationParts.push(entry.lecture.class);
          }
          if (entry?.lecture?.module) {
            locationParts.push(entry.lecture.module);
          }
          if (locationParts.length > 0) {
            const location = document.createElement('span');
            location.textContent = locationParts.join('  ');
            meta.appendChild(location);
          }
          listItem.appendChild(meta);

          const messageText = entry?.message || '';
          if (messageText) {
            const message = document.createElement('p');
            message.className = 'task-entry-message';
            message.textContent = messageText;
            listItem.appendChild(message);
          }

          const actions = document.createElement('div');
          actions.className = 'task-entry-actions';
          if (Number.isFinite(lectureId)) {
            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'text';
            openButton.dataset.taskAction = 'open';
            openButton.dataset.lectureId = String(lectureId);
            openButton.textContent = t('tasks.actions.open');
            actions.appendChild(openButton);
          }

          if (entry?.error && Number.isFinite(lectureId)) {
            const retryButton = document.createElement('button');
            retryButton.type = 'button';
            retryButton.dataset.taskAction = 'retry';
            retryButton.dataset.lectureId = String(lectureId);
            retryButton.dataset.taskType = entry?.type || '';
            retryButton.textContent = t('tasks.actions.retry');
            actions.appendChild(retryButton);

            const dismissButton = document.createElement('button');
            dismissButton.type = 'button';
            dismissButton.dataset.taskAction = 'dismiss';
            dismissButton.dataset.lectureId = String(lectureId);
            dismissButton.dataset.taskType = entry?.type || '';
            dismissButton.textContent = t('tasks.actions.dismiss');
            actions.appendChild(dismissButton);
          } else if (entry?.finished && Number.isFinite(lectureId)) {
            const dismissButton = document.createElement('button');
            dismissButton.type = 'button';
            dismissButton.dataset.taskAction = 'dismiss';
            dismissButton.dataset.lectureId = String(lectureId);
            dismissButton.dataset.taskType = entry?.type || '';
            dismissButton.textContent = t('tasks.actions.dismiss');
            actions.appendChild(dismissButton);
          }

          listItem.appendChild(actions);
          return listItem;
        }

        function createQueueTaskElement(task, sectionKey) {
          if (!task || typeof task !== 'object') {
            return null;
          }
          const lectureId = Number(task?.lecture_id);
          const listItem = document.createElement('div');
          listItem.className = 'task-entry';
          listItem.dataset.taskSection = sectionKey;
          listItem.dataset.taskSource = sectionKey;
          listItem.setAttribute('role', 'listitem');
          const statusKey =
            task.status === 'failed'
              ? 'failed'
              : task.status === 'succeeded'
              ? 'finished'
              : 'pending';
          listItem.dataset.status =
            task.status === 'failed'
              ? 'error'
              : task.status === 'succeeded'
              ? 'finished'
              : 'pending';
          listItem.dataset.taskType = task?.type || '';
          listItem.dataset.lectureId = Number.isFinite(lectureId) ? String(lectureId) : '';

          const title = document.createElement('div');
          title.className = 'task-entry-title';
          const heading = document.createElement('h3');
          heading.textContent = task?.lecture?.name || t('tasks.labels.untitled');
          const statusLabel = document.createElement('span');
          statusLabel.className = 'task-entry-status';
          statusLabel.textContent = t(`tasks.status.${statusKey}`);
          title.appendChild(heading);
          title.appendChild(statusLabel);
          listItem.appendChild(title);

          const meta = document.createElement('div');
          meta.className = 'task-entry-meta';
          const typeLabel = document.createElement('span');
          typeLabel.textContent = resolveTaskOperationLabel(task);
          meta.appendChild(typeLabel);
          const locationParts = [];
          if (task?.lecture?.class) {
            locationParts.push(task.lecture.class);
          }
          if (task?.lecture?.module) {
            locationParts.push(task.lecture.module);
          }
          if (locationParts.length > 0) {
            const location = document.createElement('span');
            location.textContent = locationParts.join('  ');
            meta.appendChild(location);
          }
          listItem.appendChild(meta);

          const message = document.createElement('p');
          message.className = 'task-entry-message';
          if (task.status === 'failed' && task.error) {
            message.textContent = String(task.error);
          } else if (task.status === 'succeeded') {
            message.textContent = t('tasks.messages.completed');
          } else {
            message.textContent = t('tasks.messages.pending');
          }
          listItem.appendChild(message);

          const actions = document.createElement('div');
          actions.className = 'task-entry-actions';
          if (Number.isFinite(lectureId)) {
            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'text';
            openButton.dataset.taskAction = 'open';
            openButton.dataset.lectureId = String(lectureId);
            openButton.textContent = t('tasks.actions.open');
            actions.appendChild(openButton);
          }
          listItem.appendChild(actions);
          return listItem;
        }

        function renderTasks() {
          if (!dom.tasks || !dom.tasks.list) {
            return;
          }
          dom.tasks.list.innerHTML = '';
          const isLoading = Boolean(state.tasks.loading);
          if (dom.tasks.container) {
            dom.tasks.container.setAttribute('aria-busy', isLoading ? 'true' : 'false');
          }

          const queueEntries = Array.isArray(state.tasks.queue) ? state.tasks.queue : [];
          const activeEntries = Array.isArray(state.tasks.active) ? state.tasks.active : [];
          const hasCompletedEntries = queueEntries.some(
            (task) => task && (task.status === 'succeeded' || task.status === 'failed'),
          );
          if (dom.tasks.clearDone) {
            dom.tasks.clearDone.disabled = state.tasks.loading || !hasCompletedEntries;
          }
          const sections = [
            {
              key: 'current',
              label: t('tasks.sections.current'),
              entries: activeEntries
                .map((entry) => ({ entry }))
                .filter((item) => item.entry && typeof item.entry === 'object'),
            },
            {
              key: 'queued',
              label: t('tasks.sections.queued'),
              entries: queueEntries
                .filter((task) => task && task.status !== 'succeeded' && task.status !== 'failed')
                .map((task) => ({ task })),
            },
            {
              key: 'done',
              label: t('tasks.sections.done'),
              entries: queueEntries
                .filter((task) => task && task.status !== 'pending' && task.status !== 'running')
                .map((task) => ({ task })),
            },
          ];

          const hasItems = sections.some((section) => section.entries.length > 0);

          if (!hasItems) {
            if (dom.tasks.empty) {
              dom.tasks.empty.classList.remove('hidden');
            }
            return;
          }

          if (dom.tasks.empty) {
            dom.tasks.empty.classList.add('hidden');
          }

          sections.forEach((section) => {
            const sectionBlock = document.createElement('div');
            sectionBlock.className = 'task-section';
            sectionBlock.setAttribute('role', 'presentation');
            const heading = document.createElement('div');
            heading.className = 'task-section-heading';
            heading.textContent = section.label;
            sectionBlock.appendChild(heading);

            if (!section.entries.length) {
              const placeholder = document.createElement('p');
              placeholder.className = 'task-section-empty';
              placeholder.textContent = t('tasks.sections.empty');
              sectionBlock.appendChild(placeholder);
            } else {
              section.entries.forEach((entry) => {
                let element = null;
                if (section.key === 'current') {
                  element = createActiveTaskElement(entry.entry);
                } else {
                  element = createQueueTaskElement(entry.task, section.key);
                }
                if (element) {
                  sectionBlock.appendChild(element);
                }
              });
            }

            dom.tasks.list.appendChild(sectionBlock);
          });
        }

        function getBulkProcessKey(lectureId, operation) {
          return `${lectureId}:${operation}`;
        }

        function collectBulkProcessMeta() {
          const meta = state.bulkProcess.meta;
          meta.clear();
          let availableCount = 0;
          let lectureCount = 0;

          state.classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const classId = Number(klass.id);
            const className =
              typeof klass.name === 'string' && klass.name
                ? klass.name
                : t('storage.unnamedClass');
            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            modules.forEach((module) => {
              if (!module || typeof module !== 'object') {
                return;
              }
              const moduleId = Number(module.id);
              const moduleName =
                typeof module.name === 'string' && module.name
                  ? module.name
                  : t('storage.unnamedModule');
              const lectures = Array.isArray(module.lectures) ? module.lectures : [];
              lectures.forEach((lecture) => {
                if (!lecture || typeof lecture !== 'object') {
                  return;
                }
                const lectureId = Number(lecture.id);
                if (!Number.isFinite(lectureId) || lectureId <= 0) {
                  return;
                }
                lectureCount += 1;
                const lectureName =
                  typeof lecture.name === 'string' && lecture.name
                    ? lecture.name
                    : t('tasks.labels.untitled');
                const pendingSlideUploads = getPendingSlideUploadCount(lecture);
                const hasSlideSource = Boolean(lecture?.slide_path);
                BULK_PROCESS_OPERATIONS.forEach((definition) => {
                  const key = getBulkProcessKey(lectureId, definition.operation);
                  const available = Boolean(definition.isAvailable(lecture, state.settings));
                  const completed = available && Boolean(definition.isCompleted(lecture));
                  const options =
                    typeof definition.buildOptions === 'function'
                      ? definition.buildOptions(lecture, state.settings)
                      : null;
                  const requiresSlideMerge =
                    definition.operation === 'slide_bundle' &&
                    pendingSlideUploads > 0 &&
                    !hasSlideSource;
                  meta.set(key, {
                    key,
                    lectureId,
                    lectureName,
                    moduleId,
                    moduleName,
                    classId,
                    className,
                    operation: definition.operation,
                    labelKey: definition.labelKey,
                    available,
                    completed,
                    options,
                    pendingSlideUploadCount: pendingSlideUploads,
                    requiresSlideMerge,
                  });
                  if (!available) {
                    state.bulkProcess.selections.delete(key);
                  } else {
                    availableCount += 1;
                  }
                });
              });
            });
          });

          state.bulkProcess.selections.forEach((_, key) => {
            if (!meta.has(key)) {
              state.bulkProcess.selections.delete(key);
            }
          });

          state.bulkProcess.availableCount = availableCount;
          state.bulkProcess.lectureCount = lectureCount;
          return { availableCount, lectureCount };
        }

        function renderBulkProcessTree() {
          if (!dom.bulkProcessDialog || !dom.bulkProcessDialog.content) {
            return;
          }
          const container = dom.bulkProcessDialog.content;
          container.innerHTML = '';
          state.bulkProcess.checkboxMap.clear();

          const tree = document.createElement('div');
          tree.className = 'bulk-process-tree';
          let lectureRendered = 0;

          state.classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const rawModules = Array.isArray(klass.modules) ? klass.modules : [];
            const moduleEntries = rawModules
              .map((module) => {
                if (!module || typeof module !== 'object') {
                  return null;
                }
                const lectures = Array.isArray(module.lectures) ? module.lectures : [];
                const validLectures = lectures.filter((lecture) => {
                  const lectureId = Number(lecture?.id);
                  return Number.isFinite(lectureId) && lectureId > 0;
                });
                return validLectures.length > 0 ? { module, lectures: validLectures } : null;
              })
              .filter(Boolean);

            if (!moduleEntries.length) {
              return;
            }

            const classDetails = document.createElement('details');
            classDetails.className = 'bulk-process-class';
            const classId = Number(klass.id);
            const classKey = Number.isFinite(classId) ? String(classId) : null;
            let classOpen = false;
            if (classKey) {
              const stored = state.bulkProcess.expandedClasses.get(classKey);
              if (typeof stored === 'boolean') {
                classOpen = stored;
              }
            }
            classDetails.open = classOpen;
            if (classKey) {
              classDetails.dataset.classId = classKey;
              classDetails.addEventListener('toggle', () => {
                state.bulkProcess.expandedClasses.set(classKey, classDetails.open);
              });
            }

            const classSummary = document.createElement('summary');
            const classTitle = document.createElement('span');
            classTitle.className = 'bulk-process-summary-title';
            classTitle.textContent = klass.name || t('storage.unnamedClass');
            classSummary.appendChild(classTitle);

            const moduleCount = moduleEntries.length;
            const lectureCount = moduleEntries.reduce(
              (total, entry) => total + entry.lectures.length,
              0,
            );
            const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            const classMeta = document.createElement('span');
            classMeta.className = 'bulk-process-summary-meta';
            classMeta.textContent = t('curriculum.classMeta', {
              moduleCount,
              moduleWord,
              lectureCount,
              lectureWord,
            });
            classSummary.appendChild(classMeta);
            classDetails.appendChild(classSummary);

            moduleEntries.forEach((entry) => {
              const moduleDetails = document.createElement('details');
              moduleDetails.className = 'bulk-process-module';
              const moduleId = Number(entry.module?.id);
              const moduleKey =
                classKey && Number.isFinite(moduleId) ? `${classKey}:${moduleId}` : null;
              let moduleOpen = false;
              if (moduleKey) {
                const stored = state.bulkProcess.expandedModules.get(moduleKey);
                if (typeof stored === 'boolean') {
                  moduleOpen = stored;
                }
              }
              moduleDetails.open = moduleOpen;
              if (moduleKey) {
                moduleDetails.dataset.classId = classKey;
                moduleDetails.dataset.moduleId = String(moduleId);
                moduleDetails.addEventListener('toggle', () => {
                  state.bulkProcess.expandedModules.set(moduleKey, moduleDetails.open);
                });
              }

              const moduleSummary = document.createElement('summary');
              const moduleTitle = document.createElement('span');
              moduleTitle.className = 'bulk-process-summary-title';
              moduleTitle.textContent = entry.module?.name || t('storage.unnamedModule');
              moduleSummary.appendChild(moduleTitle);

              const moduleLectureCount = entry.lectures.length;
              const moduleLectureWord = pluralize(
                currentLanguage,
                'counts.lecture',
                moduleLectureCount,
              );
              const moduleMeta = document.createElement('span');
              moduleMeta.className = 'bulk-process-summary-meta';
              moduleMeta.textContent = t('curriculum.moduleMeta', {
                lectureCount: moduleLectureCount,
                lectureWord: moduleLectureWord,
              });
              moduleSummary.appendChild(moduleMeta);
              moduleDetails.appendChild(moduleSummary);

              const lectureList = document.createElement('ul');
              lectureList.className = 'bulk-process-lectures';

              entry.lectures.forEach((lecture) => {
                const lectureId = Number(lecture.id);
                if (!Number.isFinite(lectureId) || lectureId <= 0) {
                  return;
                }
                lectureRendered += 1;

                const lectureItem = document.createElement('li');
                lectureItem.className = 'bulk-process-lecture';

                const header = document.createElement('div');
                header.className = 'bulk-process-lecture-header';

                const title = document.createElement('div');
                title.className = 'bulk-process-lecture-title';
                title.textContent = lecture.name || t('tasks.labels.untitled');
                header.appendChild(title);

                const metaLine = document.createElement('div');
                metaLine.className = 'bulk-process-lecture-meta';
                metaLine.textContent = `${klass.name || t('storage.unnamedClass')}  ${
                  entry.module?.name || t('storage.unnamedModule')
                }`;
                header.appendChild(metaLine);

                lectureItem.appendChild(header);

                const checkboxGroup = document.createElement('div');
                checkboxGroup.className = 'bulk-process-checkbox-group';

                BULK_PROCESS_OPERATIONS.forEach((definition) => {
                  const key = getBulkProcessKey(lectureId, definition.operation);
                  const meta = state.bulkProcess.meta.get(key);
                  if (!meta) {
                    return;
                  }

                  const checkbox = document.createElement('label');
                  checkbox.className = 'bulk-process-checkbox';
                  checkbox.dataset.lectureId = String(lectureId);
                  checkbox.dataset.operation = definition.operation;

                  const input = document.createElement('input');
                  input.type = 'checkbox';
                  input.setAttribute('aria-label', t(definition.labelKey));
                  const statusId = `bulk-process-status-${lectureId}-${definition.key}`;
                  input.setAttribute('aria-describedby', statusId);
                  input.addEventListener('change', (event) => {
                    event.stopPropagation();
                    setBulkProcessStatus('');
                    handleBulkProcessCheckboxChange(key, event.target.checked);
                  });
                  checkbox.appendChild(input);

                  const indicator = document.createElement('span');
                  indicator.className = 'bulk-process-indicator';
                  indicator.setAttribute('aria-hidden', 'true');
                  checkbox.appendChild(indicator);

                  const text = document.createElement('span');
                  text.className = 'bulk-process-checkbox-text';

                  const action = document.createElement('span');
                  action.className = 'bulk-process-checkbox-title';
                  text.appendChild(action);

                  const status = document.createElement('span');
                  status.id = statusId;
                  status.className = 'bulk-process-status-label';
                  text.appendChild(status);

                  checkbox.appendChild(text);

                  state.bulkProcess.checkboxMap.set(key, {
                    container: checkbox,
                    input,
                    status,
                    action,
                  });

                  updateBulkProcessCheckboxState(key);

                  checkboxGroup.appendChild(checkbox);
                });

                lectureItem.appendChild(checkboxGroup);
                lectureList.appendChild(lectureItem);
              });

              moduleDetails.appendChild(lectureList);
              classDetails.appendChild(moduleDetails);
            });

            tree.appendChild(classDetails);
          });

          if (dom.bulkProcessDialog.empty) {
            dom.bulkProcessDialog.empty.hidden = lectureRendered > 0;
          }
          if (lectureRendered > 0) {
            container.appendChild(tree);
          } else {
            container.innerHTML = '';
          }
        }

        function updateBulkProcessCheckboxState(key) {
          const entry = state.bulkProcess.checkboxMap.get(key);
          const meta = state.bulkProcess.meta.get(key);
          if (!entry || !meta) {
            return;
          }
          const { container, input, status, action } = entry;
          if (action) {
            action.textContent = t(meta.labelKey);
          }

          const available = Boolean(meta.available);
          const completed = Boolean(meta.completed);
          const selected = available && state.bulkProcess.selections.has(key);

          let stateValue = 'empty';
          if (!available) {
            stateValue = 'unavailable';
          } else if (selected) {
            stateValue = 'selected';
          } else if (completed) {
            stateValue = 'completed';
          }

          container.dataset.state = stateValue;
          input.disabled = !available;
          input.checked = selected;

          if (status) {
            status.textContent = t(`tasks.bulkProcess.status.${stateValue}`);
          }
        }

        function refreshBulkProcessCheckboxes() {
          state.bulkProcess.checkboxMap.forEach((_, key) => {
            updateBulkProcessCheckboxState(key);
          });
        }

        function updateBulkProcessSummary() {
          if (!dom.bulkProcessDialog) {
            return;
          }
          const summary = dom.bulkProcessDialog.summary;
          const selectAllButton = dom.bulkProcessDialog.selectAll;
          const clearButton = dom.bulkProcessDialog.clear;
          const submitButton = dom.bulkProcessDialog.submit;

          const selectedEntries = [];
          state.bulkProcess.selections.forEach((_, key) => {
            const meta = state.bulkProcess.meta.get(key);
            if (meta && meta.available) {
              selectedEntries.push(meta);
            } else {
              state.bulkProcess.selections.delete(key);
            }
          });

          const selectedCount = selectedEntries.length;
          const transcriptionCount = selectedEntries.filter(
            (entry) => entry.operation === 'transcription',
          ).length;
          const mergeCount = selectedEntries.filter(
            (entry) => entry.operation === 'slide_merge',
          ).length;
          const slideCount = selectedEntries.filter(
            (entry) => entry.operation === 'slide_bundle',
          ).length;

          if (summary) {
            summary.innerHTML = '';
            if (selectedCount === 0) {
              summary.textContent = t('tasks.bulkProcess.summaryEmpty');
            } else {
              const taskWord = pluralize(currentLanguage, 'counts.task', selectedCount);
              const totalLine = document.createElement('span');
              totalLine.textContent = t('tasks.bulkProcess.summarySelected', {
                count: selectedCount,
                taskWord,
              });
              summary.appendChild(totalLine);

              const breakdown = document.createElement('span');
              breakdown.textContent = t('tasks.bulkProcess.summaryBreakdown', {
                merge: mergeCount,
                transcription: transcriptionCount,
                slides: slideCount,
              });
              summary.appendChild(breakdown);
            }
          }

          if (selectAllButton) {
            selectAllButton.disabled = state.bulkProcess.availableCount === 0;
          }
          if (clearButton) {
            clearButton.disabled = selectedCount === 0;
          }
          if (submitButton) {
            submitButton.disabled = selectedCount === 0;
          }
        }

        function setBulkProcessStatus(message = '', variant = '') {
          if (!dom.bulkProcessDialog || !dom.bulkProcessDialog.status) {
            return;
          }
          const element = dom.bulkProcessDialog.status;
          element.classList.remove('error', 'success');
          if (variant) {
            element.classList.add(variant);
          }
          element.textContent = message || '';
        }

        function selectAllBulkProcess() {
          state.bulkProcess.meta.forEach((meta, key) => {
            if (!meta.available) {
              state.bulkProcess.selections.delete(key);
              return;
            }
            if (meta.completed) {
              state.bulkProcess.selections.delete(key);
              return;
            }
            state.bulkProcess.selections.set(key, true);
          });
          refreshBulkProcessCheckboxes();
          updateBulkProcessSummary();
        }

        function clearBulkProcessSelections() {
          if (state.bulkProcess.selections.size > 0) {
            state.bulkProcess.selections.clear();
          }
          refreshBulkProcessCheckboxes();
          updateBulkProcessSummary();
        }

        function handleBulkProcessCheckboxChange(key, checked) {
          const meta = state.bulkProcess.meta.get(key);
          if (!meta || !meta.available) {
            state.bulkProcess.selections.delete(key);
            updateBulkProcessCheckboxState(key);
            updateBulkProcessSummary();
            return;
          }
          if (checked) {
            state.bulkProcess.selections.set(key, true);
            if (meta.operation === 'slide_bundle' && meta.requiresSlideMerge) {
              const mergeKey = getBulkProcessKey(meta.lectureId, 'slide_merge');
              const mergeMeta = state.bulkProcess.meta.get(mergeKey);
              if (
                mergeMeta &&
                mergeMeta.available &&
                !state.bulkProcess.selections.has(mergeKey)
              ) {
                state.bulkProcess.selections.set(mergeKey, true);
                updateBulkProcessCheckboxState(mergeKey);
              }
            }
          } else {
            state.bulkProcess.selections.delete(key);
          }
          updateBulkProcessCheckboxState(key);
          updateBulkProcessSummary();
        }

        let bulkProcessDialogCleanup = null;
        let bulkProcessPreviousFocus = null;

        function closeBulkProcessDialog(options = {}) {
          if (typeof bulkProcessDialogCleanup === 'function') {
            const cleanup = bulkProcessDialogCleanup;
            bulkProcessDialogCleanup = null;
            cleanup(options);
          }
        }

        async function handleBulkProcessSubmit(event) {
          event?.preventDefault?.();
          if (!dialogState.bulkProcessActive) {
            return;
          }
          const tasks = [];
          state.bulkProcess.selections.forEach((_, key) => {
            const meta = state.bulkProcess.meta.get(key);
            if (meta && meta.available) {
              const task = { lecture_id: meta.lectureId, operation: meta.operation };
              if (meta.options && typeof meta.options === 'object') {
                task.options = meta.options;
              }
              tasks.push(task);
            }
          });
          tasks.sort((a, b) => {
            const priorityA =
              BULK_PROCESS_OPERATION_PRIORITY.get(a.operation) ?? Number.MAX_SAFE_INTEGER;
            const priorityB =
              BULK_PROCESS_OPERATION_PRIORITY.get(b.operation) ?? Number.MAX_SAFE_INTEGER;
            if (priorityA !== priorityB) {
              return priorityA - priorityB;
            }
            const lectureA = Number(a.lecture_id) || 0;
            const lectureB = Number(b.lecture_id) || 0;
            if (lectureA !== lectureB) {
              return lectureA - lectureB;
            }
            return 0;
          });
          if (!tasks.length) {
            updateBulkProcessSummary();
            return;
          }
          const submitButton = dom.bulkProcessDialog?.submit;
          let previousDisabled = false;
          if (submitButton) {
            previousDisabled = submitButton.disabled;
            submitButton.disabled = true;
          }
          setBulkProcessStatus('');
          try {
            await request('/api/tasks', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tasks }),
            });
            state.bulkProcess.selections.clear();
            closeBulkProcessDialog();
            showStatus(t('tasks.notifications.queued'), 'success');
            await refreshTasks({ force: true });
          } catch (error) {
            const detail = error instanceof Error ? error.message : String(error || '');
            setBulkProcessStatus(detail || t('status.processing'), 'error');
          } finally {
            if (dialogState.bulkProcessActive) {
              if (submitButton) {
                submitButton.disabled = previousDisabled;
              }
              refreshBulkProcessCheckboxes();
              updateBulkProcessSummary();
            }
          }
        }

        function openBulkProcessDialog() {
          if (
            dialogState.bulkProcessActive ||
            dialogState.bulkDownloadActive ||
            dialogState.active ||
            dialogState.uploadActive ||
            dialogState.bulkUploadActive ||
            dialogState.viewerActive
          ) {
            return;
          }
          if (!dom.bulkProcessDialog || !dom.bulkProcessDialog.root) {
            return;
          }

          collectBulkProcessMeta();
          renderBulkProcessTree();
          refreshBulkProcessCheckboxes();
          updateBulkProcessSummary();
          setBulkProcessStatus('');

          const root = dom.bulkProcessDialog.root;
          root.classList.remove('hidden');
          root.setAttribute('aria-hidden', 'false');
          document.body.classList.add('dialog-open');
          dialogState.bulkProcessActive = true;

          bulkProcessPreviousFocus =
            document.activeElement instanceof HTMLElement ? document.activeElement : null;

          const focusTargets = [
            dom.bulkProcessDialog.selectAll,
            dom.bulkProcessDialog.clear,
            dom.bulkProcessDialog.submit,
            dom.bulkProcessDialog.cancel,
          ].filter((element) => element instanceof HTMLElement && !element.disabled);
          if (focusTargets.length > 0) {
            focusTargets[0].focus({ preventScroll: true });
          }

          function handleSelectAll(event) {
            event?.preventDefault?.();
            setBulkProcessStatus('');
            selectAllBulkProcess();
          }

          function handleClear(event) {
            event?.preventDefault?.();
            setBulkProcessStatus('');
            clearBulkProcessSelections();
          }

          function handleCancel(event) {
            event?.preventDefault?.();
            closeBulkProcessDialog();
          }

          function handleBackdrop(event) {
            event?.preventDefault?.();
            closeBulkProcessDialog();
          }

          function handleKeyDown(event) {
            if (event.key === 'Escape') {
              event.preventDefault();
              closeBulkProcessDialog();
              return;
            }
            if (event.key === 'Tab') {
              const focusable = [
                dom.bulkProcessDialog.selectAll,
                dom.bulkProcessDialog.clear,
                dom.bulkProcessDialog.submit,
                dom.bulkProcessDialog.cancel,
              ].filter((element) => element instanceof HTMLElement && !element.disabled);
              if (!focusable.length) {
                return;
              }
              const currentIndex = focusable.indexOf(document.activeElement);
              const nextIndex = event.shiftKey
                ? currentIndex <= 0
                  ? focusable.length - 1
                  : currentIndex - 1
                : currentIndex === focusable.length - 1
                ? 0
                : currentIndex + 1;
              focusable[nextIndex].focus({ preventScroll: true });
              event.preventDefault();
            }
          }

          if (dom.bulkProcessDialog.selectAll) {
            dom.bulkProcessDialog.selectAll.addEventListener('click', handleSelectAll);
          }
          if (dom.bulkProcessDialog.clear) {
            dom.bulkProcessDialog.clear.addEventListener('click', handleClear);
          }
          if (dom.bulkProcessDialog.cancel) {
            dom.bulkProcessDialog.cancel.addEventListener('click', handleCancel);
          }
          if (dom.bulkProcessDialog.backdrop) {
            dom.bulkProcessDialog.backdrop.addEventListener('click', handleBackdrop);
          }
          if (dom.bulkProcessDialog.submit) {
            dom.bulkProcessDialog.submit.addEventListener('click', handleBulkProcessSubmit);
          }
          if (dom.bulkProcessDialog.window) {
            dom.bulkProcessDialog.window.addEventListener('keydown', handleKeyDown);
          }

          bulkProcessDialogCleanup = (options = {}) => {
            const { restoreFocus = true } = options;
            if (dom.bulkProcessDialog.selectAll) {
              dom.bulkProcessDialog.selectAll.removeEventListener('click', handleSelectAll);
            }
            if (dom.bulkProcessDialog.clear) {
              dom.bulkProcessDialog.clear.removeEventListener('click', handleClear);
            }
            if (dom.bulkProcessDialog.cancel) {
              dom.bulkProcessDialog.cancel.removeEventListener('click', handleCancel);
            }
            if (dom.bulkProcessDialog.backdrop) {
              dom.bulkProcessDialog.backdrop.removeEventListener('click', handleBackdrop);
            }
            if (dom.bulkProcessDialog.submit) {
              dom.bulkProcessDialog.submit.removeEventListener('click', handleBulkProcessSubmit);
            }
            if (dom.bulkProcessDialog.window) {
              dom.bulkProcessDialog.window.removeEventListener('keydown', handleKeyDown);
            }

            root.classList.add('hidden');
            root.setAttribute('aria-hidden', 'true');
            dialogState.bulkProcessActive = false;
            state.bulkProcess.checkboxMap.clear();
            if (
              !dialogState.active &&
              !dialogState.uploadActive &&
              !dialogState.bulkUploadActive &&
              !dialogState.bulkDownloadActive &&
              !dialogState.viewerActive
            ) {
              document.body.classList.remove('dialog-open');
            }
            if (restoreFocus && bulkProcessPreviousFocus) {
              bulkProcessPreviousFocus.focus({ preventScroll: true });
            }
            bulkProcessPreviousFocus = null;
            setBulkProcessStatus('');
            updateBulkProcessSummary();
          };
        }


        function getBulkDownloadKey(lectureId, assetKey) {
          return `${lectureId}:${assetKey}`;
        }

        function collectBulkDownloadMeta() {
          const meta = state.bulkDownload.meta;
          meta.clear();
          let availableCount = 0;
          let lectureCount = 0;

          state.classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const classId = Number(klass.id);
            const className =
              typeof klass.name === 'string' && klass.name
                ? klass.name
                : t('storage.unnamedClass');
            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            modules.forEach((module) => {
              if (!module || typeof module !== 'object') {
                return;
              }
              const moduleId = Number(module.id);
              const moduleName =
                typeof module.name === 'string' && module.name
                  ? module.name
                  : t('storage.unnamedModule');
              const lectures = Array.isArray(module.lectures) ? module.lectures : [];
              lectures.forEach((lecture) => {
                if (!lecture || typeof lecture !== 'object') {
                  return;
                }
                const lectureId = Number(lecture.id);
                if (!Number.isFinite(lectureId) || lectureId <= 0) {
                  return;
                }
                lectureCount += 1;
                const lectureName =
                  typeof lecture.name === 'string' && lecture.name
                    ? lecture.name
                    : t('tasks.labels.untitled');

                BULK_DOWNLOAD_ASSETS.forEach((definition) => {
                  if (!definition || !definition.key) {
                    return;
                  }
                  const key = getBulkDownloadKey(lectureId, definition.key);
                  const path =
                    typeof definition.resolvePath === 'function'
                      ? definition.resolvePath(lecture)
                      : null;
                  const available = Boolean(path);
                  meta.set(key, {
                    key,
                    lectureId,
                    lectureName,
                    moduleId,
                    moduleName,
                    classId,
                    className,
                    assetKey: definition.key,
                    labelKey: definition.labelKey,
                    available,
                  });
                  if (!available) {
                    state.bulkDownload.selections.delete(key);
                  } else {
                    availableCount += 1;
                  }
                });
              });
            });
          });

          state.bulkDownload.selections.forEach((_, key) => {
            if (!meta.has(key)) {
              state.bulkDownload.selections.delete(key);
            }
          });

          state.bulkDownload.availableCount = availableCount;
          state.bulkDownload.lectureCount = lectureCount;
          return { availableCount, lectureCount };
        }

        function renderBulkDownloadTree() {
          if (!dom.bulkDownloadDialog || !dom.bulkDownloadDialog.content) {
            return;
          }
          const container = dom.bulkDownloadDialog.content;
          container.innerHTML = '';
          state.bulkDownload.checkboxMap.clear();

          const tree = document.createElement('div');
          tree.className = 'bulk-process-tree';
          let lectureRendered = 0;

          state.classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const classId = Number(klass.id);
            const classKey = `class-${classId}`;
            const classDetails = document.createElement('details');
            classDetails.className = 'bulk-process-class';
            const stored = state.bulkDownload.expandedClasses.get(classKey);
            if (typeof stored === 'boolean') {
              classDetails.open = stored;
            }
            classDetails.addEventListener('toggle', () => {
              state.bulkDownload.expandedClasses.set(classKey, classDetails.open);
            });

            const classSummary = document.createElement('summary');
            classSummary.className = 'bulk-process-summary';
            const classTitle = document.createElement('div');
            classTitle.className = 'bulk-process-summary-title';
            classTitle.textContent =
              typeof klass.name === 'string' && klass.name
                ? klass.name
                : t('storage.unnamedClass');
            classSummary.appendChild(classTitle);

            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            const moduleCount = modules.length;
            const lectureCount = modules.reduce((total, module) => {
              const moduleLectures = Array.isArray(module.lectures) ? module.lectures : [];
              const valid = moduleLectures.filter((lecture) => {
                const lectureId = Number(lecture?.id);
                return Number.isFinite(lectureId) && lectureId > 0;
              });
              return total + valid.length;
            }, 0);
            const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            const classMeta = document.createElement('div');
            classMeta.className = 'bulk-process-summary-meta';
            classMeta.textContent = t('curriculum.classMeta', {
              moduleCount,
              moduleWord,
              lectureCount,
              lectureWord,
            });
            classSummary.appendChild(classMeta);

            classDetails.appendChild(classSummary);

            const moduleList = document.createElement('div');
            moduleList.className = 'bulk-process-modules';
            modules.forEach((module) => {
              if (!module || typeof module !== 'object') {
                return;
              }
              const moduleId = Number(module.id);
              const moduleKey = `${classKey}-module-${moduleId}`;
              const moduleDetails = document.createElement('details');
              moduleDetails.className = 'bulk-process-module';
              const moduleStored = state.bulkDownload.expandedModules.get(moduleKey);
              if (typeof moduleStored === 'boolean') {
                moduleDetails.open = moduleStored;
              }
              moduleDetails.addEventListener('toggle', () => {
                state.bulkDownload.expandedModules.set(moduleKey, moduleDetails.open);
              });
              const moduleLectures = Array.isArray(module.lectures) ? module.lectures : [];

              const moduleSummary = document.createElement('summary');
              moduleSummary.className = 'bulk-process-summary';
              const moduleTitle = document.createElement('div');
              moduleTitle.className = 'bulk-process-summary-title';
              moduleTitle.textContent =
                typeof module.name === 'string' && module.name
                  ? module.name
                  : t('storage.unnamedModule');
              moduleSummary.appendChild(moduleTitle);
              const moduleLectureCount = moduleLectures.filter((lecture) => {
                const lectureId = Number(lecture?.id);
                return Number.isFinite(lectureId) && lectureId > 0;
              }).length;
              const moduleLectureWord = pluralize(
                currentLanguage,
                'counts.lecture',
                moduleLectureCount,
              );
              const moduleMeta = document.createElement('div');
              moduleMeta.className = 'bulk-process-summary-meta';
              moduleMeta.textContent = t('curriculum.moduleMeta', {
                lectureCount: moduleLectureCount,
                lectureWord: moduleLectureWord,
              });
              moduleSummary.appendChild(moduleMeta);
              moduleDetails.appendChild(moduleSummary);

              const lectureList = document.createElement('div');
              lectureList.className = 'bulk-process-lectures';

              moduleLectures.forEach((lecture) => {
                if (!lecture || typeof lecture !== 'object') {
                  return;
                }
                const lectureId = Number(lecture.id);
                if (!Number.isFinite(lectureId) || lectureId <= 0) {
                  return;
                }
                lectureRendered += 1;
                const lectureItem = document.createElement('div');
                lectureItem.className = 'bulk-process-lecture';

                const header = document.createElement('div');
                header.className = 'bulk-process-lecture-header';
                const title = document.createElement('div');
                title.className = 'bulk-process-lecture-title';
                title.textContent = lecture.name || t('tasks.labels.untitled');
                header.appendChild(title);

                const metaLine = document.createElement('div');
                metaLine.className = 'bulk-process-lecture-meta';
                metaLine.textContent = moduleTitle.textContent;
                header.appendChild(metaLine);
                lectureItem.appendChild(header);

                const checkboxGroup = document.createElement('div');
                checkboxGroup.className = 'bulk-process-checkbox-group';

                BULK_DOWNLOAD_ASSETS.forEach((definition) => {
                  if (!definition || !definition.key) {
                    return;
                  }
                  const key = getBulkDownloadKey(lectureId, definition.key);
                  const checkbox = document.createElement('label');
                  checkbox.className = 'bulk-process-checkbox';
                  checkbox.dataset.key = key;
                  checkbox.dataset.asset = definition.key;
                  const input = document.createElement('input');
                  input.type = 'checkbox';
                  input.addEventListener('change', (event) => {
                    setBulkDownloadStatus('');
                    handleBulkDownloadCheckboxChange(key, event.target.checked);
                  });
                  checkbox.appendChild(input);

                  const indicator = document.createElement('span');
                  indicator.className = 'bulk-process-indicator';
                  checkbox.appendChild(indicator);

                  const text = document.createElement('span');
                  text.className = 'bulk-process-checkbox-text';
                  const action = document.createElement('span');
                  action.className = 'bulk-process-checkbox-title';
                  action.textContent = t(definition.labelKey);
                  text.appendChild(action);
                  const status = document.createElement('span');
                  status.className = 'bulk-process-status-label';
                  status.id = `bulk-download-status-${lectureId}-${definition.key}`;
                  text.appendChild(status);

                  checkbox.appendChild(text);
                  checkboxGroup.appendChild(checkbox);
                  state.bulkDownload.checkboxMap.set(key, {
                    checkbox,
                    input,
                    status,
                  });
                });

                lectureItem.appendChild(checkboxGroup);
                lectureList.appendChild(lectureItem);
              });

              moduleDetails.appendChild(lectureList);
              moduleList.appendChild(moduleDetails);
            });

            classDetails.appendChild(moduleList);
            tree.appendChild(classDetails);
          });

          container.appendChild(tree);
          if (dom.bulkDownloadDialog.empty) {
            dom.bulkDownloadDialog.empty.hidden = lectureRendered > 0;
          }
          refreshBulkDownloadCheckboxes();
        }

        function updateBulkDownloadCheckboxState(key) {
          const entry = state.bulkDownload.checkboxMap.get(key);
          const meta = state.bulkDownload.meta.get(key);
          if (!entry || !meta) {
            state.bulkDownload.selections.delete(key);
            return;
          }
          const { checkbox, input, status } = entry;
          const available = Boolean(meta.available);
          const selected = available && state.bulkDownload.selections.has(key);
          input.disabled = !available;
          input.checked = selected;
          const stateValue = !available ? 'unavailable' : selected ? 'selected' : 'available';
          checkbox.dataset.state = stateValue;
          if (status) {
            status.textContent = t(`tasks.bulkDownload.status.${stateValue}`);
          }
        }

        function refreshBulkDownloadCheckboxes() {
          state.bulkDownload.checkboxMap.forEach((_, key) => {
            updateBulkDownloadCheckboxState(key);
          });
        }

        function updateBulkDownloadSummary() {
          if (!dom.bulkDownloadDialog || !dom.bulkDownloadDialog.summary) {
            return;
          }
          const summary = dom.bulkDownloadDialog.summary;
          const selectAllButton = dom.bulkDownloadDialog.selectAll;
          const clearButton = dom.bulkDownloadDialog.clear;
          const submitButton = dom.bulkDownloadDialog.submit;
          summary.innerHTML = '';

          let selectedCount = 0;
          const breakdown = {
            audio: 0,
            txt: 0,
            pdf: 0,
            md: 0,
            zip: 0,
          };

          state.bulkDownload.selections.forEach((_, key) => {
            const meta = state.bulkDownload.meta.get(key);
            if (!meta || !meta.available) {
              state.bulkDownload.selections.delete(key);
              return;
            }
            selectedCount += 1;
            const assetKey = meta.assetKey;
            breakdown[assetKey] = (breakdown[assetKey] || 0) + 1;
          });

          if (selectedCount === 0) {
            summary.textContent = t('tasks.bulkDownload.summaryEmpty');
          } else {
            const totalLine = document.createElement('p');
            const assetWord =
              selectedCount === 1
                ? t('tasks.bulkDownload.assetSingular')
                : t('tasks.bulkDownload.assetPlural');
            totalLine.textContent = t('tasks.bulkDownload.summarySelected', {
              count: selectedCount,
              assetWord,
            });
            const breakdownLine = document.createElement('p');
            breakdownLine.textContent = t('tasks.bulkDownload.summaryBreakdown', {
              audio: breakdown.audio || 0,
              txt: breakdown.txt || 0,
              pdf: breakdown.pdf || 0,
              md: breakdown.md || 0,
              zip: breakdown.zip || 0,
            });
            summary.appendChild(totalLine);
            summary.appendChild(breakdownLine);
          }

          if (selectAllButton) {
            selectAllButton.disabled = state.bulkDownload.availableCount === 0;
          }
          if (clearButton) {
            clearButton.disabled = state.bulkDownload.selections.size === 0;
          }
          if (submitButton) {
            submitButton.disabled = state.bulkDownload.selections.size === 0;
          }
        }

        function setBulkDownloadStatus(message = '', variant = '') {
          if (!dom.bulkDownloadDialog || !dom.bulkDownloadDialog.status) {
            return;
          }
          const element = dom.bulkDownloadDialog.status;
          element.textContent = message || '';
          element.classList.remove('error', 'success');
          if (variant === 'error') {
            element.classList.add('error');
          } else if (variant === 'success') {
            element.classList.add('success');
          }
        }

        function selectAllBulkDownload() {
          state.bulkDownload.meta.forEach((meta, key) => {
            if (!meta || !meta.available) {
              state.bulkDownload.selections.delete(key);
              return;
            }
            state.bulkDownload.selections.set(key, true);
          });
          refreshBulkDownloadCheckboxes();
          updateBulkDownloadSummary();
        }

        function clearBulkDownloadSelections() {
          if (state.bulkDownload.selections.size > 0) {
            state.bulkDownload.selections.clear();
          }
          refreshBulkDownloadCheckboxes();
          updateBulkDownloadSummary();
        }

        function handleBulkDownloadCheckboxChange(key, checked) {
          const meta = state.bulkDownload.meta.get(key);
          if (!meta || !meta.available) {
            state.bulkDownload.selections.delete(key);
          } else if (checked) {
            state.bulkDownload.selections.set(key, true);
          } else {
            state.bulkDownload.selections.delete(key);
          }
          updateBulkDownloadCheckboxState(key);
          updateBulkDownloadSummary();
        }

        let bulkDownloadDialogCleanup = null;
        let bulkDownloadPreviousFocus = null;

        function closeBulkDownloadDialog(options = {}) {
          if (typeof bulkDownloadDialogCleanup === 'function') {
            const cleanup = bulkDownloadDialogCleanup;
            bulkDownloadDialogCleanup = null;
            cleanup(options);
          }
        }

        async function handleBulkDownloadSubmit(event) {
          event?.preventDefault?.();
          if (state.bulkDownload.selections.size === 0) {
            setBulkDownloadStatus(t('tasks.bulkDownload.noneSelected'), 'error');
            return;
          }
          const grouped = new Map();
          state.bulkDownload.selections.forEach((_, key) => {
            const meta = state.bulkDownload.meta.get(key);
            if (!meta || !meta.available) {
              return;
            }
            const assets = grouped.get(meta.lectureId) || [];
            assets.push(meta.assetKey);
            grouped.set(meta.lectureId, assets);
          });
          if (!grouped.size) {
            setBulkDownloadStatus(t('tasks.bulkDownload.noneSelected'), 'error');
            return;
          }

          const submitButton = dom.bulkDownloadDialog?.submit;
          if (submitButton) {
            submitButton.disabled = true;
          }
          setBulkDownloadStatus(t('tasks.bulkDownload.preparing'), 'info');

          try {
            const items = Array.from(grouped.entries()).map(([lectureId, assets]) => ({
              lecture_id: lectureId,
              assets,
            }));
            const response = await request('/api/download/bulk', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ items }),
            });
            const archive = response?.archive;
            if (!archive || !archive.path) {
              throw new Error(t('tasks.bulkDownload.failure'));
            }
            const downloadUrl = buildStorageURL(archive.path);
            const anchor = document.createElement('a');
            anchor.href = downloadUrl;
            anchor.download = archive.filename || 'lecture-assets.zip';
            anchor.rel = 'noopener';
            document.body.appendChild(anchor);
            anchor.click();
            anchor.remove();
            const filename = archive.filename || 'archive.zip';
            setBulkDownloadStatus(t('tasks.bulkDownload.ready', { filename }), 'success');
          } catch (error) {
            const detail = error instanceof Error ? error.message : String(error);
            setBulkDownloadStatus(detail || t('tasks.bulkDownload.failure'), 'error');
          } finally {
            if (submitButton) {
              submitButton.disabled = state.bulkDownload.selections.size === 0;
            }
          }
        }

        function openBulkDownloadDialog() {
          if (
            dialogState.bulkDownloadActive ||
            dialogState.bulkProcessActive ||
            dialogState.active ||
            dialogState.uploadActive ||
            dialogState.bulkUploadActive ||
            dialogState.viewerActive
          ) {
            return;
          }
          if (!dom.bulkDownloadDialog || !dom.bulkDownloadDialog.root) {
            return;
          }

          collectBulkDownloadMeta();
          renderBulkDownloadTree();
          refreshBulkDownloadCheckboxes();
          updateBulkDownloadSummary();
          setBulkDownloadStatus('');

          const root = dom.bulkDownloadDialog.root;
          root.classList.remove('hidden');
          root.setAttribute('aria-hidden', 'false');
          document.body.classList.add('dialog-open');
          dialogState.bulkDownloadActive = true;

          bulkDownloadPreviousFocus =
            document.activeElement instanceof HTMLElement ? document.activeElement : null;

          const focusTargets = [
            dom.bulkDownloadDialog.selectAll,
            dom.bulkDownloadDialog.clear,
            dom.bulkDownloadDialog.submit,
            dom.bulkDownloadDialog.cancel,
          ].filter((element) => element instanceof HTMLElement && !element.disabled);
          if (focusTargets.length > 0) {
            focusTargets[0].focus({ preventScroll: true });
          }

          function handleSelectAll(event) {
            event?.preventDefault?.();
            setBulkDownloadStatus('');
            selectAllBulkDownload();
          }

          function handleClear(event) {
            event?.preventDefault?.();
            setBulkDownloadStatus('');
            clearBulkDownloadSelections();
          }

          function handleCancel(event) {
            event?.preventDefault?.();
            closeBulkDownloadDialog();
          }

          function handleBackdrop(event) {
            event?.preventDefault?.();
            closeBulkDownloadDialog();
          }

          function handleKeyDown(event) {
            if (event.key === 'Escape') {
              event.preventDefault();
              closeBulkDownloadDialog();
              return;
            }
            if (event.key === 'Tab') {
              const focusable = [
                dom.bulkDownloadDialog.selectAll,
                dom.bulkDownloadDialog.clear,
                dom.bulkDownloadDialog.submit,
                dom.bulkDownloadDialog.cancel,
              ].filter((element) => element instanceof HTMLElement && !element.disabled);
              if (!focusable.length) {
                return;
              }
              const currentIndex = focusable.indexOf(document.activeElement);
              const nextIndex = event.shiftKey
                ? currentIndex <= 0
                  ? focusable.length - 1
                  : currentIndex - 1
                : currentIndex === focusable.length - 1
                ? 0
                : currentIndex + 1;
              focusable[nextIndex].focus({ preventScroll: true });
              event.preventDefault();
            }
          }

          if (dom.bulkDownloadDialog.selectAll) {
            dom.bulkDownloadDialog.selectAll.addEventListener('click', handleSelectAll);
          }
          if (dom.bulkDownloadDialog.clear) {
            dom.bulkDownloadDialog.clear.addEventListener('click', handleClear);
          }
          if (dom.bulkDownloadDialog.cancel) {
            dom.bulkDownloadDialog.cancel.addEventListener('click', handleCancel);
          }
          if (dom.bulkDownloadDialog.backdrop) {
            dom.bulkDownloadDialog.backdrop.addEventListener('click', handleBackdrop);
          }
          if (dom.bulkDownloadDialog.submit) {
            dom.bulkDownloadDialog.submit.addEventListener('click', handleBulkDownloadSubmit);
          }
          if (dom.bulkDownloadDialog.window) {
            dom.bulkDownloadDialog.window.addEventListener('keydown', handleKeyDown);
          }

          bulkDownloadDialogCleanup = (options = {}) => {
            const { restoreFocus = true } = options;
            if (dom.bulkDownloadDialog.selectAll) {
              dom.bulkDownloadDialog.selectAll.removeEventListener('click', handleSelectAll);
            }
            if (dom.bulkDownloadDialog.clear) {
              dom.bulkDownloadDialog.clear.removeEventListener('click', handleClear);
            }
            if (dom.bulkDownloadDialog.cancel) {
              dom.bulkDownloadDialog.cancel.removeEventListener('click', handleCancel);
            }
            if (dom.bulkDownloadDialog.backdrop) {
              dom.bulkDownloadDialog.backdrop.removeEventListener('click', handleBackdrop);
            }
            if (dom.bulkDownloadDialog.submit) {
              dom.bulkDownloadDialog.submit.removeEventListener('click', handleBulkDownloadSubmit);
            }
            if (dom.bulkDownloadDialog.window) {
              dom.bulkDownloadDialog.window.removeEventListener('keydown', handleKeyDown);
            }

            root.classList.add('hidden');
            root.setAttribute('aria-hidden', 'true');
            dialogState.bulkDownloadActive = false;
            state.bulkDownload.checkboxMap.clear();
            if (
              !dialogState.active &&
              !dialogState.uploadActive &&
              !dialogState.bulkUploadActive &&
              !dialogState.bulkProcessActive &&
              !dialogState.viewerActive
            ) {
              document.body.classList.remove('dialog-open');
            }
            if (restoreFocus && bulkDownloadPreviousFocus) {
              bulkDownloadPreviousFocus.focus({ preventScroll: true });
            }
            bulkDownloadPreviousFocus = null;
            setBulkDownloadStatus('');
            updateBulkDownloadSummary();
          };
        }

        async function refreshTasks({ force = false, silent = false } = {}) {
          if (state.tasks.loading && !force) {
            return;
          }
          if (!dom.tasks) {
            return;
          }
          state.tasks.loading = true;
          if (!silent) {
            renderTasks();
          }
          try {
            const payload = await request('/api/tasks');
            state.tasks.queue = Array.isArray(payload?.queue) ? payload.queue : [];
            state.tasks.active = Array.isArray(payload?.active) ? payload.active : [];
          } catch (error) {
            const detail = error instanceof Error ? error.message : String(error);
            if (!silent && detail) {
              showStatus(detail, 'error');
            }
          } finally {
            state.tasks.loading = false;
            renderTasks();
          }
        }

        async function clearCompletedTasks() {
          if (!dom.tasks || state.tasks.loading) {
            return;
          }
          if (dom.tasks.clearDone) {
            dom.tasks.clearDone.disabled = true;
          }
          try {
            const payload = await request('/api/tasks/completed', { method: 'DELETE' });
            const cleared = Number(payload?.cleared) || 0;
            await refreshTasks({ force: true, silent: true });
            if (cleared > 0) {
              showStatus(t('tasks.notifications.cleared', { count: cleared }), 'success');
            }
          } catch (error) {
            const detail = error instanceof Error ? error.message : String(error);
            showStatus(detail || t('status.processing'), 'error');
            renderTasks();
          }
        }

        function stopTaskPolling() {
          if (state.tasks.timer !== null) {
            window.clearInterval(state.tasks.timer);
          }
          state.tasks.timer = null;
        }

        function startTaskPolling() {
          stopTaskPolling();
          if (!dom.tasks || !dom.tasks.container) {
            return;
          }
          let polling = false;
          const poll = async () => {
            if (polling) {
              return;
            }
            polling = true;
            try {
              await refreshTasks({ silent: true });
            } finally {
              polling = false;
            }
          };
          void poll();
          state.tasks.timer = window.setInterval(() => {
            void poll();
          }, 2500);
        }

        async function dismissTaskEntry(entry) {
          if (!entry) {
            return;
          }
          const lectureId = Number(entry.lecture_id);
          if (!Number.isFinite(lectureId)) {
            return;
          }
          const type = entry.type ? `?type=${encodeURIComponent(entry.type)}` : '';
          try {
            await request(`/api/progress/${lectureId}${type}`, { method: 'DELETE' });
            state.tasks.active = state.tasks.active.filter(
              (item) => !(Number(item?.lecture_id) === lectureId && item?.type === entry.type),
            );
            if (Array.isArray(state.tasks.queue)) {
              const entryOperation =
                (entry?.task && typeof entry.task.operation === 'string' && entry.task.operation)
                  || (entry?.type === 'processing'
                    ? entry?.context?.operation || entry?.context?.type
                    : entry?.type)
                  || '';
              state.tasks.queue = state.tasks.queue.filter((queueEntry) => {
                if (!queueEntry || Number(queueEntry.lecture_id) !== lectureId) {
                  return true;
                }
                if (queueEntry.status !== 'succeeded' && queueEntry.status !== 'failed') {
                  return true;
                }
                if (!entryOperation) {
                  return false;
                }
                return queueEntry.operation !== entryOperation;
              });
            }
            renderTasks();
          } catch (error) {
            const detail = error instanceof Error ? error.message : String(error);
            showStatus(detail || t('status.processing'), 'error');
          }
        }

        async function retryTaskEntry(entry) {
          if (!entry) {
            return;
          }
          const lectureId = Number(entry.lecture_id);
          if (!Number.isFinite(lectureId)) {
            return;
          }
          try {
            if (entry.type === 'transcription') {
              const model = entry?.context?.model || state.settings?.whisper_model || 'base';
              await request(`/api/lectures/${lectureId}/transcribe`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model }),
              });
              startTranscriptionProgress(lectureId);
            } else if (entry.type === 'processing') {
              const operation = entry?.context?.operation || entry?.context?.type;
              if (operation === 'slide_bundle') {
                const formData = new FormData();
                if (entry?.context?.preview_token) {
                  formData.append('preview_token', entry.context.preview_token);
                }
                const pageRange = entry?.context?.page_range;
                if (pageRange?.start) {
                  formData.append('page_start', String(pageRange.start));
                }
                if (pageRange?.end) {
                  formData.append('page_end', String(pageRange.end));
                }
                await request(`/api/lectures/${lectureId}/process-slides`, {
                  method: 'POST',
                  body: formData,
                });
                startProcessingProgress(lectureId);
              } else {
                showStatus(t('tasks.retryUnavailable'), 'info');
                return;
              }
            }
            await refreshTasks({ force: true, silent: true });
          } catch (error) {
            const detail = error instanceof Error ? error.message : String(error);
            showStatus(detail || t('status.processing'), 'error');
          }
        }

        async function handleTaskAction(event) {
          const target = event.target instanceof HTMLElement ? event.target : null;
          if (!target) {
            return;
          }
          const button = target.closest('button[data-task-action]');
          if (!button) {
            return;
          }
          const action = button.dataset.taskAction || '';
          const lectureId = Number(button.dataset.lectureId);
          const type = button.dataset.taskType || '';
          const entry = state.tasks.active.find(
            (item) => Number(item?.lecture_id) === lectureId && (type ? item?.type === type : true),
          );
          if (action === 'retry') {
            await retryTaskEntry(entry);
            return;
          }
          if (action === 'dismiss') {
            await dismissTaskEntry(entry);
            return;
          }
          if (action === 'open' && Number.isFinite(lectureId)) {
            await selectLecture(lectureId);
            setActiveView('details');
          }
        }

        async function handlePurgeProcessedAudio() {
          if (!dom.storage || !dom.storage.purge) {
            return;
          }
          const overview = state.storage.overview;
          const eligible = Number(overview?.eligible_audio_total) || 0;
          if (!eligible || state.storage.purging) {
            return;
          }
          const lectureWord = pluralize(currentLanguage, 'counts.lecture', eligible);
          const confirmed = await confirmDialog({
            title: t('storage.dialogs.purgeTitle'),
            message: t('storage.dialogs.purgeMessage', { count: eligible, lectureWord }),
            confirmText: t('common.actions.delete'),
            cancelText: t('dialog.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            state.storage.purging = true;
            renderStorage();
            await request('/api/storage/purge-audio', { method: 'POST' });
            showStatus(t('status.storagePurged'), 'success');
            await refreshStorage();
          } catch (error) {
            const messageText = error instanceof Error ? error.message : String(error);
            showStatus(messageText || t('status.storagePurgeFailed'), 'error');
          } finally {
            state.storage.purging = false;
            renderStorage();
          }
        }

        applyTranslations(DEFAULT_LANGUAGE);
        renderStorage();
        renderSystemUpdate();
        renderTasks();
        renderMiniConsole();
        void refreshTasks({ silent: true });

        function formatMiniConsoleTimestamp(timestamp) {
          if (!Number.isFinite(timestamp)) {
            return '';
          }
          const date = new Date(timestamp);
          try {
            return new Intl.DateTimeFormat(currentLanguage || undefined, {
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
            }).format(date);
          } catch (error) {
            return date.toLocaleTimeString();
          }
        }

        function renderMiniConsole() {
          if (!dom.miniConsole || !dom.miniConsole.entries) {
            return;
          }
          const consoleState = state.miniConsole || {};
          const entries = Array.isArray(consoleState.entries) ? consoleState.entries : [];
          const container = dom.miniConsole.entries;
          container.innerHTML = '';
          const hasEntries = entries.length > 0;
          if (dom.miniConsole.empty) {
            dom.miniConsole.empty.hidden = hasEntries;
          }
          container.hidden = !hasEntries;
          if (!hasEntries) {
            return;
          }
          entries.forEach((entry) => {
            if (!entry || typeof entry !== 'object') {
              return;
            }
            const item = document.createElement('div');
            item.className = 'mini-console-entry';
            item.dataset.variant = entry.variant || 'info';

            const header = document.createElement('div');
            header.className = 'mini-console-entry-header';
            const timestamp = formatMiniConsoleTimestamp(entry.timestamp);
            if (timestamp) {
              const timeLabel = document.createElement('span');
              timeLabel.className = 'mini-console-meta';
              timeLabel.textContent = timestamp;
              header.appendChild(timeLabel);
            }
            if (entry.progressMode === 'ratio' && typeof entry.progressRatio === 'number') {
              const ratioLabel = document.createElement('span');
              ratioLabel.className = 'mini-console-meta';
              const ratioPercent = Math.round(entry.progressRatio * 1000) / 10;
              ratioLabel.textContent = Number.isInteger(ratioPercent)
                ? `${ratioPercent}%`
                : `${ratioPercent.toFixed(1)}%`;
              header.appendChild(ratioLabel);
            }
            item.appendChild(header);

            const message = document.createElement('p');
            message.className = 'mini-console-message';
            message.textContent = entry.message || '';
            item.appendChild(message);

            if (entry.progressMode === 'ratio' && typeof entry.progressRatio === 'number') {
              const track = document.createElement('div');
              track.className = 'mini-console-progress-track';
              const fill = document.createElement('div');
              fill.className = 'mini-console-progress-fill';
              const bounded = Math.max(0, Math.min(entry.progressRatio, 1));
              fill.style.width = `${bounded * 100}%`;
              track.appendChild(fill);
              item.appendChild(track);
            } else if (entry.progressMode === 'indeterminate') {
              const track = document.createElement('div');
              track.className = 'mini-console-progress-track';
              const fill = document.createElement('div');
              fill.className = 'mini-console-progress-fill indeterminate';
              track.appendChild(fill);
              item.appendChild(track);
            }

            container.appendChild(item);
          });
        }

        function recordMiniConsoleEntry(message, variant = 'info', options = {}) {
          const consoleState = state.miniConsole;
          if (!consoleState || typeof message !== 'string') {
            return;
          }
          const normalizedMessage = message.trim();
          if (!normalizedMessage) {
            return;
          }
          if (!Array.isArray(consoleState.entries)) {
            consoleState.entries = [];
          }
          const entries = consoleState.entries;
          const ratioValue =
            typeof options.progressRatio === 'number' && Number.isFinite(options.progressRatio)
              ? Math.max(0, Math.min(options.progressRatio, 1))
              : null;
          const indeterminate = ratioValue === null && Boolean(options.persist);
          const key =
            typeof options.consoleKey === 'string' && options.consoleKey.trim().length > 0
              ? options.consoleKey.trim()
              : null;
          const timestamp = Date.now();
          let entryIndex = -1;
          if (key) {
            entryIndex = entries.findIndex((item) => item && item.key === key);
          }
          if (entryIndex === -1 && ratioValue !== null) {
            entryIndex = entries.findIndex(
              (item) =>
                item &&
                item.message === normalizedMessage &&
                item.variant === variant &&
                item.progressMode === 'ratio',
            );
          }
          if (entryIndex === -1 && indeterminate) {
            entryIndex = entries.findIndex(
              (item) =>
                item &&
                item.message === normalizedMessage &&
                item.variant === variant &&
                item.progressMode === 'indeterminate',
            );
          }
          let entry;
          if (entryIndex >= 0) {
            entry = entries[entryIndex];
            entry.message = normalizedMessage;
            entry.variant = variant;
            entry.timestamp = timestamp;
            entry.key = key || entry.key || null;
            entry.progressRatio = ratioValue;
            entry.progressMode = ratioValue !== null ? 'ratio' : indeterminate ? 'indeterminate' : null;
            if (entryIndex > 0) {
              entries.splice(entryIndex, 1);
              entries.unshift(entry);
            }
          } else {
            consoleState.sequence = (consoleState.sequence || 0) + 1;
            entry = {
              id: consoleState.sequence,
              key,
              message: normalizedMessage,
              variant,
              timestamp,
              progressRatio: ratioValue,
              progressMode: ratioValue !== null ? 'ratio' : indeterminate ? 'indeterminate' : null,
            };
            entries.unshift(entry);
          }
          const limit = Number(consoleState.maxEntries) || 4;
          while (entries.length > limit) {
            entries.pop();
          }
          renderMiniConsole();
        }

        function showStatus(message, variant = 'info', options = {}) {
          if (typeof message !== 'string') {
            return;
          }
          const normalizedMessage = message.trim();
          if (!normalizedMessage) {
            return;
          }

          const ratioValue =
            options && typeof options.progressRatio === 'number'
              ? options.progressRatio
              : null;
          const hasRatio = Number.isFinite(ratioValue);
          const clampedRatio = hasRatio
            ? Math.max(0, Math.min(Number(ratioValue), 1))
            : null;

          const miniConsoleOptions = {
            ...(options || {}),
            progressRatio: clampedRatio,
          };
          recordMiniConsoleEntry(normalizedMessage, variant, miniConsoleOptions);
        }

        function updateGpuWhisperUI(status = {}) {
          const supported = Boolean(status.supported);
          const checked = Boolean(status.checked);
          const unavailable = Boolean(status.unavailable);
          const output = typeof status.output === 'string' ? status.output : '';
          const lastChecked = status.last_checked || null;
          let message =
            typeof status.message === 'string' && status.message.trim().length > 0
              ? status.message.trim()
              : checked
              ? t('status.gpuUnavailable')
              : t('settings.whisper.gpu.status');

          state.gpuWhisper = {
            supported,
            checked,
            message,
            output,
            lastChecked,
            unavailable,
          };

          if (dom.settingsWhisperGpuStatus) {
            let displayMessage = message;
            if (output) {
              const snippet = output.split('\n').slice(0, 5).join('\n').trim();
              if (snippet && snippet !== message) {
                displayMessage = `${message}\n${snippet}`;
              }
            }
            dom.settingsWhisperGpuStatus.textContent = displayMessage;
          }

          if (dom.settingsWhisperGpuTest) {
            dom.settingsWhisperGpuTest.disabled = unavailable;
            dom.settingsWhisperGpuTest.textContent = supported
              ? t('settings.whisper.gpu.retry')
              : t('settings.whisper.gpu.test');
          }

          if (dom.gpuModelOptions) {
            dom.gpuModelOptions.forEach((option) => {
              if (option instanceof HTMLOptionElement) {
                option.disabled = !supported;
              }
            });
          }

          const requestedModel =
            state.settings?.whisper_model_requested || state.settings?.whisper_model;
          if (!supported) {
            if (dom.settingsWhisperModel && dom.settingsWhisperModel.value === GPU_MODEL) {
              dom.settingsWhisperModel.value = DEFAULT_WHISPER_MODEL;
            }
            const transcribeSelect = getTranscribeModelSelect();
            if (transcribeSelect && transcribeSelect.value === GPU_MODEL) {
              setTranscribeModelValue(DEFAULT_WHISPER_MODEL);
            }
            if (state.settings) {
              state.settings.whisper_model = dom.settingsWhisperModel
                ? dom.settingsWhisperModel.value
                : DEFAULT_WHISPER_MODEL;
            }
          } else if (requestedModel === GPU_MODEL) {
            if (dom.settingsWhisperModel) {
              dom.settingsWhisperModel.value = GPU_MODEL;
            }
            setTranscribeModelValue(GPU_MODEL);
            if (state.settings) {
              state.settings.whisper_model = GPU_MODEL;
            }
          }
        }

        function updateCloudConnectionStatus(statusKey, overrideMessage = null) {
          const normalizedKey = typeof statusKey === 'string' ? statusKey : 'idle';
          state.cloudConnection.statusKey = normalizedKey;
          if (overrideMessage && dom.settingsCloudConnectionStatus) {
            dom.settingsCloudConnectionStatus.textContent = overrideMessage;
            return;
          }
          if (dom.settingsCloudConnectionStatus) {
            dom.settingsCloudConnectionStatus.textContent = t(
              `settings.cloudConnection.status.${normalizedKey}`,
            );
          }
        }

        const CLOUD_LOCAL_ONLY_PREFIXES = ['/api/settings', '/api/system', '/api/debug'];

        function shouldRouteToCloud(target) {
          if (typeof target !== 'string') {
            return false;
          }
          if (target.startsWith('/storage/')) {
            return true;
          }
          if (!target.startsWith('/api/')) {
            return false;
          }
          return !CLOUD_LOCAL_ONLY_PREFIXES.some((prefix) => target.startsWith(prefix));
        }

        function isProcessingEndpoint(target) {
          if (typeof target !== 'string' || !target.startsWith('/api/')) {
            return false;
          }
          if (target.startsWith('/api/tasks')) {
            return true;
          }
          return (
            target.includes('/transcription-progress') ||
            target.includes('/processing-progress') ||
            target.includes('/transcribe') ||
            target.includes('/process-slides')
          );
        }

        function resolveCloudServerUrl(target) {
          if (!target || typeof target !== 'string') {
            return target;
          }
          if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(target) || target.startsWith('//')) {
            return target;
          }
          const base = normalizeCloudServerUrl(state.cloudConnection.url);
          try {
            const normalized = target.startsWith('/') ? target : `/${target}`;
            return new URL(normalized, `${base}/`).toString();
          } catch (error) {
            return target;
          }
        }

        async function refreshCloudConnectionData() {
          const selectedLectureId = state.selectedLectureId;
          await refreshData();
          if (selectedLectureId && state.selectedLectureId === selectedLectureId) {
            await selectLecture(selectedLectureId);
          }
        }

        async function testCloudConnection({ silent = false, refresh = false } = {}) {
          const baseUrl = normalizeCloudServerUrl(
            dom.settingsCloudServerUrl?.value || state.cloudConnection.url,
          );
          state.cloudConnection.url = baseUrl;
          const pingUrl = resolveCloudServerUrl('/api/cloud-connection/ping');
          if (!silent && dom.settingsCloudConnectionTest) {
            dom.settingsCloudConnectionTest.disabled = true;
          }
          try {
            const response = await fetch(pingUrl, { method: 'GET' });
            if (!response.ok) {
              throw new Error(`${response.status} ${response.statusText}`.trim());
            }
            state.cloudConnection.connected = true;
            updateCloudConnectionStatus('connected');
            if (!silent) {
              showStatus(t('settings.cloudConnection.notifications.connected'), 'success');
            }
            if (refresh && state.cloudConnection.enabled) {
              await refreshCloudConnectionData();
            }
            return true;
          } catch (error) {
            state.cloudConnection.connected = false;
            updateCloudConnectionStatus('disconnected');
            if (!silent) {
              const detail =
                error instanceof Error && error.message
                  ? error.message
                  : t('settings.cloudConnection.errors.unavailable');
              showStatus(detail, 'error');
            }
            return false;
          } finally {
            if (dom.settingsCloudConnectionTest) {
              dom.settingsCloudConnectionTest.disabled = false;
            }
          }
        }

        async function cancelCloudProcessingTasks({ reason, silent = false, force = false } = {}) {
          if (
            !state.cloudConnection.enabled ||
            state.cloudConnection.processingTarget !== 'local' ||
            (!state.cloudConnection.connected && !force)
          ) {
            return;
          }
          const payload = JSON.stringify({
            reason: typeof reason === 'string' ? reason : t('settings.cloudConnection.cancelReason'),
          });
          const url = resolveAppUrl('/api/tasks/cancel');
          if (navigator.sendBeacon) {
            try {
              const blob = new Blob([payload], { type: 'application/json' });
              navigator.sendBeacon(url, blob);
              return;
            } catch (error) {
              // Fall back to fetch.
            }
          }
          try {
            await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: payload,
              keepalive: true,
            });
          } catch (error) {
            if (!silent) {
              console.warn('Unable to cancel cloud connection local tasks', error);
            }
          }
        }

        async function handleCloudConnectionDisconnect(error) {
          if (!state.cloudConnection.enabled) {
            return;
          }
          state.cloudConnection.connected = false;
          updateCloudConnectionStatus('disconnected');
          const detail =
            error instanceof Error && error.message
              ? error.message
              : t('settings.cloudConnection.errors.unavailable');
          showStatus(detail, 'error');
        }

        function ensureDebugPlaceholder() {
          if (!dom.debugLog || !dom.debugEmpty) {
            return;
          }
          if (!dom.debugEmpty.parentElement) {
            dom.debugLog.appendChild(dom.debugEmpty);
          }
        }

        function normalizeCorrelationValue(value) {
          if (typeof value === 'string') {
            return value.trim();
          }
          if (value == null) {
            return '';
          }
          return String(value).trim();
        }

        function getEntryCorrelation(entry, key) {
          if (!entry || typeof entry !== 'object') {
            return '';
          }
          const sources = [entry[key], entry?.context?.[key], entry?.payload?.[key]];
          for (const source of sources) {
            const normalized = normalizeCorrelationValue(source);
            if (normalized) {
              return normalized;
            }
          }
          return '';
        }

        function normalizeFilterValue(value) {
          if (typeof value === 'string') {
            return value.trim().toLowerCase();
          }
          if (typeof value === 'number' || typeof value === 'boolean') {
            return String(value).trim().toLowerCase();
          }
          return '';
        }

        function hasActiveFilters() {
          const filters = state.debug.filters || {};
          if (
            normalizeFilterValue(filters.severity) &&
            normalizeFilterValue(filters.severity) !== 'all'
          ) {
            return true;
          }
          if (
            normalizeFilterValue(filters.category) &&
            normalizeFilterValue(filters.category) !== 'all'
          ) {
            return true;
          }
          return Boolean(
            normalizeFilterValue(filters.correlationId) ||
              normalizeFilterValue(filters.taskId) ||
              normalizeFilterValue(filters.query),
          );
        }

        function getEntrySeverity(entry) {
          const sources = [entry?.severity, entry?.level, entry?.status];
          for (const source of sources) {
            if (typeof source === 'string') {
              const normalized = source.trim().toLowerCase();
              if (!normalized) {
                continue;
              }
              if (normalized === 'failed' || normalized === 'failure') {
                return 'error';
              }
              return normalized;
            }
          }
          if (typeof entry?.context?.severity === 'string') {
            const normalized = entry.context.severity.trim().toLowerCase();
            if (normalized) {
              return normalized;
            }
          }
          if (typeof entry?.payload?.severity === 'string') {
            const normalized = entry.payload.severity.trim().toLowerCase();
            if (normalized) {
              return normalized;
            }
          }
        return 'info';
      }

      function getEntryCategory(entry) {
        const category = normalizeFilterValue(entry?.category);
        if (category) {
          return category;
        }
        const hasTaskId = Boolean(getEntryCorrelation(entry, 'task_id') || getEntryCorrelation(entry, 'taskId'));
        if (hasTaskId) {
          return 'task';
        }
        return 'app';
      }

      function getEntryTaskId(entry) {
        const taskKeys = ['task_id', 'taskId', 'job_id', 'jobId'];
        for (const key of taskKeys) {
          const value = getEntryCorrelation(entry, key);
          if (value) {
            return value;
          }
        }
        if (typeof entry?.task === 'string' && entry.task.trim()) {
          return entry.task.trim();
        }
        return '';
      }

      function collectEntryCorrelations(entry) {
        const values = new Set();
        const append = (value) => {
          const normalized = normalizeCorrelationValue(value);
          if (normalized) {
            values.add(normalized);
          }
        };
        const correlationKeys = [
          'correlation_id',
          'correlationId',
          'request_id',
          'requestId',
          'job_id',
          'jobId',
          'actor',
          'task_id',
          'taskId',
          'trace_id',
          'span_id',
          'parent_request_id',
        ];
        correlationKeys.forEach((key) => {
          append(getEntryCorrelation(entry, key));
        });
        if (Array.isArray(entry?.correlation_ids)) {
          entry.correlation_ids.forEach((value) => append(value));
        }
        if (typeof entry?.correlation_id === 'string') {
          append(entry.correlation_id);
        }
        return Array.from(values);
      }

      function entryMatchesQuery(entry, query) {
        const normalizedQuery = normalizeFilterValue(query);
        if (!normalizedQuery) {
          return true;
        }
        const segments = [];
        const append = (value) => {
          if (value == null) {
            return;
          }
          if (typeof value === 'string') {
            const normalized = value.toLowerCase();
            if (normalized) {
              segments.push(normalized);
            }
            return;
          }
          if (typeof value === 'number' || typeof value === 'boolean') {
            segments.push(String(value).toLowerCase());
            return;
          }
          if (typeof value === 'object') {
            try {
              const serialized = JSON.stringify(value);
              if (serialized) {
                segments.push(serialized.toLowerCase());
              }
            } catch (error) {
              console.warn('Unable to serialize log entry for search', error);
            }
          }
        };

        append(entry?.message);
        append(entry?.rendered);
        append(entry?.event_type);
        append(entry?.logger);
        append(entry?.category);
        append(entry?.context);
        append(entry?.payload);
        append(entry?.stack);
        append(entry?.error);
        append(entry?.exception);

        return segments.some((segment) => segment.includes(normalizedQuery));
      }

      function isEntryFailure(entry) {
        const severity = getEntrySeverity(entry);
        if (severity === 'error' || severity === 'critical') {
          return true;
        }
        const status = normalizeFilterValue(entry?.status);
        if (status === 'failed' || status === 'error') {
          return true;
        }
        const contextStatus = normalizeFilterValue(entry?.context?.status);
        if (contextStatus === 'failed' || contextStatus === 'error') {
          return true;
        }
        const payloadStatus = normalizeFilterValue(entry?.payload?.status);
        if (payloadStatus === 'failed' || payloadStatus === 'error') {
          return true;
        }
        if (typeof entry?.error === 'string' && entry.error.trim()) {
          return true;
        }
        if (typeof entry?.exception === 'string' && entry.exception.trim()) {
          return true;
        }
        return false;
      }

      function formatTimestamp(value) {
        if ((typeof value !== 'string' && typeof value !== 'number') || value === '') {
          return '';
        }
        const parsed = new Date(value);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed.toLocaleTimeString([], {
            hour12: false,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
          });
        }
        if (typeof value === 'string') {
          return value;
        }
        return '';
      }

      function matchesDebugFilters(entry) {
        const filters = state.debug.filters || {};
        const severityFilter = normalizeFilterValue(filters.severity);
        if (severityFilter && severityFilter !== 'all') {
          const entrySeverity = getEntrySeverity(entry);
          if (severityFilter === 'error') {
            if (entrySeverity !== 'error' && entrySeverity !== 'critical') {
              return false;
            }
          } else if (entrySeverity !== severityFilter) {
            return false;
          }
        }

        const categoryFilter = normalizeFilterValue(filters.category);
        if (categoryFilter && categoryFilter !== 'all') {
          const entryCategory = getEntryCategory(entry);
          if (entryCategory !== categoryFilter) {
            return false;
          }
        }

        const correlationFilter = normalizeFilterValue(filters.correlationId);
        if (correlationFilter) {
          const correlations = collectEntryCorrelations(entry).map((value) => value.toLowerCase());
          const match = correlations.some((value) => value.includes(correlationFilter));
          if (!match) {
            return false;
          }
        }

        const taskFilter = normalizeFilterValue(filters.taskId);
        if (taskFilter) {
          const taskId = normalizeFilterValue(getEntryTaskId(entry));
          if (!taskId || !taskId.includes(taskFilter)) {
            return false;
          }
        }

        const query = filters.query;
        if (typeof query === 'string' && normalizeFilterValue(query)) {
          if (!entryMatchesQuery(entry, query)) {
            return false;
          }
        }

        return true;
      }

      function applyDebugFilters(entries) {
        const list = Array.isArray(entries) ? entries : [];
        return list.filter((entry) => matchesDebugFilters(entry));
      }

      function summarizeEntryDetails(entry) {
        const ignore = new Set([
          'request_id',
          'requestId',
          'job_id',
          'jobId',
          'actor',
          'correlation_id',
          'correlationId',
          'task_id',
          'taskId',
          'retry',
          'retry_count',
          'attempt',
          'duplicate',
          'is_duplicate',
        ]);
        const segments = [];
        const seen = new Set();
        const appendFrom = (source) => {
          if (!source || typeof source !== 'object') {
            return;
          }
          Object.entries(source).forEach(([key, value]) => {
            if (!key || ignore.has(key)) {
              return;
            }
            const normalized = normalizeCorrelationValue(value);
            if (!normalized) {
              return;
            }
            const label = `${key}: ${normalized}`;
            if (seen.has(label)) {
              return;
            }
            seen.add(label);
            segments.push(label);
          });
        };
        appendFrom(entry?.context);
        appendFrom(entry?.payload);
        if (typeof entry?.count === 'number' && entry.count > 1) {
          const label = `occurrences: ${entry.count}`;
          if (!seen.has(label)) {
            seen.add(label);
            segments.push(label);
          }
        }
        if (typeof entry?.last_duration_ms === 'number') {
          const last = entry.last_duration_ms.toFixed(1).replace(/\.0$/, '');
          const label = `last ${last} ms`;
          if (!seen.has(label)) {
            seen.add(label);
            segments.push(label);
          }
        }
        if (typeof entry?.average_duration_ms === 'number' && entry.average_duration_ms > 0) {
          const avg = entry.average_duration_ms.toFixed(1).replace(/\.0$/, '');
          const label = `avg ${avg} ms`;
          if (!seen.has(label)) {
            seen.add(label);
            segments.push(label);
          }
        }
        return segments;
      }

      function extractStackTrace(entry) {
        const candidates = [
          entry?.stack,
          entry?.exception?.stack,
          entry?.exception?.stacktrace,
          entry?.exception?.traceback,
          entry?.traceback,
          entry?.context?.stack,
          entry?.context?.stacktrace,
          entry?.context?.traceback,
          entry?.payload?.stack,
          entry?.payload?.stacktrace,
          entry?.payload?.trace,
        ];
        for (const candidate of candidates) {
          if (typeof candidate === 'string' && candidate.trim()) {
            return candidate.trim();
          }
          if (Array.isArray(candidate) && candidate.length) {
            return candidate.join('\n');
          }
        }
        return '';
      }

      function extractCombinedContext(entry) {
        const combined = {};
        let hasValues = false;
        const merge = (source) => {
          if (!source || typeof source !== 'object') {
            return;
          }
          Object.entries(source).forEach(([key, value]) => {
            if (value === undefined) {
              return;
            }
            if (typeof key !== 'string' || !key) {
              return;
            }
            combined[key] = value;
            hasValues = true;
          });
        };
        merge(entry?.context);
        merge(entry?.payload);
        merge(entry?.extra);
        if (!hasValues) {
          return '';
        }
        try {
          return JSON.stringify(combined, null, 2);
        } catch (error) {
          console.warn('Unable to stringify log context', error);
          return String(combined);
        }
      }

      function extractEntryBadges(entry) {
        const badges = [];
        const retryCandidates = [
          entry?.retry,
          entry?.context?.retry,
          entry?.context?.retry_count,
          entry?.payload?.retry,
          entry?.payload?.retry_count,
          entry?.attempt,
          entry?.context?.attempt,
          entry?.payload?.attempt,
        ];
        let retryCount = null;
        retryCandidates.forEach((value) => {
          if (Number.isFinite(value)) {
            const numeric = Number(value);
            if (numeric > 0) {
              retryCount = retryCount === null ? numeric : Math.max(retryCount, numeric);
            }
          } else if (typeof value === 'string' && value.trim()) {
            const numeric = Number.parseInt(value.trim(), 10);
            if (!Number.isNaN(numeric) && numeric > 0) {
              retryCount = retryCount === null ? numeric : Math.max(retryCount, numeric);
            }
          }
        });
        if (retryCount !== null) {
          badges.push({ label: `retry ${retryCount}`, variant: 'warning' });
        } else {
          const retryFlag = retryCandidates.some((value) => {
            if (typeof value === 'boolean') {
              return value;
            }
            if (typeof value === 'string') {
              const normalized = value.trim().toLowerCase();
              return normalized === 'true' || normalized === 'retry';
            }
            return false;
          });
          if (retryFlag) {
            badges.push({ label: 'retry', variant: 'warning' });
          }
        }

        const duplicateCandidates = [
          entry?.duplicate,
          entry?.is_duplicate,
          entry?.context?.duplicate,
          entry?.context?.is_duplicate,
          entry?.payload?.duplicate,
          entry?.payload?.is_duplicate,
        ];
        const hasDuplicate = duplicateCandidates.some((value) => {
          if (typeof value === 'boolean') {
            return value;
          }
          if (typeof value === 'string') {
            const normalized = value.trim().toLowerCase();
            return normalized === 'true' || normalized === 'duplicate';
          }
          return false;
        });
        if (hasDuplicate) {
          badges.push({ label: 'duplicate', variant: 'accent' });
        }

        return badges;
      }

      async function copyTextToClipboard(text) {
        if (!text) {
          throw new Error('Nothing to copy');
        }
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
          return;
        }

        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'fixed';
        textarea.style.top = '-9999px';
        document.body.appendChild(textarea);
        textarea.select();
        textarea.setSelectionRange(0, textarea.value.length);
        try {
          const successful = document.execCommand('copy');
          if (!successful) {
            throw new Error('execCommand copy failed');
          }
        } finally {
          document.body.removeChild(textarea);
        }
      }

      function createCopyButton(getText) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'debug-copy-button';
        button.textContent = 'Copy';
        button.setAttribute('aria-label', 'Copy message');
        button.title = 'Copy message';

        const updateDisabledState = () => {
          try {
            const text = getText();
            button.disabled = !text;
          } catch (error) {
            button.disabled = true;
          }
        };

        updateDisabledState();

        let resetTimer = null;
        button.addEventListener('click', async () => {
          const originalText = 'Copy';
          const copiedText = 'Copied!';
          const errorText = 'Copy failed';
          window.clearTimeout(resetTimer);
          try {
            const text = getText();
            if (!text) {
              throw new Error('Nothing to copy');
            }
            await copyTextToClipboard(text);
            button.dataset.state = 'copied';
            button.textContent = copiedText;
          } catch (error) {
            console.error('Failed to copy message', error);
            button.dataset.state = 'error';
            button.textContent = errorText;
          }
          resetTimer = window.setTimeout(() => {
            button.dataset.state = '';
            button.textContent = originalText;
            updateDisabledState();
          }, 2000);
        });

        return button;
      }

      function buildDebugLogEntry(entry, { isFirstFailure = false } = {}) {
        const severity = getEntrySeverity(entry);
        const category = getEntryCategory(entry);
        const element = document.createElement('article');
        element.className = 'debug-log-entry';
        element.dataset.severity = severity;
        element.dataset.category = category;
        if (entry && typeof entry === 'object' && entry.id != null) {
          element.dataset.entryId = String(entry.id);
        }
        if (isFirstFailure) {
          element.classList.add('is-first-failure');
        }

        const timeline = document.createElement('div');
        timeline.className = 'debug-log-entry-timeline';
        const dot = document.createElement('div');
        dot.className = 'debug-log-entry-dot';
        timeline.appendChild(dot);
        element.appendChild(timeline);

        const body = document.createElement('div');
        body.className = 'debug-log-entry-body';
        element.appendChild(body);

        const header = document.createElement('header');
        header.className = 'debug-log-entry-header';
        body.appendChild(header);

        const title = document.createElement('div');
        title.className = 'debug-log-entry-title';
        header.appendChild(title);

        const severityBadge = document.createElement('span');
        severityBadge.className = 'debug-log-severity';
        severityBadge.dataset.variant = severity;
        severityBadge.textContent = severity;
        title.appendChild(severityBadge);

        const eventType = normalizeCorrelationValue(entry?.event_type || entry?.logger || entry?.category);
        if (eventType) {
          const badge = document.createElement('span');
          badge.className = 'debug-log-badge';
          badge.dataset.variant = 'accent';
          badge.textContent = eventType;
          title.appendChild(badge);
        }

        if (entry?.level != null && entry.level !== '') {
          const levelText =
            typeof entry.level === 'string' && entry.level.trim()
              ? entry.level.trim()
              : String(entry.level);
          if (levelText) {
            const levelBadge = document.createElement('span');
            levelBadge.className = 'debug-log-tag';
            levelBadge.textContent = levelText;
            title.appendChild(levelBadge);
          }
        }

        if (category && category !== 'app') {
          const categoryBadge = document.createElement('span');
          categoryBadge.className = 'debug-log-tag';
          categoryBadge.textContent = category;
          title.appendChild(categoryBadge);
        }

        const timestampSource =
          entry?.last_seen || entry?.first_seen || entry?.timestamp || entry?.time || entry?.created_at;
        const formattedTime = formatTimestamp(timestampSource);
        if (formattedTime) {
          const timeElement = document.createElement('span');
          timeElement.className = 'debug-log-time';
          timeElement.textContent = formattedTime;
          header.appendChild(timeElement);
        }

        const renderedValue =
          typeof entry?.rendered === 'string' && entry.rendered
            ? entry.rendered
            : entry?.message != null
            ? entry.message
            : '';
        const messageText =
          typeof renderedValue === 'string' ? renderedValue : String(renderedValue ?? '');
        const messageWrapper = document.createElement('div');
        messageWrapper.className = 'debug-log-message-wrapper';
        const messageElement = document.createElement('div');
        messageElement.className = 'debug-log-message';
        messageElement.textContent = messageText;
        messageWrapper.appendChild(messageElement);
        const copyButton = createCopyButton(() => messageElement.textContent || '');
        messageWrapper.appendChild(copyButton);
        body.appendChild(messageWrapper);

        const meta = document.createElement('div');
        meta.className = 'debug-log-entry-meta';
        const correlationLabels = [
          ['request_id', 'req'],
          ['job_id', 'job'],
          ['actor', 'actor'],
          ['correlation_id', 'corr'],
          ['task_id', 'task'],
          ['trace_id', 'trace'],
        ];
        const seenCorrelation = new Set();
        correlationLabels.forEach(([key, label]) => {
          const value = getEntryCorrelation(entry, key);
          if (value && !seenCorrelation.has(`${key}:${value}`)) {
            seenCorrelation.add(`${key}:${value}`);
            const tag = document.createElement('span');
            tag.className = 'debug-log-tag';
            tag.textContent = `${label} ${value}`;
            meta.appendChild(tag);
          }
        });

        const correlations = collectEntryCorrelations(entry);
        correlations.forEach((value) => {
          if (!seenCorrelation.has(value)) {
            seenCorrelation.add(value);
            const tag = document.createElement('span');
            tag.className = 'debug-log-tag';
            tag.textContent = value;
            meta.appendChild(tag);
          }
        });

        const badges = extractEntryBadges(entry);
        if (badges.length) {
          const badgeRow = document.createElement('div');
          badgeRow.className = 'debug-log-entry-badges';
          badges.forEach((badge) => {
            const badgeElement = document.createElement('span');
            badgeElement.className = 'debug-log-badge';
            if (badge.variant) {
              badgeElement.dataset.variant = badge.variant;
            }
            badgeElement.textContent = badge.label;
            badgeRow.appendChild(badgeElement);
          });
          meta.appendChild(badgeRow);
        }

        if (meta.childElementCount > 0) {
          body.appendChild(meta);
        }

        const detailTags = summarizeEntryDetails(entry);
        if (detailTags.length) {
          const detailRow = document.createElement('div');
          detailRow.className = 'debug-log-context';
          detailTags.slice(0, 8).forEach((detail) => {
            const detailTag = document.createElement('span');
            detailTag.className = 'debug-log-tag';
            detailTag.textContent = detail;
            detailRow.appendChild(detailTag);
          });
          body.appendChild(detailRow);
        }

        const stackTrace = extractStackTrace(entry);
        const contextJson = extractCombinedContext(entry);
        if (stackTrace || contextJson) {
          const expandable = document.createElement('details');
          expandable.className = 'debug-log-entry-expandable';
          if (severity === 'error' || severity === 'critical') {
            expandable.dataset.variant = 'error';
          }
          const summary = document.createElement('summary');
          if (stackTrace && contextJson) {
            summary.textContent = 'View stack trace & context';
          } else if (stackTrace) {
            summary.textContent = 'View stack trace';
          } else {
            summary.textContent = 'View context';
          }
          expandable.appendChild(summary);

          if (stackTrace) {
            const stackBlock = document.createElement('div');
            stackBlock.className = 'debug-log-entry-expandable-block';
            const stackLabel = document.createElement('div');
            stackLabel.className = 'debug-log-entry-expandable-label';
            stackLabel.textContent = 'Stack trace';
            const stackPre = document.createElement('pre');
            stackPre.textContent = stackTrace;
            stackBlock.appendChild(stackLabel);
            stackBlock.appendChild(stackPre);
            expandable.appendChild(stackBlock);
          }

          if (contextJson) {
            const contextBlock = document.createElement('div');
            contextBlock.className = 'debug-log-entry-expandable-block';
            const contextLabel = document.createElement('div');
            contextLabel.className = 'debug-log-entry-expandable-label';
            contextLabel.textContent = 'Context';
            const contextPre = document.createElement('pre');
            contextPre.textContent = contextJson;
            contextBlock.appendChild(contextLabel);
            contextBlock.appendChild(contextPre);
            expandable.appendChild(contextBlock);
          }

          body.appendChild(expandable);
        }

        return element;
      }

      function buildDebugStreamEntry(entry) {
        const severity = getEntrySeverity(entry);
        const element = document.createElement('div');
        element.className = 'debug-stream-entry';
        element.dataset.severity = severity;

        const header = document.createElement('div');
        header.className = 'debug-stream-entry-header';
        const title = document.createElement('span');
        title.className = 'debug-stream-entry-title';
        title.textContent = normalizeCorrelationValue(
          entry?.event_type || entry?.logger || entry?.category || 'event',
        );
        header.appendChild(title);

        const timestamp =
          entry?.timestamp || entry?.last_seen || entry?.first_seen || entry?.time || entry?.created_at;
        const formattedTime = formatTimestamp(timestamp);
        if (formattedTime) {
          const timeElement = document.createElement('span');
          timeElement.className = 'debug-stream-entry-time';
          timeElement.textContent = formattedTime;
          header.appendChild(timeElement);
        }
        element.appendChild(header);

        const rendered =
          typeof entry?.message === 'string' && entry.message
            ? entry.message
            : typeof entry?.rendered === 'string'
            ? entry.rendered
            : entry?.message != null
            ? String(entry.message)
            : '';
        const messageWrapper = document.createElement('div');
        messageWrapper.className = 'debug-stream-entry-message-wrapper';
        const messageElement = document.createElement('div');
        messageElement.className = 'debug-stream-entry-message';
        messageElement.textContent =
          typeof rendered === 'string' ? rendered : String(rendered ?? '');
        messageWrapper.appendChild(messageElement);
        const copyButton = createCopyButton(() => messageElement.textContent || '');
        messageWrapper.appendChild(copyButton);
        element.appendChild(messageWrapper);

        const meta = document.createElement('div');
        meta.className = 'debug-stream-entry-meta';
        const statusValue =
          entry?.status != null ? entry.status : entry?.context?.status ?? entry?.payload?.status;
        const statusText =
          typeof statusValue === 'string'
            ? statusValue
            : statusValue != null
            ? String(statusValue)
            : '';
        if (statusText) {
          const statusTag = document.createElement('span');
          statusTag.className = 'debug-log-tag';
          statusTag.textContent = `status ${statusText}`;
          meta.appendChild(statusTag);
        }
        const phaseValue = entry?.context?.phase || entry?.payload?.phase || entry?.phase;
        const phaseText =
          typeof phaseValue === 'string'
            ? phaseValue
            : phaseValue != null
            ? String(phaseValue)
            : '';
        if (phaseText) {
          const phaseTag = document.createElement('span');
          phaseTag.className = 'debug-log-tag';
          phaseTag.textContent = `phase ${phaseText}`;
          meta.appendChild(phaseTag);
        }
        const correlations = collectEntryCorrelations(entry);
        correlations.slice(0, 3).forEach((value) => {
          const tag = document.createElement('span');
          tag.className = 'debug-log-tag';
          tag.textContent = value;
          meta.appendChild(tag);
        });
        const badges = extractEntryBadges(entry);
        badges.forEach((badge) => {
          const badgeElement = document.createElement('span');
          badgeElement.className = 'debug-log-badge';
          if (badge.variant) {
            badgeElement.dataset.variant = badge.variant;
          }
          badgeElement.textContent = badge.label;
          meta.appendChild(badgeElement);
        });
        if (meta.childElementCount > 0) {
          element.appendChild(meta);
        }

        if (entry?.error != null && entry.error !== '') {
          const errorText =
            typeof entry.error === 'string' ? entry.error : String(entry.error);
          const errorLine = document.createElement('div');
          errorLine.className = 'debug-stream-entry-error';
          errorLine.textContent = errorText;
          element.appendChild(errorLine);
        }

        return element;
      }

      function renderDebugHeartbeat(entries, firstFailureIndex) {
        if (!dom.debugHeartbeat || !dom.debugHeartbeatTrack) {
          return;
        }
        const track = dom.debugHeartbeatTrack;
        track.innerHTML = '';
        if (!Array.isArray(entries) || entries.length === 0) {
          dom.debugHeartbeat.dataset.state = 'idle';
          return;
        }
        dom.debugHeartbeat.dataset.state = 'active';
        const maxDots = 60;
        const startIndex = Math.max(0, entries.length - maxDots);
        const visible = entries.slice(startIndex);
        let highlightIndex = firstFailureIndex;
        if (highlightIndex < startIndex) {
          highlightIndex = -1;
          for (let index = startIndex; index < entries.length; index += 1) {
            if (isEntryFailure(entries[index])) {
              highlightIndex = index;
              break;
            }
          }
        }
        const fragment = document.createDocumentFragment();
        visible.forEach((entry, index) => {
          const absoluteIndex = startIndex + index;
          const dot = document.createElement('span');
          dot.className = 'debug-heartbeat-dot';
          dot.dataset.severity = getEntrySeverity(entry);
          const timestampSource = entry?.last_seen || entry?.first_seen || entry?.timestamp || entry?.time;
          const formattedTime = formatTimestamp(timestampSource);
          const eventType = normalizeCorrelationValue(entry?.event_type || entry?.logger || entry?.category);
          const messageSource =
            typeof entry?.message === 'string'
              ? entry.message
              : entry?.message != null
              ? String(entry.message)
              : '';
          const messageSnippet = messageSource ? messageSource.slice(0, 80) : '';
          const parts = [formattedTime, eventType, messageSnippet].filter(Boolean);
          if (parts.length) {
            dot.title = parts.join('  ');
          }
          if (absoluteIndex === highlightIndex) {
            dot.classList.add('is-failure');
          }
          fragment.appendChild(dot);
        });
        track.appendChild(fragment);
      }

      function renderDebugLogs() {
        if (!dom.debugLog) {
          return;
        }
        ensureDebugPlaceholder();
        const entries = Array.isArray(state.debug.entries)
          ? state.debug.entries.slice(-MAX_DEBUG_LOG_ENTRIES)
          : [];
        const filtered = applyDebugFilters(entries);
        const firstFailureIndex = filtered.findIndex((entry) => isEntryFailure(entry));
        renderDebugHeartbeat(filtered, firstFailureIndex);
        const container = dom.debugLog;
        const existing = Array.from(container.children).filter((child) => child !== dom.debugEmpty);
        existing.forEach((child) => {
          container.removeChild(child);
        });
        const hasServerEntries = Array.isArray(state.debug.serverEntries)
          ? state.debug.serverEntries.length > 0
          : false;
        const hasTaskEntries = Array.isArray(state.debug.tasks)
          ? state.debug.tasks.length > 0
          : false;
        if (!filtered.length) {
          if (dom.debugEmpty) {
            if (hasActiveFilters()) {
              dom.debugEmpty.textContent = FILTERED_DEBUG_EMPTY_TEXT;
              dom.debugEmpty.hidden = false;
            } else {
              dom.debugEmpty.textContent = DEFAULT_DEBUG_EMPTY_TEXT;
              dom.debugEmpty.hidden = hasServerEntries || hasTaskEntries;
            }
          }
          if (state.debug.autoScroll) {
            container.scrollTop = container.scrollHeight;
          }
          return;
        }

        if (dom.debugEmpty) {
          dom.debugEmpty.textContent = DEFAULT_DEBUG_EMPTY_TEXT;
          dom.debugEmpty.hidden = true;
        }

        const fragment = document.createDocumentFragment();
        filtered.forEach((entry, index) => {
          fragment.appendChild(
            buildDebugLogEntry(entry, { isFirstFailure: index === firstFailureIndex }),
          );
        });
        container.appendChild(fragment);

        if (state.debug.autoScroll) {
          container.scrollTop = container.scrollHeight;
        }
      }

      function setDebugFilter(field, value) {
        const filters = state.debug.filters || {
          severity: 'all',
          category: 'all',
          correlationId: '',
          taskId: '',
          query: '',
        };
        let next = typeof value === 'string' ? value.trim() : '';
        if ((field === 'severity' || field === 'category') && !next) {
          next = 'all';
        }
        if (filters[field] === next) {
          return;
        }
        state.debug.filters = {
          ...filters,
          [field]: next,
        };
        renderDebugLogs();
      }

      function normalizeServerEntry(entry) {
        if (entry == null) {
          return null;
        }
        if (typeof entry === 'string') {
          return {
            id: `server-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`,
            category: SERVER_LOG_CATEGORY,
            severity: 'info',
            event_type: 'server',
            timestamp: new Date().toISOString(),
            message: entry,
            context: {},
            payload: {},
          };
        }
        if (typeof entry !== 'object') {
          return null;
        }
        const message =
          typeof entry.message === 'string' && entry.message
            ? entry.message
            : typeof entry.rendered === 'string'
            ? entry.rendered
            : '';
        const timestamp =
          entry.last_seen ||
          entry.first_seen ||
          entry.timestamp ||
          entry.time ||
          entry.created_at ||
          '';
        return {
          id:
            entry.id != null
              ? `server-${entry.id}`
              : `server-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`,
          category: normalizeFilterValue(entry.category) || SERVER_LOG_CATEGORY,
          severity: getEntrySeverity(entry),
          event_type: entry.event_type || entry.logger || 'server',
          timestamp,
          message,
          context: typeof entry.context === 'object' && entry.context ? entry.context : {},
          payload: typeof entry.payload === 'object' && entry.payload ? entry.payload : {},
          error: entry.error,
          stack: entry.stack,
        };
      }

      function normalizeTaskEntry(entry) {
        if (!entry || typeof entry !== 'object') {
          return null;
        }
        const payload = typeof entry.payload === 'object' && entry.payload ? entry.payload : {};
        const rawTaskId =
          payload.task_id ||
          entry.task_id ||
          entry.taskId ||
          payload.job_id ||
          entry.id;
        const taskId = normalizeCorrelationValue(rawTaskId) || `task-${Date.now()}`;
        const statusValue = payload.status || payload.phase || entry.status || entry.level || '';
        const normalizedStatus = normalizeFilterValue(statusValue);
        let severity = getEntrySeverity(entry);
        if (normalizedStatus === 'failed' || normalizedStatus === 'failure' || normalizedStatus === 'error') {
          severity = 'error';
        } else if (normalizedStatus === 'warning' || normalizedStatus === 'warn') {
          severity = 'warning';
        }
        const timestamp =
          payload.updated_at ||
          payload.completed_at ||
          payload.started_at ||
          entry.last_seen ||
          entry.timestamp ||
          entry.time ||
          entry.created_at ||
          '';
        const message =
          payload.message ||
          payload.step ||
          entry.message ||
          entry.rendered ||
          '';
        const context = {
          status: statusValue || '',
          phase: payload.phase || '',
          task_id: taskId,
          lecture_id: payload.lecture_id || '',
        };
        const updatedAt = (() => {
          const candidate = Date.parse(timestamp || '');
          if (!Number.isNaN(candidate)) {
            return candidate;
          }
          return Date.now();
        })();
        const normalized = {
          id: taskId,
          taskId,
          category: 'task',
          severity,
          status: statusValue || '',
          event_type: payload.operation || entry.event_type || 'task',
          timestamp,
          message,
          context,
          payload,
          updatedAt,
        };
        if (payload.error || entry.error) {
          normalized.error = payload.error || entry.error;
        }
        if (entry.exception) {
          normalized.exception = entry.exception;
        }
        return normalized;
      }

      function updateDebugStatus(message) {
        if (!dom.debugStatus) {
          return;
        }
        if (message) {
            dom.debugStatus.hidden = false;
            dom.debugStatus.textContent = message;
          } else {
            dom.debugStatus.hidden = true;
            dom.debugStatus.textContent = '';
          }
        }

        function updateServerStream(serverEntries, taskEntries, { reset = false } = {}) {
          if (reset || !Array.isArray(state.debug.serverEntries)) {
            state.debug.serverEntries = [];
          }
          if (reset || !Array.isArray(state.debug.tasks)) {
            state.debug.tasks = [];
          }

          const normalizedServerEntries = Array.isArray(serverEntries)
            ? serverEntries.map((entry) => normalizeServerEntry(entry)).filter(Boolean)
            : [];
          const existingServerEntries = Array.isArray(state.debug.serverEntries)
            ? state.debug.serverEntries.map((entry) => normalizeServerEntry(entry)).filter(Boolean)
            : [];
          state.debug.serverEntries = existingServerEntries
            .concat(normalizedServerEntries)
            .slice(-MAX_SERVER_STREAM_ENTRIES);

          const normalizedTaskEntries = Array.isArray(taskEntries)
            ? taskEntries.map((entry) => normalizeTaskEntry(entry)).filter(Boolean)
            : [];
          const existingTasks = Array.isArray(state.debug.tasks)
            ? state.debug.tasks.map((task) => normalizeTaskEntry(task)).filter(Boolean)
            : [];
          if (normalizedTaskEntries.length) {
            const existing = new Map();
            existingTasks.forEach((task) => {
              if (task && task.taskId) {
                existing.set(task.taskId, task);
              }
            });
            normalizedTaskEntries.forEach((task) => {
              existing.set(task.taskId, task);
            });
            state.debug.tasks = Array.from(existing.values())
              .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
              .slice(0, MAX_SERVER_STREAM_ENTRIES);
          } else {
            state.debug.tasks = existingTasks.slice(0, MAX_SERVER_STREAM_ENTRIES);
          }

          if (!dom.debugStreamEntries) {
            return;
          }

          dom.debugStreamEntries.innerHTML = '';
          const hasTasks = Array.isArray(state.debug.tasks) && state.debug.tasks.length > 0;
          const hasServerMessages =
            Array.isArray(state.debug.serverEntries) && state.debug.serverEntries.length > 0;
          if (!hasTasks && !hasServerMessages) {
            if (dom.debugStreamEmpty) {
              dom.debugStreamEmpty.hidden = false;
              dom.debugStreamEntries.appendChild(dom.debugStreamEmpty);
            }
            return;
          }

          if (dom.debugStreamEmpty) {
            dom.debugStreamEmpty.hidden = true;
          }

          const fragment = document.createDocumentFragment();
          if (hasTasks) {
            state.debug.tasks.forEach((task) => {
              fragment.appendChild(buildDebugStreamEntry(task));
            });
          }
          if (hasServerMessages) {
            state.debug.serverEntries.forEach((entry) => {
              fragment.appendChild(buildDebugStreamEntry(entry));
            });
          }
          dom.debugStreamEntries.appendChild(fragment);
        }

        function appendDebugLogs(entries, { reset = false } = {}) {
          if (!dom.debugLog) {
            return;
          }
          const list = Array.isArray(entries) ? entries : [];
          const serverLogs = [];
          const taskLogs = [];
          const regularLogs = [];
          list.forEach((entry) => {
            if (!entry || typeof entry !== 'object') {
              return;
            }
            if (entry.category === SERVER_LOG_CATEGORY) {
              serverLogs.push(entry);
              return;
            }
            if (entry.category === 'task') {
              taskLogs.push(entry);
              return;
            }
            regularLogs.push(entry);
          });

          updateServerStream(serverLogs, taskLogs, { reset });
          if (reset || !Array.isArray(state.debug.entries)) {
            state.debug.entries = [];
          }
          if (regularLogs.length) {
            state.debug.entries = state.debug.entries
              .concat(regularLogs)
              .slice(-MAX_DEBUG_LOG_ENTRIES);
          }
          renderDebugLogs();
        }

        async function fetchDebugLogs(reset = false) {
          if (!state.debug.enabled || state.debug.pending) {
            return;
          }
          state.debug.pending = true;
          try {
            let url = '/api/debug/logs';
            if (!reset && state.debug.lastId) {
              url += `?after=${encodeURIComponent(state.debug.lastId)}`;
            }
            const payload = await request(url);
            const logs = Array.isArray(payload?.logs) ? payload.logs : [];
            appendDebugLogs(logs, { reset });
            if (typeof payload?.next === 'number') {
              state.debug.lastId = payload.next;
            } else if (logs.length) {
              const lastEntry = logs[logs.length - 1];
              if (lastEntry && typeof lastEntry.id === 'number') {
                state.debug.lastId = lastEntry.id;
              }
            }
            updateDebugStatus('');
          } catch (error) {
            const base = t('debug.error');
            const detail = error instanceof Error ? error.message : String(error || '');
            updateDebugStatus(detail ? `${base} ${detail}` : base);
          } finally {
            state.debug.pending = false;
          }
        }

        function startDebugPolling() {
          stopDebugPolling();
          if (!state.debug.enabled) {
            return;
          }
          fetchDebugLogs(state.debug.lastId === 0);
          state.debug.timer = window.setInterval(() => {
            fetchDebugLogs(false);
          }, DEBUG_POLL_INTERVAL_MS);
        }

        function stopDebugPolling() {
          if (state.debug.timer) {
            window.clearInterval(state.debug.timer);
            state.debug.timer = null;
          }
        }

        function setDebugMode(enabled) {
          const active = Boolean(enabled);
          if (state.debug.enabled === active) {
            document.body.classList.toggle('debug-enabled', active);
            if (dom.debugPane) {
              dom.debugPane.hidden = !active;
            }
            if (active && state.debug.timer === null) {
              startDebugPolling();
            }
            return;
          }

          state.debug.enabled = active;
          document.body.classList.toggle('debug-enabled', active);
          if (dom.debugPane) {
            dom.debugPane.hidden = !active;
          }

          if (active) {
            state.debug.lastId = 0;
            state.debug.autoScroll = true;
            state.debug.pending = false;
            appendDebugLogs([], { reset: true });
            updateDebugStatus('');
            startDebugPolling();
          } else {
            stopDebugPolling();
            updateDebugStatus('');
            updateServerStream([], [], { reset: true });
            state.debug.entries = [];
            renderDebugLogs();
            if (dom.debugEmpty) {
              ensureDebugPlaceholder();
              dom.debugEmpty.hidden = false;
            }
          }
        }

        let pdfjsLibPromise = null;

        function loadPdfjsLib() {
          if (window.pdfjsLib) {
            return Promise.resolve(window.pdfjsLib);
          }
          if (pdfjsLibPromise) {
            return pdfjsLibPromise;
          }

          const scriptUrl = window.__LECTURE_TOOLS_PDFJS_SCRIPT_URL__;
          if (typeof scriptUrl !== 'string' || !scriptUrl) {
            return Promise.reject(new Error('PDF.js script URL not configured.'));
          }

          const existingScript = document.querySelector('script[data-pdfjs-loader="true"]');
          if (existingScript && !window.pdfjsLib) {
            pdfjsLibPromise = new Promise((resolve, reject) => {
              const handleLoad = () => {
                if (window.pdfjsLib) {
                  try {
                    const workerUrl = window.__LECTURE_TOOLS_PDFJS_WORKER_URL__;
                    if (workerUrl) {
                      window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;
                    }
                  } catch (workerError) {
                    console.warn('Unable to configure PDF.js worker', workerError);
                  }
                  resolve(window.pdfjsLib);
                } else {
                  reject(new Error('PDF.js did not expose pdfjsLib.'));
                }
              };
              existingScript.addEventListener('load', handleLoad, { once: true });
              existingScript.addEventListener(
                'error',
                () => reject(new Error('Failed to load PDF.js script.')),
                { once: true },
              );
            }).catch((error) => {
              pdfjsLibPromise = null;
              throw error;
            });
            return pdfjsLibPromise;
          }

          pdfjsLibPromise = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = scriptUrl;
            script.async = true;
            script.dataset.pdfjsLoader = 'true';
            script.onload = () => {
              if (window.pdfjsLib) {
                try {
                  const workerUrl = window.__LECTURE_TOOLS_PDFJS_WORKER_URL__;
                  if (workerUrl) {
                    window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;
                  }
                } catch (workerError) {
                  console.warn('Unable to configure PDF.js worker', workerError);
                }
                resolve(window.pdfjsLib);
              } else {
                reject(new Error('PDF.js did not expose pdfjsLib.'));
              }
            };
            script.onerror = () => {
              reject(new Error('Failed to load PDF.js script.'));
            };
            document.head.appendChild(script);
          }).catch((error) => {
            pdfjsLibPromise = null;
            throw error;
          });

          return pdfjsLibPromise;
        }

        async function extractPdfPageCountFromBlob(blob) {
          if (!(blob instanceof Blob)) {
            return null;
          }
          try {
            const pdfjs = await loadPdfjsLib();
            const data = await blob.arrayBuffer();
            const loadingTask = pdfjs.getDocument({ data });
            try {
              const pdfDocument = await loadingTask.promise;
              const totalPages = pdfDocument?.numPages;
              if (typeof pdfDocument?.destroy === 'function') {
                try {
                  await pdfDocument.destroy();
                } catch (destroyError) {
                  console.warn('Failed to destroy PDF document', destroyError);
                }
              }
              if (Number.isFinite(totalPages) && totalPages > 0) {
                return Math.round(totalPages);
              }
            } finally {
              if (typeof loadingTask.destroy === 'function') {
                try {
                  await loadingTask.destroy();
                } catch (taskError) {
                  // Ignore cleanup failures.
                }
              }
            }
          } catch (error) {
            console.warn('Failed to read PDF page count from blob', error);
          }
          return null;
        }

        async function extractPdfPageCountFromUrl(url, { withCredentials = false } = {}) {
          if (typeof url !== 'string' || !url) {
            return null;
          }
          try {
            const pdfjs = await loadPdfjsLib();
            const loadingTask = pdfjs.getDocument({ url, withCredentials });
            try {
              const pdfDocument = await loadingTask.promise;
              const totalPages = pdfDocument?.numPages;
              if (typeof pdfDocument?.destroy === 'function') {
                try {
                  await pdfDocument.destroy();
                } catch (destroyError) {
                  console.warn('Failed to destroy PDF document', destroyError);
                }
              }
              if (Number.isFinite(totalPages) && totalPages > 0) {
                return Math.round(totalPages);
              }
            } finally {
              if (typeof loadingTask.destroy === 'function') {
                try {
                  await loadingTask.destroy();
                } catch (taskError) {
                  // Ignore cleanup failures.
                }
              }
            }
          } catch (error) {
            console.warn('Failed to read PDF page count from URL', error);
          }
          return null;
        }

        function showPendingOverlay(message = '') {
          const pending = dom.pendingDialog;
          if (!pending || !pending.root) {
            return;
          }
          if (pending.message) {
            pending.message.textContent = message || '';
          }
          pending.root.classList.remove('hidden');
          pending.root.setAttribute('aria-hidden', 'false');
        }

        function hidePendingOverlay() {
          const pending = dom.pendingDialog;
          if (!pending || !pending.root) {
            return;
          }
          pending.root.classList.add('hidden');
          pending.root.setAttribute('aria-hidden', 'true');
          if (pending.message) {
            pending.message.textContent = '';
          }
        }


        function syncSettingsForm(settings) {
          const themeValue = normalizeTheme(settings?.theme);
          const displayModeValue = normalizeDisplayMode(settings?.display_mode, settings?.theme);
          const effectsValue = normalizeVisualEffects(settings?.visual_effects);
          const languageValue = normalizeLanguage(settings?.language);
          const requestedModel = normalizeWhisperModel(settings?.whisper_model);
          const computeRaw = settings?.whisper_compute_type ?? 'int8';
          const computeValue =
            typeof computeRaw === 'string' ? computeRaw.trim() || 'int8' : 'int8';
          const beamNumber = Math.max(
            1,
            Math.min(10, Number(settings?.whisper_beam_size) || 5),
          );
          const dpiValue = normalizeSlideDpi(settings?.slide_dpi);
          const slideForceOcr = Boolean(settings?.slide_force_ocr);
          const masteringEnabled = settings?.audio_mastering_enabled !== false;
          const debugEnabled = Boolean(settings?.debug_enabled);
          const updatePasswordSet = Boolean(settings?.update_sudo_password_set);
          const cloudConnectionEnabled = Boolean(settings?.cloud_connection_enabled);
          const cloudServerUrl = normalizeCloudServerUrl(settings?.cloud_server_url);
          const cloudAutoConnect = Boolean(settings?.cloud_auto_connect);
          const cloudProcessingTarget =
            settings?.cloud_processing_target === 'local' ? 'local' : 'cloud';

          const effectiveModel =
            requestedModel === GPU_MODEL && !state.gpuWhisper.supported
              ? DEFAULT_WHISPER_MODEL
              : requestedModel;

          if (dom.settingsDisplayMode) {
            dom.settingsDisplayMode.value = displayModeValue;
          }
          dom.settingsTheme.value = themeValue;
          if (dom.settingsVisualEffects) {
            dom.settingsVisualEffects.value = effectsValue;
          }
          dom.settingsLanguage.value = languageValue;
          dom.settingsWhisperModel.value = effectiveModel;
          dom.settingsWhisperCompute.value = computeValue;
          dom.settingsWhisperBeam.value = String(beamNumber);
          dom.settingsSlideDpi.value = dpiValue;
          if (dom.settingsSlideForceOcr) {
            dom.settingsSlideForceOcr.checked = slideForceOcr;
          }
          if (dom.settingsAudioMastering) {
            dom.settingsAudioMastering.checked = masteringEnabled;
          }
          if (dom.settingsDebugEnabled) {
            dom.settingsDebugEnabled.checked = debugEnabled;
          }
          if (dom.settingsCloudConnectionEnabled) {
            dom.settingsCloudConnectionEnabled.checked = cloudConnectionEnabled;
          }
          if (dom.settingsCloudServerUrl) {
            dom.settingsCloudServerUrl.value = cloudServerUrl;
          }
          if (dom.settingsCloudAutoConnect) {
            dom.settingsCloudAutoConnect.checked = cloudAutoConnect;
          }
          if (dom.settingsCloudProcessingTarget) {
            dom.settingsCloudProcessingTarget.value = cloudProcessingTarget;
          }
          if (dom.settingsUpdatePassword) {
            dom.settingsUpdatePassword.value = '';
          }
          if (dom.settingsUpdatePasswordClear) {
            dom.settingsUpdatePasswordClear.checked = false;
          }
          if (dom.settingsUpdatePasswordStatus) {
            dom.settingsUpdatePasswordStatus.hidden = !updatePasswordSet;
          }
          setTranscribeModelValue(effectiveModel);

          state.settings = {
            display_mode: displayModeValue,
            theme: themeValue,
            visual_effects: effectsValue,
            language: languageValue,
            whisper_model: effectiveModel,
            whisper_model_requested: requestedModel,
            whisper_compute_type: computeValue,
            whisper_beam_size: beamNumber,
            slide_dpi: Number(dpiValue),
            slide_force_ocr: slideForceOcr,
            audio_mastering_enabled: masteringEnabled,
            debug_enabled: debugEnabled,
            update_sudo_password_set: updatePasswordSet,
            cloud_connection_enabled: cloudConnectionEnabled,
            cloud_server_url: cloudServerUrl,
            cloud_auto_connect: cloudAutoConnect,
            cloud_processing_target: cloudProcessingTarget,
          };

          state.cloudConnection.enabled = cloudConnectionEnabled;
          state.cloudConnection.url = cloudServerUrl;
          state.cloudConnection.autoConnect = cloudAutoConnect;
          state.cloudConnection.processingTarget = cloudProcessingTarget;
          if (!cloudConnectionEnabled) {
            state.cloudConnection.connected = false;
            updateCloudConnectionStatus('disabled');
          } else if (state.cloudConnection.connected) {
            updateCloudConnectionStatus('connected');
          } else {
            updateCloudConnectionStatus('idle');
          }

          applyAppearance(displayModeValue, themeValue, effectsValue);
          updateGpuWhisperUI({ ...state.gpuWhisper });
          applyTranslations(languageValue);
          renderStorage();
          updateEditModeUI();
          setDebugMode(debugEnabled);
        }

        function showDialog({
          title = '',
          message = '',
          confirmText = t('dialog.confirm'),
          cancelText = t('dialog.cancel'),
          variant = 'primary',
          input = false,
          placeholder = '',
          defaultValue = '',
          required = false,
        } = {}) {
          return new Promise((resolve) => {
            const dialog = dom.dialog;
            if (
              !dialog.root ||
              dialogState.active ||
              dialogState.uploadActive ||
              dialogState.bulkUploadActive ||
              dialogState.bulkProcessActive ||
              dialogState.bulkDownloadActive ||
              dialogState.viewerActive
            ) {
              resolve({ confirmed: false, value: null });
              return;
            }

            dialogState.active = true;
            const previousActive =
              document.activeElement instanceof HTMLElement ? document.activeElement : null;
            const requireValue = Boolean(required && input);
            const variantClass = variant === 'danger' ? 'danger' : 'primary';

            dialog.title.textContent = title || '';
            dialog.message.textContent = message || '';
            dialog.message.style.display = message ? 'block' : 'none';

            if (input) {
              dialog.inputWrapper.classList.remove('hidden');
              dialog.input.value = defaultValue ?? '';
              dialog.input.placeholder = placeholder ?? '';
            } else {
              dialog.inputWrapper.classList.add('hidden');
              dialog.input.value = '';
              dialog.input.placeholder = '';
            }

            dialog.confirm.textContent = confirmText;
            dialog.cancel.textContent = cancelText;
            dialog.confirm.classList.remove('primary', 'danger');
            dialog.confirm.classList.add(variantClass);
            dialog.confirm.disabled = false;

            const focusOrder = [];
            if (input) {
              focusOrder.push(dialog.input);
            }
            focusOrder.push(dialog.cancel, dialog.confirm);

            function updateConfirmState() {
              if (!requireValue) {
                dialog.confirm.disabled = false;
                return;
              }
              dialog.confirm.disabled = dialog.input.value.trim().length === 0;
            }

            function cleanup() {
              dialog.confirm.removeEventListener('click', handleConfirm);
              dialog.cancel.removeEventListener('click', handleCancel);
              dialog.backdrop.removeEventListener('click', handleCancel);
              dialog.window.removeEventListener('keydown', handleKeyDown);
              if (input) {
                dialog.input.removeEventListener('input', updateConfirmState);
              }
              dialog.root.classList.add('hidden');
              dialog.root.setAttribute('aria-hidden', 'true');
              dialogState.active = false;
              if (
                !dialogState.uploadActive &&
                !dialogState.bulkUploadActive &&
                !dialogState.bulkProcessActive &&
                !dialogState.bulkDownloadActive &&
                !dialogState.viewerActive
              ) {
                document.body.classList.remove('dialog-open');
              }
              if (previousActive) {
                previousActive.focus({ preventScroll: true });
              }
            }

            function resolveAndClose(result) {
              cleanup();
              resolve(result);
            }

            function handleConfirm(event) {
              event.preventDefault();
              if (dialog.confirm.disabled) {
                return;
              }
              const value = input ? dialog.input.value : null;
              resolveAndClose({ confirmed: true, value });
            }

            function handleCancel(event) {
              event.preventDefault();
              resolveAndClose({ confirmed: false, value: null });
            }

            function handleKeyDown(event) {
              if (event.key === 'Escape') {
                event.preventDefault();
                handleCancel(event);
                return;
              }
              if (event.key === 'Enter') {
                if (input) {
                  if (requireValue && dialog.input.value.trim().length === 0) {
                    return;
                  }
                  if (document.activeElement !== dialog.cancel) {
                    event.preventDefault();
                    handleConfirm(event);
                  }
                } else if (
                  document.activeElement !== dialog.confirm &&
                  document.activeElement !== dialog.cancel
                ) {
                  event.preventDefault();
                  handleConfirm(event);
                }
                return;
              }
              if (event.key === 'Tab') {
                const focusable = focusOrder.filter(
                  (element) => element instanceof HTMLElement && !element.disabled,
                );
                if (!focusable.length) {
                  return;
                }
                const currentIndex = focusable.indexOf(document.activeElement);
                if (event.shiftKey) {
                  const previousIndex = currentIndex <= 0 ? focusable.length - 1 : currentIndex - 1;
                  focusable[previousIndex].focus();
                } else {
                  const nextIndex = currentIndex === focusable.length - 1 ? 0 : currentIndex + 1;
                  focusable[nextIndex].focus();
                }
                event.preventDefault();
              }
            }

            dialog.confirm.addEventListener('click', handleConfirm);
            dialog.cancel.addEventListener('click', handleCancel);
            dialog.backdrop.addEventListener('click', handleCancel);
            dialog.window.addEventListener('keydown', handleKeyDown);
            if (input) {
              dialog.input.addEventListener('input', updateConfirmState);
            }

            dialog.root.classList.remove('hidden');
            dialog.root.setAttribute('aria-hidden', 'false');
            document.body.classList.add('dialog-open');
            updateConfirmState();

            const initialFocus = input ? dialog.input : dialog.confirm;
            window.requestAnimationFrame(() => {
              initialFocus.focus({ preventScroll: true });
              if (input) {
                const valueLength = dialog.input.value.length;
                dialog.input.setSelectionRange(valueLength, valueLength);
              }
            });
          });
        }

        async function confirmDialog(options = {}) {
          const result = await showDialog({ ...options, input: false });
          return Boolean(result.confirmed);
        }

        async function promptDialog(options = {}) {
          const result = await showDialog({ ...options, input: true });
          if (!result.confirmed) {
            return null;
          }
          return typeof result.value === 'string' ? result.value : '';
        }

        async function showUploadDialog(options = {}) {
          return new Promise((resolve) => {
            const dialog = dom.uploadDialog;
            if (
              !dialog ||
              !dialog.root ||
              dialogState.uploadActive ||
              dialogState.bulkUploadActive ||
              dialogState.bulkProcessActive ||
              dialogState.bulkDownloadActive ||
              dialogState.viewerActive
            ) {
              resolve({ confirmed: false, uploaded: false, file: null, result: null, meta: null });
              return;
            }

            dialogState.uploadActive = true;
            let closed = false;
            let selectedEntries = [];
            let selecting = false;
            let uploading = false;
            let uploadComplete = false;
            let uploadResult = null;
            let uploadResults = [];
            let uploadStage = 'idle';
            let processingInBackground = false;
            let autoCloseOnComplete = false;
            let dragSourceIndex = null;

            const allowBackgroundProcessing = options.allowBackgroundProcessing === true;
            const enableProcessingStage = options.enableProcessingStage !== false;
            const backgroundProcessingMessage =
              typeof options.backgroundProcessing === 'string' ? options.backgroundProcessing : '';
            const allowMultiple = options.multiple === true;

            const actionLabelCandidate =
              options.uploadLabel ||
              t('dialogs.upload.action') ||
              t('common.actions.upload');
            const labels = {
              title: options.title || t('dialogs.upload.title'),
              description: options.description || t('dialogs.upload.description'),
              prompt: options.prompt || t('dialogs.upload.prompt'),
              help: options.help || t('dialogs.upload.help'),
              browse: options.browseLabel || t('dialogs.upload.browse'),
              clear: options.clearLabel || t('dialogs.upload.clear'),
              waiting: options.waiting || t('dialogs.upload.waiting'),
              preparing: options.preparing || t('dialogs.upload.preparing'),
              uploading: options.uploading || t('dialogs.upload.uploading'),
              processing: options.processing || t('dialogs.upload.processing'),
              processingAction:
                options.processingAction || t('dialogs.upload.processingAction'),
              backgroundProcessing:
                backgroundProcessingMessage || t('dialogs.upload.backgroundProcessing'),
              success: options.success || t('dialogs.upload.success'),
              failure: options.failure || t('dialogs.upload.failure'),
              progress: options.progressLabel || t('dialogs.upload.progress'),
              fileProgress: options.fileProgressLabel || t('dialogs.upload.fileProgress'),
              filesSelected: options.filesSelectedLabel || t('dialogs.upload.filesSelected'),
              filesSummary: options.filesSummaryLabel || t('dialogs.upload.filesSummary'),
              listHelp: options.listHelpLabel || t('dialogs.upload.listHelp'),
              uploadingFile: options.uploadingFileLabel || t('dialogs.upload.uploadingFile'),
              action: actionLabelCandidate || 'Upload',
              close: options.closeLabel || t('common.actions.close') || 'Close',
            };

            const accept = typeof options.accept === 'string' ? options.accept : '';
            const uploadHandler = typeof options.onUpload === 'function' ? options.onUpload : null;
            const fileSelectedHandler =
              typeof options.onFileSelected === 'function' ? options.onFileSelected : null;

            const previousActive =
              document.activeElement instanceof HTMLElement ? document.activeElement : null;

            function cleanup() {
              closed = true;
              if (dialog.confirm) {
                dialog.confirm.removeEventListener('click', handleConfirm);
              }
              if (dialog.cancel) {
                dialog.cancel.removeEventListener('click', handleCancel);
              }
              if (dialog.backdrop) {
                dialog.backdrop.removeEventListener('click', handleCancel);
              }
              if (dialog.window) {
                dialog.window.removeEventListener('keydown', handleKeyDown);
              }
              if (dialog.dropzone) {
                dialog.dropzone.removeEventListener('click', handleBrowseClick);
                dialog.dropzone.removeEventListener('keydown', handleDropzoneKeyDown);
                dialog.dropzone.removeEventListener('dragover', handleDragOver);
                dialog.dropzone.removeEventListener('dragleave', handleDragLeave);
                dialog.dropzone.removeEventListener('drop', handleDrop);
              }
              if (dialog.browse) {
                dialog.browse.removeEventListener('click', handleBrowseClick);
                dialog.browse.removeEventListener('keydown', handleDropzoneKeyDown);
              }
              if (dialog.input) {
                dialog.input.removeEventListener('change', handleInputChange);
              }
              if (dialog.clear) {
                dialog.clear.removeEventListener('click', handleClearSelection);
              }
              resetProgress();
              setStatus('');
              if (dialog.fileInfo) {
                dialog.fileInfo.classList.add('hidden');
              }
              if (dialog.fileName) {
                dialog.fileName.textContent = '';
              }
              if (dialog.fileList) {
                dialog.fileList.innerHTML = '';
                dialog.fileList.classList.add('hidden');
              }
              if (dialog.fileSize) {
                dialog.fileSize.textContent = '';
              }
              if (dialog.dropzone) {
                dialog.dropzone.classList.remove('active');
              }
              if (dialog.input) {
                dialog.input.value = '';
              }
              if (dialog.root) {
                dialog.root.classList.add('hidden');
                dialog.root.classList.remove('upload-dialog-hidden');
                dialog.root.setAttribute('aria-hidden', 'true');
              }
              dialogState.uploadActive = false;
              if (
                !dialogState.active &&
                !dialogState.bulkUploadActive &&
                !dialogState.bulkProcessActive &&
                !dialogState.bulkDownloadActive &&
                !dialogState.viewerActive
              ) {
                document.body.classList.remove('dialog-open');
              }
              selectedEntries = [];
              dragSourceIndex = null;
              if (previousActive) {
                previousActive.focus({ preventScroll: true });
              }
            }

            async function resolveAndClose(payload) {
              if (!payload || payload.uploaded !== true) {
                await runSelectedCleanup();
              }
              cleanup();
              resolve(payload);
            }

            function setStatus(message, variant = '') {
              if (!dialog.status) {
                return;
              }
              dialog.status.classList.remove('error', 'success');
              if (variant) {
                dialog.status.classList.add(variant);
              }
              dialog.status.textContent = message || '';
            }

            function resetProgress() {
              if (dialog.progressContainer) {
                dialog.progressContainer.classList.add('hidden');
              }
              if (dialog.progressFill) {
                dialog.progressFill.style.width = '0%';
              }
              if (dialog.progressText) {
                dialog.progressText.textContent = '';
              }
              if (dialog.progress) {
                dialog.progress.setAttribute('aria-valuenow', '0');
                dialog.progress.setAttribute('aria-label', labels.progress);
              }
              uploadStage = 'idle';
              processingInBackground = false;
              autoCloseOnComplete = false;
            }

            function updateProgress(ratio) {
              const value = Number.isFinite(ratio) ? Math.max(0, Math.min(1, ratio)) : 0;
              const percent = Math.round(value * 100);
              if (dialog.progressContainer) {
                dialog.progressContainer.classList.remove('hidden');
              }
              if (dialog.progressFill) {
                dialog.progressFill.style.width = `${percent}%`;
              }
              if (dialog.progressText) {
                dialog.progressText.textContent = `${percent}%`;
              }
              if (dialog.progress) {
                dialog.progress.setAttribute('aria-valuenow', String(percent));
              }
              if (percent >= 100) {
                autoCloseOnComplete = true;
                if (uploading && uploadStage === 'uploading') {
                  setStatus(labels.success, 'success');
                }
              }
              if (
                enableProcessingStage &&
                labels.processing &&
                uploading &&
                uploadStage !== 'processing' &&
                percent >= 100 &&
                !autoCloseOnComplete
              ) {
                uploadStage = 'processing';
                if (allowBackgroundProcessing) {
                  enterProcessingStage();
                } else {
                  setStatus(labels.processing);
                  updateActionState();
                }
              }
            }

            function enterProcessingStage() {
              if (processingInBackground || !allowBackgroundProcessing) {
                return;
              }
              processingInBackground = true;
              const message = labels.backgroundProcessing || labels.processing || labels.uploading;
              setStatus(message, 'info');
              updateActionState();
            }

            function updateActionState() {
              if (!dialog.confirm) {
                return;
              }
              dialog.confirm.classList.remove('hidden');
              dialog.confirm.style.display = '';
              if (processingInBackground && allowBackgroundProcessing && uploading) {
                dialog.confirm.textContent = labels.close;
                dialog.confirm.disabled = false;
                if (dialog.cancel) {
                  dialog.cancel.textContent = labels.close;
                  dialog.cancel.disabled = false;
                }
                return;
              }
              if (uploading) {
                const buttonLabel =
                  uploadStage === 'processing'
                    ? labels.processingAction || labels.processing || labels.uploading
                    : labels.uploading;
                dialog.confirm.textContent = buttonLabel;
                dialog.confirm.disabled = true;
                if (dialog.cancel) {
                  dialog.cancel.textContent = t('dialog.cancel');
                  dialog.cancel.disabled = true;
                }
                return;
              }
              if (uploadComplete) {
                dialog.confirm.textContent = t('dialog.confirm');
                dialog.confirm.disabled = false;
                if (dialog.cancel) {
                  dialog.cancel.textContent = t('dialog.cancel');
                  dialog.cancel.disabled = false;
                }
                return;
              }
              const readyLabel =
                labels.action || t('dialogs.upload.action') || t('common.actions.upload') || 'Upload';
              const hasSelection = selectedEntries.length > 0;
              dialog.confirm.textContent = readyLabel;
              dialog.confirm.disabled = !hasSelection || !uploadHandler;
              if (dialog.cancel) {
                dialog.cancel.textContent = t('dialog.cancel');
                dialog.cancel.disabled = false;
              }
            }

            async function runWithSuspendedDialog(task) {
              if (typeof task !== 'function') {
                return null;
              }
              const pendingMessage =
                t('dialogs.slideRange.loading') ||
                labels.processing ||
                labels.uploading ||
                'Preparing document';
              showPendingOverlay(pendingMessage);
              if (dialog.root) {
                dialog.root.classList.add('upload-dialog-hidden');
                dialog.root.setAttribute('aria-hidden', 'true');
              }
              dialogState.uploadActive = false;
              if (
                !dialogState.active &&
                !dialogState.bulkUploadActive &&
                !dialogState.bulkProcessActive &&
                !dialogState.bulkDownloadActive &&
                !dialogState.viewerActive
              ) {
                document.body.classList.remove('dialog-open');
              }
              try {
                return await task();
              } finally {
                hidePendingOverlay();
                if (!closed) {
                  dialogState.uploadActive = true;
                  if (dialog.root) {
                    dialog.root.classList.remove('upload-dialog-hidden');
                    dialog.root.classList.remove('hidden');
                    dialog.root.setAttribute('aria-hidden', 'false');
                  }
                  document.body.classList.add('dialog-open');
                  window.requestAnimationFrame(() => {
                    if (!closed && dialog.dropzone instanceof HTMLElement) {
                      dialog.dropzone.focus({ preventScroll: true });
                    }
                  });
                } else {
                  if (
                    !dialogState.active &&
                    !dialogState.bulkUploadActive &&
                    !dialogState.bulkProcessActive &&
                    !dialogState.bulkDownloadActive &&
                    !dialogState.viewerActive
                  ) {
                    document.body.classList.remove('dialog-open');
                  }
                }
              }
            }

            async function runSelectedCleanup() {
              const cleanups = [];
              selectedEntries.forEach((entry) => {
                if (entry && typeof entry.cleanup === 'function') {
                  cleanups.push(entry.cleanup);
                  entry.cleanup = null;
                }
              });
              if (!cleanups.length) {
                return;
              }
              for (const cleanupFn of cleanups) {
                try {
                  await cleanupFn();
                } catch (error) {
                  console.warn('Failed to clear upload selection metadata', error);
                }
              }
            }


            function renderSelectedFiles(summaryMessage = '') {
              const total = selectedEntries.length;
              if (!dialog.fileInfo) {
                return;
              }
              if (total === 0) {
                dialog.fileInfo.classList.add('hidden');
                if (dialog.fileName) {
                  dialog.fileName.textContent = '';
                }
                if (dialog.fileSize) {
                  dialog.fileSize.textContent = '';
                }
                if (dialog.fileList) {
                  dialog.fileList.innerHTML = '';
                  dialog.fileList.classList.add('hidden');
                }
                if (summaryMessage) {
                  setStatus(summaryMessage);
                }
                return;
              }

              dialog.fileInfo.classList.remove('hidden');

              if (total === 1) {
                const entry = selectedEntries[0];
                if (dialog.fileName) {
                  dialog.fileName.textContent = entry?.file?.name || '';
                }
                if (dialog.fileSize) {
                  const sizeText =
                    entry && entry.file && typeof entry.file.size === 'number' && Number.isFinite(entry.file.size)
                      ? formatBytes(entry.file.size)
                      : '';
                  dialog.fileSize.textContent = sizeText;
                }
                if (dialog.fileList) {
                  dialog.fileList.innerHTML = '';
                  dialog.fileList.classList.add('hidden');
                }
                if (summaryMessage) {
                  setStatus(summaryMessage);
                } else if (!uploading) {
                  setStatus(labels.waiting);
                }
                return;
              }

              if (dialog.fileList) {
                dialog.fileList.innerHTML = '';
                dialog.fileList.classList.remove('hidden');
              }

              const totalSize = selectedEntries.reduce((sum, entry) => {
                const value =
                  entry && entry.file && typeof entry.file.size === 'number' && Number.isFinite(entry.file.size)
                    ? entry.file.size
                    : 0;
                return sum + value;
              }, 0);
              const sizeText = totalSize > 0 ? formatBytes(totalSize) : '';

              const selectedText =
                typeof labels.filesSelected === 'string' && labels.filesSelected
                  ? formatTemplate(labels.filesSelected, { count: total })
                  : `${total} files selected`;
              let summaryText;
              if (typeof labels.filesSummary === 'string' && labels.filesSummary && sizeText) {
                summaryText = formatTemplate(labels.filesSummary, { count: total, size: sizeText });
              } else if (typeof labels.filesSelected === 'string' && labels.filesSelected) {
                summaryText = formatTemplate(labels.filesSelected, { count: total });
              } else if (sizeText) {
                summaryText = `${total} files  ${sizeText}`;
              } else {
                summaryText = `${total} files selected`;
              }

              if (dialog.fileName) {
                dialog.fileName.textContent = selectedText;
              }
              if (dialog.fileSize) {
                dialog.fileSize.textContent = summaryText;
              }

              if (dialog.fileList) {
                selectedEntries.forEach((entry, index) => {
                  const item = document.createElement('li');
                  item.className = 'upload-file-item';
                  item.dataset.index = String(index);
                  item.setAttribute('draggable', uploading ? 'false' : 'true');
                  const name = document.createElement('span');
                  name.className = 'upload-file-item-name';
                  name.textContent = entry?.file?.name || '';
                  const meta = document.createElement('span');
                  meta.className = 'upload-file-item-meta';
                  const entrySize =
                    entry && entry.file && typeof entry.file.size === 'number' && Number.isFinite(entry.file.size)
                      ? formatBytes(entry.file.size)
                      : '';
                  meta.textContent = entrySize;
                  item.appendChild(name);
                  item.appendChild(meta);
                  item.addEventListener('dragstart', handleFileItemDragStart);
                  item.addEventListener('dragenter', handleFileItemDragEnter);
                  item.addEventListener('dragover', handleFileItemDragOver);
                  item.addEventListener('dragleave', handleFileItemDragLeave);
                  item.addEventListener('drop', handleFileItemDrop);
                  item.addEventListener('dragend', handleFileItemDragEnd);
                  dialog.fileList.appendChild(item);
                });
              }

              if (summaryMessage) {
                setStatus(summaryMessage);
              } else if (labels.listHelp) {
                setStatus(labels.listHelp, 'info');
              } else if (!uploading) {
                setStatus(labels.waiting);
              }
            }

            function handleFileItemDragStart(event) {
              if (uploading) {
                event.preventDefault();
                return;
              }
              const target = event.currentTarget;
              if (!(target instanceof HTMLElement)) {
                return;
              }
              const index = Number(target.dataset.index || target.getAttribute('data-index'));
              if (!Number.isFinite(index)) {
                return;
              }
              dragSourceIndex = index;
              target.classList.add('dragging');
              if (event.dataTransfer) {
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', String(index));
              }
            }

            function handleFileItemDragEnter(event) {
              if (uploading) {
                return;
              }
              const target = event.currentTarget;
              if (target instanceof HTMLElement) {
                target.classList.add('drop-target');
              }
            }

            function handleFileItemDragOver(event) {
              if (uploading) {
                return;
              }
              event.preventDefault();
              if (event.dataTransfer) {
                event.dataTransfer.dropEffect = 'move';
              }
            }

            function handleFileItemDragLeave(event) {
              if (uploading) {
                return;
              }
              const target = event.currentTarget;
              if (target instanceof HTMLElement) {
                target.classList.remove('drop-target');
              }
            }

            function handleFileItemDrop(event) {
              if (uploading) {
                return;
              }
              event.preventDefault();
              const target = event.currentTarget;
              const targetIndex =
                target instanceof HTMLElement
                  ? Number(target.dataset.index || target.getAttribute('data-index'))
                  : NaN;
              const sourceIndex =
                typeof dragSourceIndex === 'number'
                  ? dragSourceIndex
                  : Number(event.dataTransfer?.getData('text/plain'));
              dragSourceIndex = null;
              if (target instanceof HTMLElement) {
                target.classList.remove('drop-target');
              }
              if (!Number.isFinite(sourceIndex) || !Number.isFinite(targetIndex) || sourceIndex === targetIndex) {
                renderSelectedFiles();
                return;
              }
              const [entry] = selectedEntries.splice(sourceIndex, 1);
              if (entry) {
                selectedEntries.splice(targetIndex, 0, entry);
              }
              renderSelectedFiles();
            }

            function handleFileItemDragEnd(event) {
              const target = event.currentTarget;
              if (target instanceof HTMLElement) {
                target.classList.remove('dragging');
                target.classList.remove('drop-target');
              }
              dragSourceIndex = null;
            }

            async function setSelectedFiles(files) {
              if (selecting) {
                return;
              }
              selecting = true;
              try {
                const candidates = Array.isArray(files)
                  ? files.filter((item) => item instanceof Blob)
                  : files
                  ? [files]
                  : [];

                if (!candidates.length) {
                  await runSelectedCleanup();
                  selectedEntries = [];
                  dragSourceIndex = null;
                  if (dialog.input) {
                    dialog.input.value = '';
                  }
                  resetProgress();
                  renderSelectedFiles();
                  uploadComplete = false;
                  setStatus(labels.waiting);
                  updateActionState();
                  return;
                }

                const trimmed = allowMultiple ? candidates : candidates.slice(0, 1);

                await runSelectedCleanup();

                const entries = [];
                let summaryMessage = '';

                if (trimmed.length === 1) {
                  const file = trimmed[0];
                  let meta = null;
                  let cleanupFn = null;
                  let summary = '';
                  if (fileSelectedHandler) {
                    setStatus(labels.preparing);
                    try {
                      const result = await runWithSuspendedDialog(() => fileSelectedHandler(file));
                      if (closed) {
                        return;
                      }
                      if (
                        result === false ||
                        (result && result.cancelled === true) ||
                        (result && result.confirmed === false)
                      ) {
                      if (dialog.input) {
                        dialog.input.value = '';
                      }
                      setStatus(labels.waiting);
                      uploadComplete = false;
                      selectedEntries = [];
                      dragSourceIndex = null;
                      renderSelectedFiles();
                      updateActionState();
                      return;
                    }
                      if (result && typeof result === 'object' && 'meta' in result) {
                        meta = result.meta;
                        if (typeof result.summary === 'string') {
                          summary = result.summary;
                        }
                        if (typeof result.cleanup === 'function') {
                          cleanupFn = result.cleanup;
                        }
                      } else if (result && typeof result === 'object') {
                        meta = result;
                        if (typeof result.cleanup === 'function') {
                          cleanupFn = result.cleanup;
                        }
                      }
                    } catch (error) {
                    const message = error instanceof Error && error.message ? error.message : labels.failure;
                    setStatus(message, 'error');
                    uploadComplete = false;
                    selectedEntries = [];
                    dragSourceIndex = null;
                    renderSelectedFiles();
                    updateActionState();
                    return;
                  }
                  }
                  entries.push({
                    file,
                    meta: meta && typeof meta === 'object' ? meta : null,
                    cleanup: typeof cleanupFn === 'function' ? cleanupFn : null,
                    summary,
                  });
                  summaryMessage = summary;
                } else {
                  trimmed.forEach((file) => {
                    entries.push({ file, meta: null, cleanup: null, summary: '' });
                  });
                }

                selectedEntries = entries;
                dragSourceIndex = null;
                if (dialog.input) {
                  dialog.input.value = '';
                }
                renderSelectedFiles(summaryMessage);
                uploadComplete = false;
                updateActionState();
              } finally {
                selecting = false;
              }
            }
            async function handleDrop(event) {
              event.preventDefault();
              if (dialog.dropzone) {
                dialog.dropzone.classList.remove('active');
              }
              const files = event.dataTransfer?.files;
              if (files && files.length > 0) {
                const selection = allowMultiple ? Array.from(files) : [files[0]];
                await setSelectedFiles(selection);
              }
            }

            async function handleInputChange(event) {
              const files = event.target?.files;
              if (files && files.length > 0) {
                const selection = allowMultiple ? Array.from(files) : [files[0]];
                await setSelectedFiles(selection);
              }
            }

            async function handleClearSelection(event) {
              event.preventDefault();
              await setSelectedFiles([]);
            }

            function openFilePicker(input) {
              if (!input) {
                return;
              }
              try {
                if (typeof input.showPicker === 'function') {
                  input.showPicker();
                  return;
                }
              } catch (error) {
                // Ignore errors from showPicker to allow fallback behaviour.
              }
              try {
                input.click();
              } catch (error) {
                // Swallow blocked click attempts quietly for keyboard activation.
              }
            }

            function handleBrowseClick(event) {
              if (!dialog.input) {
                return;
              }
              if (typeof event?.detail === 'number' && event.detail > 0) {
                return;
              }
              event?.preventDefault?.();
              event?.stopPropagation?.();
              openFilePicker(dialog.input);
            }

            function handleDropzoneKeyDown(event) {
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                handleBrowseClick(event);
              }
            }

            function handleDragOver(event) {
              event.preventDefault();
              if (event.dataTransfer) {
                event.dataTransfer.dropEffect = 'copy';
              }
              if (dialog.dropzone) {
                dialog.dropzone.classList.add('active');
              }
            }

            function handleDragLeave(event) {
              event.preventDefault();
              if (dialog.dropzone) {
                dialog.dropzone.classList.remove('active');
              }
            }


            async function performUpload() {
              if (!uploadHandler || !selectedEntries.length || uploading) {
                return;
              }
              uploading = true;
              uploadComplete = false;
              uploadResults = [];
              resetProgress();
              uploadStage = 'uploading';
              updateActionState();
              renderSelectedFiles();
              const total = selectedEntries.length;
              const results = [];
              try {
                for (let index = 0; index < total; index += 1) {
                  const entry = selectedEntries[index];
                  if (!entry || !(entry.file instanceof Blob)) {
                    continue;
                  }
                  const baseProgress = total > 0 ? index / total : 0;
                  const progressShare = total > 0 ? 1 / total : 1;
                  if (total > 1) {
                    const progressLabel =
                      typeof labels.fileProgress === 'string' && labels.fileProgress
                        ? formatTemplate(labels.fileProgress, { current: index + 1, total })
                        : '';
                    if (typeof labels.uploadingFile === 'string' && labels.uploadingFile) {
                      const message = formatTemplate(labels.uploadingFile, {
                        name: entry?.file?.name || t('dialogs.upload.title'),
                        current: index + 1,
                        total,
                      });
                      setStatus(message, 'info');
                    } else if (progressLabel) {
                      setStatus(progressLabel, 'info');
                    } else {
                      setStatus(labels.uploading);
                    }
                  } else {
                    setStatus(labels.uploading);
                  }
                  const result = await uploadHandler(entry.file, {
                    reportProgress: (ratio) => {
                      if (typeof ratio === 'number') {
                        const constrained = Math.max(0, Math.min(1, ratio));
                        const aggregate = Math.min(1, baseProgress + constrained * progressShare);
                        updateProgress(aggregate);
                      }
                    },
                    meta: entry.meta,
                  });
                  results.push(result ?? null);
                  if (total > 0) {
                    updateProgress((index + 1) / total);
                  }
                }
                uploadResults = results;
                uploadResult = results.length <= 1 ? results[0] ?? null : results;
                uploadComplete = true;
                uploading = false;
                uploadStage = 'idle';
                processingInBackground = false;
                updateProgress(1);
                setStatus(labels.success, 'success');
                updateActionState();
                if (autoCloseOnComplete) {
                  autoCloseOnComplete = false;
                  void resolveAndClose({
                    confirmed: true,
                    uploaded: true,
                    file: selectedEntries[0]?.file || null,
                    files: selectedEntries.map((entry) => entry.file),
                    result: uploadResult,
                    results: uploadResults,
                    meta: selectedEntries.length === 1 ? selectedEntries[0]?.meta || null : null,
                    metas: selectedEntries.map((entry) => entry.meta || null),
                  });
                  return;
                }
              } catch (error) {
                uploading = false;
                uploadComplete = false;
                uploadResult = null;
                uploadResults = [];
                uploadStage = 'idle';
                processingInBackground = false;
                autoCloseOnComplete = false;
                const message = error instanceof Error && error.message ? error.message : labels.failure;
                setStatus(message, 'error');
                resetProgress();
                updateActionState();
              }
            }
            function getFocusableElements() {
              const elements = [];
              if (dialog.dropzone instanceof HTMLElement) {
                elements.push(dialog.dropzone);
              }
              if (
                dialog.fileInfo &&
                !dialog.fileInfo.classList.contains('hidden') &&
                dialog.clear instanceof HTMLElement
              ) {
                elements.push(dialog.clear);
              }
              if (dialog.cancel instanceof HTMLElement) {
                elements.push(dialog.cancel);
              }
              if (dialog.confirm instanceof HTMLElement) {
                elements.push(dialog.confirm);
              }
              return elements.filter((element) => !element.disabled);
            }

            function handleKeyDown(event) {
              if (event.key === 'Escape') {
                event.preventDefault();
                handleCancel(event);
                return;
              }
              if (event.key === 'Tab') {
                const focusable = getFocusableElements();
                if (!focusable.length) {
                  return;
                }
                const index = focusable.indexOf(document.activeElement);
                const nextIndex = event.shiftKey
                  ? index <= 0
                    ? focusable.length - 1
                    : index - 1
                  : index === focusable.length - 1
                  ? 0
                  : index + 1;
                focusable[nextIndex].focus();
                event.preventDefault();
              }
            }

            function handleConfirm(event) {
              event.preventDefault();
              const firstEntry = selectedEntries[0] || null;
              const files = selectedEntries.map((entry) => entry.file);
              const metas = selectedEntries.map((entry) => entry.meta || null);
              if (processingInBackground && allowBackgroundProcessing && uploading) {
                void resolveAndClose({
                  confirmed: false,
                  uploaded: uploadComplete,
                  file: firstEntry?.file || null,
                  files,
                  result: uploadResult,
                  results: uploadResults,
                  meta: firstEntry?.meta || null,
                  metas,
                  processing: true,
                });
                return;
              }
              if (uploadComplete) {
                void resolveAndClose({
                  confirmed: true,
                  uploaded: true,
                  file: firstEntry?.file || null,
                  files,
                  result: uploadResult,
                  results: uploadResults,
                  meta: selectedEntries.length === 1 ? firstEntry?.meta || null : null,
                  metas,
                });
                return;
              }
              performUpload();
            }

            function handleCancel(event) {
              event?.preventDefault?.();
              const firstEntry = selectedEntries[0] || null;
              void resolveAndClose({
                confirmed: false,
                uploaded: uploadComplete,
                file: firstEntry?.file || null,
                files: selectedEntries.map((entry) => entry.file),
                result: uploadResult,
                results: uploadResults,
                meta: selectedEntries.length === 1 ? firstEntry?.meta || null : null,
                metas: selectedEntries.map((entry) => entry.meta || null),
                processing: processingInBackground && uploading,
              });
            }

            if (dialog.root) {
              dialog.root.classList.remove('hidden');
              dialog.root.classList.remove('upload-dialog-hidden');
              dialog.root.setAttribute('aria-hidden', 'false');
            }
            document.body.classList.add('dialog-open');

            if (dialog.title) {
              dialog.title.textContent = labels.title;
            }
            if (dialog.description) {
              dialog.description.textContent = labels.description;
            }
            if (dialog.prompt) {
              dialog.prompt.textContent = labels.prompt;
            }
            if (dialog.dropzone) {
              dialog.dropzone.setAttribute('aria-label', labels.prompt);
            }
            if (dialog.help) {
              dialog.help.textContent = labels.help;
            }
            if (dialog.browse) {
              dialog.browse.textContent = labels.browse;
            }
            if (dialog.clear) {
              dialog.clear.textContent = labels.clear;
            }
            if (dialog.input) {
              dialog.input.accept = accept;
              if (allowMultiple) {
                dialog.input.setAttribute('multiple', 'multiple');
              } else {
                dialog.input.removeAttribute('multiple');
              }
              dialog.input.value = '';
            }
            if (dialog.progress) {
              dialog.progress.setAttribute('aria-label', labels.progress);
              dialog.progress.setAttribute('aria-valuenow', '0');
            }
            if (dialog.status) {
              dialog.status.classList.remove('error', 'success');
              dialog.status.textContent = '';
            }
            if (dialog.fileInfo) {
              dialog.fileInfo.classList.add('hidden');
            }
            selectedEntries = [];
            dragSourceIndex = null;
            uploading = false;
            uploadComplete = false;
            uploadResult = null;
            uploadResults = [];
            resetProgress();
            setStatus(labels.waiting);
            updateActionState();

            if (dialog.confirm) {
              dialog.confirm.addEventListener('click', handleConfirm);
            }
            if (dialog.cancel) {
              dialog.cancel.textContent = t('dialog.cancel');
              dialog.cancel.addEventListener('click', handleCancel);
            }
            if (dialog.backdrop) {
              dialog.backdrop.addEventListener('click', handleCancel);
            }
            if (dialog.window) {
              dialog.window.addEventListener('keydown', handleKeyDown);
            }
            if (dialog.dropzone) {
              dialog.dropzone.addEventListener('click', handleBrowseClick);
              dialog.dropzone.addEventListener('keydown', handleDropzoneKeyDown);
              dialog.dropzone.addEventListener('dragover', handleDragOver);
              dialog.dropzone.addEventListener('dragleave', handleDragLeave);
              dialog.dropzone.addEventListener('drop', handleDrop);
            }
            if (dialog.browse) {
              dialog.browse.addEventListener('click', handleBrowseClick);
              dialog.browse.addEventListener('keydown', handleDropzoneKeyDown);
            }
            if (dialog.input) {
              dialog.input.addEventListener('change', handleInputChange);
            }
            if (dialog.clear) {
              dialog.clear.addEventListener('click', handleClearSelection);
            }

            window.requestAnimationFrame(() => {
              const target = dialog.dropzone instanceof HTMLElement ? dialog.dropzone : dialog.confirm;
              target?.focus?.({ preventScroll: true });
            });
          });
        }

        async function showSlideRangeDialog(source) {
          return new Promise((resolve) => {
            const dialog = dom.slideRangeDialog;
            if (
              !dialog ||
              !dialog.root ||
              dialogState.active ||
              dialogState.uploadActive ||
              dialogState.bulkUploadActive ||
              dialogState.bulkProcessActive ||
              dialogState.bulkDownloadActive ||
              dialogState.viewerActive
            ) {
              resolve({ confirmed: false, pageStart: null, pageEnd: null, pageTotal: null });
              return;
            }

            hidePendingOverlay();
            dialogState.active = true;
            let cancelled = false;
            let pageCount = 0;
            let startPage = 1;
            let endPage = 1;
            let anchorPage = 1;
            let previewFailed = false;
            let manualSelectionMade = false;
            const pageEntries = [];
            const BASE_PREVIEW_COLUMN_WIDTH = 220;
            let previewZoom = 100;
            let fallbackObjectUrl = null;
            let fallbackPreviewUrl = null;
            const previewSource =
              source instanceof Blob
                ? { file: source }
                : source && typeof source === 'object'
                ? { ...source }
                : null;

            const previousActive =
              document.activeElement instanceof HTMLElement
                ? document.activeElement
                : null;

            function clampPage(value) {
              const numeric =
                typeof value === 'number'
                  ? value
                  : Number.parseInt(String(value ?? ''), 10);
              if (!Number.isFinite(numeric)) {
                return 1;
              }
              const rounded = Math.max(1, Math.round(numeric));
              if (!pageCount || pageCount < 1) {
                return rounded;
              }
              return Math.min(pageCount, rounded);
            }

            function configureInputBounds(totalPages) {
              const numeric =
                typeof totalPages === 'number' && Number.isFinite(totalPages) && totalPages > 0
                  ? Math.round(totalPages)
                  : 0;
              if (dialog.startInput) {
                dialog.startInput.min = '1';
                dialog.startInput.max = numeric > 0 ? String(numeric) : '';
              }
              if (dialog.endInput) {
                dialog.endInput.min = '1';
                dialog.endInput.max = numeric > 0 ? String(numeric) : '';
              }
            }

            function resolvePreviewIdentifiers() {
              if (!previewSource || typeof previewSource !== 'object') {
                return { lectureId: null, previewId: null };
              }

              let previewId =
                typeof previewSource.previewId === 'string' && previewSource.previewId
                  ? previewSource.previewId
                  : null;
              let lectureId = null;
              if (
                typeof previewSource.lectureId === 'number' ||
                (typeof previewSource.lectureId === 'string' && previewSource.lectureId)
              ) {
                lectureId = String(previewSource.lectureId).trim() || null;
              }

              if ((!previewId || !lectureId) && typeof previewSource.url === 'string') {
                const match = previewSource.url.match(
                  /\/api\/lectures\/(\d+)\/slides\/previews\/([^/?#]+)/,
                );
                if (match) {
                  if (!lectureId) {
                    lectureId = match[1];
                  }
                  if (!previewId) {
                    try {
                      previewId = decodeURIComponent(match[2]);
                    } catch (decodeError) {
                      previewId = match[2];
                    }
                  }
                }
              }

              return { lectureId, previewId };
            }

            function updateFallbackVisibility() {
              const hasUrl = Boolean(fallbackPreviewUrl);
              if (dialog.fallbackFrame) {
                dialog.fallbackFrame.src = hasUrl ? fallbackPreviewUrl : 'about:blank';
                dialog.fallbackFrame.classList.toggle('hidden', !hasUrl);
              }
              if (dialog.fallbackLink) {
                if (hasUrl) {
                  dialog.fallbackLink.href = fallbackPreviewUrl;
                  dialog.fallbackLink.classList.remove('hidden');
                } else {
                  dialog.fallbackLink.href = '#';
                  dialog.fallbackLink.classList.add('hidden');
                }
              }
              if (dialog.fallback) {
                dialog.fallback.classList.toggle('hidden', !previewFailed);
              }
            }

            function assignFallbackPreview(value, { isObjectUrl = false } = {}) {
              const nextValue = value || null;
              if (
                fallbackObjectUrl &&
                fallbackObjectUrl !== nextValue &&
                typeof URL !== 'undefined' &&
                typeof URL.revokeObjectURL === 'function'
              ) {
                try {
                  URL.revokeObjectURL(fallbackObjectUrl);
                } catch (error) {
                  // Ignore revocation failures.
                }
              }
              fallbackObjectUrl = isObjectUrl && nextValue ? nextValue : null;
              fallbackPreviewUrl = nextValue;
              updateFallbackVisibility();
            }

            function clearFallbackPreview() {
              if (
                fallbackObjectUrl &&
                typeof URL !== 'undefined' &&
                typeof URL.revokeObjectURL === 'function'
              ) {
                try {
                  URL.revokeObjectURL(fallbackObjectUrl);
                } catch (error) {
                  // Ignore revocation failures.
                }
              }
              fallbackObjectUrl = null;
              fallbackPreviewUrl = null;
              updateFallbackVisibility();
            }

            function resolveFallbackPreview() {
              const canCreateObjectUrl =
                typeof URL !== 'undefined' && typeof URL.createObjectURL === 'function';
              if (canCreateObjectUrl && previewSource?.file instanceof Blob) {
                const url = URL.createObjectURL(previewSource.file);
                return { url, isObjectUrl: true };
              }
              if (canCreateObjectUrl && source instanceof Blob) {
                const url = URL.createObjectURL(source);
                return { url, isObjectUrl: true };
              }
              if (previewSource && typeof previewSource.url === 'string' && previewSource.url) {
                return { url: resolveAppUrl(previewSource.url), isObjectUrl: false };
              }
              const { lectureId, previewId } = resolvePreviewIdentifiers();
              if (lectureId && previewId) {
                const directUrl = `/api/lectures/${lectureId}/slides/previews/${encodeURIComponent(
                  previewId,
                )}`;
                return { url: resolveAppUrl(directUrl), isObjectUrl: false };
              }
              return { url: null, isObjectUrl: false };
            }

            async function derivePdfPageCount(fallbackPreview) {
              const blobCandidates = [];
              if (previewSource?.file instanceof Blob) {
                blobCandidates.push(previewSource.file);
              }
              if (source instanceof Blob && source !== previewSource?.file) {
                blobCandidates.push(source);
              }

              for (const blobCandidate of blobCandidates) {
                try {
                  const blobCount = await extractPdfPageCountFromBlob(blobCandidate);
                  if (Number.isFinite(blobCount) && blobCount > 0) {
                    return Math.round(blobCount);
                  }
                } catch (blobError) {
                  console.warn('Failed to derive PDF page count from blob', blobError);
                }
              }

              const urlCandidates = new Set();
              if (previewSource && typeof previewSource.url === 'string' && previewSource.url) {
                urlCandidates.add(resolveAppUrl(previewSource.url));
              }
              if (fallbackPreview?.url) {
                urlCandidates.add(fallbackPreview.url);
              }

              const withCredentials = previewSource?.withCredentials === false ? false : true;
              for (const candidateUrl of urlCandidates) {
                try {
                  const urlCount = await extractPdfPageCountFromUrl(candidateUrl, {
                    withCredentials,
                  });
                  if (Number.isFinite(urlCount) && urlCount > 0) {
                    return Math.round(urlCount);
                  }
                } catch (urlError) {
                  console.warn('Failed to derive PDF page count from URL', urlError);
                }
              }

              return null;
            }

            async function fetchPreviewPageCount() {
              const { lectureId, previewId } = resolvePreviewIdentifiers();
              if (!lectureId || !previewId) {
                return null;
              }

              const credentials =
                previewSource && previewSource.withCredentials === false ? 'omit' : 'include';

              try {
                const payload = await request(
                  `/api/lectures/${lectureId}/slides/previews/${encodeURIComponent(previewId)}/metadata`,
                  {
                    method: 'GET',
                    headers: { Accept: 'application/json' },
                    credentials,
                    cache: 'no-store',
                  },
                );
                const value = payload?.page_count ?? payload?.pageCount;
                const numeric = Number(value);
                if (Number.isFinite(numeric) && numeric > 0) {
                  return Math.round(numeric);
                }
              } catch (error) {
                console.warn('Failed to load slide metadata', error);
              }

              return null;
            }

            function resolvePreviewImageUrl(pageNumber) {
              const { lectureId, previewId } = resolvePreviewIdentifiers();
              if (!lectureId || !previewId || !pageNumber) {
                return null;
              }
              const encoded = encodeURIComponent(previewId);
              const url = `/api/lectures/${lectureId}/slides/previews/${encoded}/pages/${pageNumber}`;
              return resolveAppUrl(url);
            }

            async function renderServerPreviewPages(totalPages) {
              if (!dialog.pages) {
                return;
              }
              dialog.pages.innerHTML = '';
              pageEntries.length = 0;
              const count = Number.isFinite(totalPages) ? Number(totalPages) : 0;
              if (count < 1) {
                return;
              }
              for (let pageNumber = 1; pageNumber <= count; pageNumber += 1) {
                if (cancelled) {
                  return;
                }
                const wrapper = document.createElement('div');
                wrapper.className = 'slide-preview-page';
                wrapper.dataset.pageNumber = String(pageNumber);
                wrapper.tabIndex = 0;
                const label = document.createElement('div');
                label.className = 'slide-preview-page-label';
                label.textContent = t('dialogs.slideRange.pageLabel', { page: pageNumber });
                const image = document.createElement('img');
                image.loading = 'lazy';
                image.decoding = 'async';
                image.alt = t('dialogs.slideRange.pageLabel', { page: pageNumber });
                const imageUrl = resolvePreviewImageUrl(pageNumber);
                if (imageUrl) {
                  image.src = imageUrl;
                }
                wrapper.appendChild(label);
                wrapper.appendChild(image);
                dialog.pages.appendChild(wrapper);
                pageEntries.push({ element: wrapper, label, pageNumber });
                wrapper.addEventListener('click', (event) => {
                  handlePageSelection(pageNumber, event.shiftKey);
                });
                wrapper.addEventListener('keydown', (event) => {
                  if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handlePageSelection(pageNumber, event.shiftKey);
                  }
                });
              }
            }

            async function enableServerRenderedPreview({ knownPageCount = null } = {}) {
              if (cancelled) {
                return;
              }

              const countCandidates = [
                knownPageCount,
                previewSource && typeof previewSource.pageCount !== 'undefined'
                  ? previewSource.pageCount
                  : null,
              ];

              let resolvedCount = null;
              for (const candidate of countCandidates) {
                const numeric = Number(candidate);
                if (Number.isFinite(numeric) && numeric > 0) {
                  resolvedCount = Math.round(numeric);
                  break;
                }
              }

              const fallbackPreview = resolveFallbackPreview();

              if (!resolvedCount || resolvedCount <= 0) {
                try {
                  resolvedCount = await fetchPreviewPageCount();
                } catch (metadataError) {
                  resolvedCount = null;
                }
              }

              if (!resolvedCount || resolvedCount <= 0) {
                try {
                  const derivedCount = await derivePdfPageCount(fallbackPreview);
                  if (Number.isFinite(derivedCount) && derivedCount > 0) {
                    resolvedCount = Math.round(derivedCount);
                  }
                } catch (pageCountError) {
                  console.warn('Unable to determine PDF page count from PDF data', pageCountError);
                }
              }

              pageCount = Number.isFinite(resolvedCount) && resolvedCount > 0 ? Math.round(resolvedCount) : 0;
              configureInputBounds(pageCount);
              startPage = 1;
              endPage = pageCount > 0 ? pageCount : 1;
              anchorPage = 1;
              manualSelectionMade = false;

              assignFallbackPreview(fallbackPreview.url, {
                isObjectUrl: fallbackPreview.isObjectUrl,
              });

              if (dialog.loading) {
                dialog.loading.classList.add('hidden');
              }

              let renderSucceeded = false;
              if (!cancelled && pageCount > 0) {
                try {
                  await renderServerPreviewPages(pageCount);
                  renderSucceeded = true;
                } catch (error) {
                  if (!cancelled) {
                    console.warn('Unable to render slide previews', error);
                  }
                }
              }

              previewFailed = !renderSucceeded;

              if (dialog.error) {
                if (previewFailed) {
                  dialog.error.textContent = t('dialogs.slideRange.error');
                  dialog.error.classList.remove('hidden');
                } else {
                  dialog.error.textContent = '';
                  dialog.error.classList.add('hidden');
                }
              }

              updateFallbackVisibility();
              enableControls();
              updateRangeSummary();
              updateTexts();

              window.requestAnimationFrame(() => {
                if (dialog.startInput && !dialog.startInput.disabled) {
                  dialog.startInput.focus({ preventScroll: true });
                  dialog.startInput.select();
                } else if (dialog.confirm) {
                  dialog.confirm.focus({ preventScroll: true });
                }
              });
            }

            function clampZoom(value) {
              const numeric =
                typeof value === 'number'
                  ? value
                  : Number.parseInt(String(value ?? ''), 10);
              if (!Number.isFinite(numeric)) {
                return 100;
              }
              return Math.min(200, Math.max(50, Math.round(numeric)));
            }

            function updateZoomDisplay() {
              if (dialog.pages) {
                const scale = clampZoom(previewZoom) / 100;
                const minWidth = Math.round(BASE_PREVIEW_COLUMN_WIDTH * scale);
                dialog.pages.style.setProperty(
                  '--slide-preview-min-width',
                  `${minWidth}px`,
                );
              }
              const zoomText = t('dialogs.slideRange.zoomValue', {
                value: clampZoom(previewZoom),
              });
              if (dialog.zoomValue) {
                dialog.zoomValue.textContent = zoomText;
              }
              if (dialog.zoomSlider) {
                dialog.zoomSlider.setAttribute('aria-valuetext', zoomText);
              }
            }

            function handleZoomInput(event) {
              previewZoom = clampZoom(event?.target?.value);
              if (dialog.zoomSlider) {
                dialog.zoomSlider.value = String(previewZoom);
              }
              updateZoomDisplay();
            }

            function updateTexts() {
              if (dialog.title) {
                dialog.title.textContent = t('dialogs.slideRange.title');
              }
              if (dialog.description) {
                dialog.description.textContent = t('dialogs.slideRange.description');
              }
              if (dialog.startLabel) {
                dialog.startLabel.textContent = t('dialogs.slideRange.startLabel');
              }
              if (dialog.endLabel) {
                dialog.endLabel.textContent = t('dialogs.slideRange.endLabel');
              }
              if (dialog.zoomLabel) {
                dialog.zoomLabel.textContent = t('dialogs.slideRange.zoomLabel');
              }
              if (dialog.fallbackMessage) {
                dialog.fallbackMessage.textContent = t('dialogs.slideRange.fallbackMessage');
              }
              if (dialog.fallbackLink) {
                dialog.fallbackLink.textContent = t('dialogs.slideRange.fallbackLink');
              }
              if (dialog.fallbackFrame) {
                dialog.fallbackFrame.setAttribute(
                  'title',
                  t('dialogs.slideRange.fallbackFrameTitle'),
                );
              }
              if (dialog.selectAll) {
                dialog.selectAll.textContent = t('dialogs.slideRange.selectAll');
              }
              if (dialog.hint) {
                dialog.hint.textContent = t('dialogs.slideRange.rangeHint');
              }
              if (dialog.loading) {
                dialog.loading.textContent = t('dialogs.slideRange.loading');
              }
              if (dialog.confirm) {
                dialog.confirm.textContent = t('dialogs.slideRange.confirm');
              }
              if (dialog.cancel) {
                dialog.cancel.textContent = t('dialog.cancel');
              }
              if (previewFailed && dialog.error) {
                dialog.error.textContent = t('dialogs.slideRange.error');
              }
              updateZoomDisplay();
              pageEntries.forEach(({ label, pageNumber }) => {
                if (label) {
                  label.textContent = t('dialogs.slideRange.pageLabel', {
                    page: pageNumber,
                  });
                }
              });
            }

            function updateRangeSummary() {
              const lower = clampPage(startPage);
              const upper = clampPage(endPage);
              startPage = Math.min(lower, upper);
              endPage = Math.max(lower, upper);
              anchorPage = startPage;

              if (dialog.startInput) {
                dialog.startInput.value = String(startPage);
              }
              if (dialog.endInput) {
                dialog.endInput.value = String(endPage);
              }

              if (!pageCount || pageCount < 1) {
                if (dialog.summary) {
                  if (!manualSelectionMade) {
                    dialog.summary.textContent = t('dialogs.slideRange.allPages');
                  } else {
                    const key =
                      startPage === endPage
                        ? 'dialogs.slideRange.summarySingleUnknown'
                        : 'dialogs.slideRange.summaryUnknown';
                    dialog.summary.textContent = t(key, {
                      start: startPage,
                      end: endPage,
                    });
                  }
                }
                pageEntries.forEach(({ element }) => {
                  element.classList.add('selected');
                });
                return;
              }

              if (dialog.summary) {
                const key =
                  startPage === endPage
                    ? 'dialogs.slideRange.summarySingle'
                    : 'dialogs.slideRange.summary';
                dialog.summary.textContent = t(key, {
                  start: startPage,
                  end: endPage,
                  total: pageCount,
                });
              }

              pageEntries.forEach(({ element, pageNumber }) => {
                const selected = pageNumber >= startPage && pageNumber <= endPage;
                element.classList.toggle('selected', selected);
              });
            }

            function disableControls() {
              if (dialog.startInput) {
                dialog.startInput.disabled = true;
              }
              if (dialog.endInput) {
                dialog.endInput.disabled = true;
              }
              if (dialog.selectAll) {
                dialog.selectAll.disabled = true;
              }
              if (dialog.confirm) {
                dialog.confirm.disabled = true;
              }
              if (dialog.zoomSlider) {
                dialog.zoomSlider.disabled = true;
              }
            }

            function enableControls() {
              const hasPageCount = Boolean(pageCount && pageCount > 0);
              const manualOnly = previewFailed && !hasPageCount;
              if (dialog.startInput) {
                dialog.startInput.disabled = !manualOnly && !hasPageCount;
              }
              if (dialog.endInput) {
                dialog.endInput.disabled = !manualOnly && !hasPageCount;
              }
              if (dialog.selectAll) {
                const canSelectAll = hasPageCount || manualOnly;
                dialog.selectAll.disabled = !canSelectAll;
              }
              if (dialog.confirm) {
                dialog.confirm.disabled = false;
              }
              if (dialog.zoomSlider) {
                dialog.zoomSlider.disabled = !hasPageCount || previewFailed;
              }
            }

            function enableConfirmOnly() {
              if (dialog.confirm) {
                dialog.confirm.disabled = false;
              }
              if (dialog.selectAll) {
                dialog.selectAll.disabled = true;
              }
              if (dialog.zoomSlider) {
                dialog.zoomSlider.disabled = true;
              }
            }

            function cleanup() {
              cancelled = true;
              activeSlideRangeDialog = null;
              previewFailed = false;
              clearFallbackPreview();
              if (dialog.confirm) {
                dialog.confirm.removeEventListener('click', handleConfirm);
              }
              if (dialog.cancel) {
                dialog.cancel.removeEventListener('click', handleCancel);
              }
              if (dialog.backdrop) {
                dialog.backdrop.removeEventListener('click', handleCancel);
              }
              if (dialog.window) {
                dialog.window.removeEventListener('keydown', handleKeyDown);
              }
              if (dialog.startInput) {
                dialog.startInput.removeEventListener('input', handleStartInput);
                dialog.startInput.removeEventListener('blur', handleStartBlur);
              }
              if (dialog.endInput) {
                dialog.endInput.removeEventListener('input', handleEndInput);
                dialog.endInput.removeEventListener('blur', handleEndBlur);
              }
              if (dialog.selectAll) {
                dialog.selectAll.removeEventListener('click', handleSelectAll);
              }
              if (dialog.zoomSlider) {
                dialog.zoomSlider.removeEventListener('input', handleZoomInput);
              }
              if (dialog.root) {
                dialog.root.classList.add('hidden');
                dialog.root.setAttribute('aria-hidden', 'true');
              }
              if (dialog.preview) {
                dialog.preview.scrollTop = 0;
              }
              if (dialog.pages) {
                dialog.pages.innerHTML = '';
              }
              if (dialog.error) {
                dialog.error.classList.add('hidden');
                dialog.error.textContent = '';
              }
              if (dialog.loading) {
                dialog.loading.classList.remove('hidden');
              }
              if (dialog.summary) {
                dialog.summary.textContent = '';
              }
              if (dialog.zoomSlider) {
                dialog.zoomSlider.disabled = false;
                dialog.zoomSlider.value = '100';
              }
              previewZoom = 100;
              if (dialog.pages) {
                dialog.pages.style.removeProperty('--slide-preview-min-width');
              }
              if (dialog.zoomValue) {
                dialog.zoomValue.textContent = '';
              }
              dialogState.active = false;
              if (
                !dialogState.uploadActive &&
                !dialogState.bulkUploadActive &&
                !dialogState.bulkProcessActive &&
                !dialogState.bulkDownloadActive &&
                !dialogState.viewerActive
              ) {
                document.body.classList.remove('dialog-open');
              }
              if (previousActive) {
                previousActive.focus({ preventScroll: true });
              }
            }

            function resolveAndClose(result) {
              cleanup();
              resolve(result);
            }

            function handleConfirm(event) {
              event.preventDefault();
              if (dialog.confirm && dialog.confirm.disabled) {
                return;
              }
              if (previewFailed && (!pageCount || pageCount < 1) && !manualSelectionMade) {
                resolveAndClose({
                  confirmed: true,
                  pageStart: null,
                  pageEnd: null,
                  pageTotal: null,
                });
                return;
              }
              startPage = clampPage(dialog.startInput?.value ?? startPage);
              anchorPage = startPage;
              endPage = clampPage(dialog.endInput?.value ?? endPage);
              manualSelectionMade = manualSelectionMade || previewFailed;
              updateRangeSummary();
              resolveAndClose({
                confirmed: true,
                pageStart: startPage,
                pageEnd: endPage,
                pageTotal: pageCount > 0 ? pageCount : null,
              });
            }

            function handleCancel(event) {
              event?.preventDefault?.();
              resolveAndClose({
                confirmed: false,
                pageStart: null,
                pageEnd: null,
                pageTotal: pageCount > 0 ? pageCount : null,
              });
            }

            function getFocusableElements() {
              return [
                dialog.startInput,
                dialog.endInput,
                dialog.selectAll,
                dialog.confirm,
                dialog.cancel,
              ].filter((element) => element instanceof HTMLElement && !element.disabled);
            }

            function handleKeyDown(event) {
              if (event.key === 'Escape') {
                event.preventDefault();
                handleCancel(event);
                return;
              }
              if (event.key === 'Tab') {
                const focusable = getFocusableElements();
                if (!focusable.length) {
                  return;
                }
                const currentIndex = focusable.indexOf(document.activeElement);
                const nextIndex = event.shiftKey
                  ? currentIndex <= 0
                    ? focusable.length - 1
                    : currentIndex - 1
                  : currentIndex === focusable.length - 1
                    ? 0
                    : currentIndex + 1;
                focusable[nextIndex].focus({ preventScroll: true });
                event.preventDefault();
              }
            }

            function handleStartInput(event) {
              if (!pageCount && !previewFailed) {
                return;
              }
              const newValue = clampPage(event.target.value);
              if (!Number.isFinite(newValue)) {
                return;
              }
              startPage = newValue;
              anchorPage = startPage;
              manualSelectionMade = true;
              updateRangeSummary();
            }

            function handleStartBlur() {
              if (!pageCount && !previewFailed) {
                return;
              }
              startPage = clampPage(dialog.startInput?.value);
              anchorPage = startPage;
              manualSelectionMade = manualSelectionMade || previewFailed;
              updateRangeSummary();
            }

            function handleEndInput(event) {
              if (!pageCount && !previewFailed) {
                return;
              }
              const newValue = clampPage(event.target.value);
              if (!Number.isFinite(newValue)) {
                return;
              }
              endPage = newValue;
              manualSelectionMade = true;
              updateRangeSummary();
            }

            function handleEndBlur() {
              if (!pageCount && !previewFailed) {
                return;
              }
              endPage = clampPage(dialog.endInput?.value);
              manualSelectionMade = manualSelectionMade || previewFailed;
              updateRangeSummary();
            }

            function handleSelectAll(event) {
              event?.preventDefault?.();
              if (!pageCount && !previewFailed) {
                return;
              }
              startPage = 1;
              endPage = pageCount && pageCount > 0 ? pageCount : Math.max(1, endPage);
              anchorPage = startPage;
              manualSelectionMade = false;
              updateRangeSummary();
            }

            function handlePageSelection(pageNumber, extend) {
              if (!pageCount) {
                return;
              }
              const clamped = clampPage(pageNumber);
              if (extend) {
                const lower = Math.min(anchorPage, clamped);
                const upper = Math.max(anchorPage, clamped);
                startPage = lower;
                endPage = upper;
              } else {
                startPage = clamped;
                endPage = clamped;
                anchorPage = clamped;
              }
              manualSelectionMade = true;
              updateRangeSummary();
            }

            activeSlideRangeDialog = {
              updateTexts,
              updateRangeSummary,
            };

            if (dialog.pages) {
              dialog.pages.innerHTML = '';
            }
            if (dialog.summary) {
              dialog.summary.textContent = '';
            }
            if (dialog.error) {
              dialog.error.classList.add('hidden');
              dialog.error.textContent = '';
            }
            if (dialog.loading) {
              dialog.loading.classList.remove('hidden');
            }
            if (dialog.startInput) {
              dialog.startInput.value = '1';
            }
            if (dialog.endInput) {
              dialog.endInput.value = '1';
            }
            configureInputBounds(0);
            manualSelectionMade = false;

            disableControls();
            updateTexts();
            updateRangeSummary();

            if (dialog.root) {
              dialog.root.classList.remove('hidden');
              dialog.root.setAttribute('aria-hidden', 'false');
            }
            document.body.classList.add('dialog-open');
            if (dialog.preview) {
              dialog.preview.scrollTop = 0;
            }

            if (dialog.confirm) {
              dialog.confirm.addEventListener('click', handleConfirm);
            }
            if (dialog.cancel) {
              dialog.cancel.addEventListener('click', handleCancel);
            }
            if (dialog.backdrop) {
              dialog.backdrop.addEventListener('click', handleCancel);
            }
            if (dialog.window) {
              dialog.window.addEventListener('keydown', handleKeyDown);
            }
            if (dialog.startInput) {
              dialog.startInput.addEventListener('input', handleStartInput);
              dialog.startInput.addEventListener('blur', handleStartBlur);
            }
            if (dialog.endInput) {
              dialog.endInput.addEventListener('input', handleEndInput);
              dialog.endInput.addEventListener('blur', handleEndBlur);
            }
            if (dialog.selectAll) {
              dialog.selectAll.addEventListener('click', handleSelectAll);
            }
            if (dialog.zoomSlider) {
              previewZoom = clampZoom(dialog.zoomSlider.value);
              dialog.zoomSlider.addEventListener('input', handleZoomInput);
            }

            window.requestAnimationFrame(() => {
              if (dialog.startInput && !dialog.startInput.disabled) {
                dialog.startInput.focus({ preventScroll: true });
                dialog.startInput.select();
              } else if (dialog.cancel) {
                dialog.cancel.focus({ preventScroll: true });
              } else if (dialog.confirm && !dialog.confirm.disabled) {
                dialog.confirm.focus({ preventScroll: true });
              }
            });

            (async () => {
              try {
                await enableServerRenderedPreview();
              } catch (error) {
                if (cancelled) {
                  return;
                }
                console.warn('Slide preview failed, enabling manual page selection', error);
                enableControls();
              }
            })();
          });
        }

        function formatNumber(value) {
          return new Intl.NumberFormat().format(value ?? 0);
        }

        function formatBytes(bytes) {
          if (typeof bytes !== 'number' || Number.isNaN(bytes)) {
            return '';
          }
          if (bytes < 1024) {
            return `${bytes} B`;
          }
          const units = ['KB', 'MB', 'GB', 'TB'];
          let value = bytes / 1024;
          let unitIndex = 0;
          while (value >= 1024 && unitIndex < units.length - 1) {
            value /= 1024;
            unitIndex += 1;
          }
          return `${value >= 100 ? Math.round(value) : value.toFixed(1)} ${units[unitIndex]}`;
        }

        function formatDate(isoString) {
          if (!isoString) {
            return '';
          }
          const formatter = new Intl.DateTimeFormat(undefined, {
            dateStyle: 'medium',
            timeStyle: 'short',
          });
          return formatter.format(new Date(isoString));
        }

        function escapeHtml(value) {
          if (value === null || value === undefined) {
            return '';
          }
          return String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        }

        function renderInlineMarkdown(text) {
          let result = escapeHtml(text ?? '');
          result = result.replace(/(\*\*|__)(.+?)\1/g, '<strong>$2</strong>');
          result = result.replace(/(\*|_)([^*_]+?)\1/g, '<em>$2</em>');
          result = result.replace(/`([^`]+?)`/g, '<code>$1</code>');
          return result;
        }

        function convertMarkdownToHtml(markdown) {
          if (typeof markdown !== 'string') {
            return '';
          }
          const lines = markdown.replace(/\r\n?/g, '\n').split('\n');
          let html = '';
          let inParagraph = false;
          let inCodeBlock = false;
          let codeFence = '```';
          let listType = null;

          const closeParagraph = () => {
            if (inParagraph) {
              html += '</p>';
              inParagraph = false;
            }
          };

          const closeList = () => {
            if (listType === 'ul') {
              html += '</ul>';
            } else if (listType === 'ol') {
              html += '</ol>';
            }
            listType = null;
          };

          const closeCodeBlock = () => {
            if (inCodeBlock) {
              html += '</code></pre>';
              inCodeBlock = false;
            }
          };

          lines.forEach((line) => {
            const rawLine = line.replace(/\s+$/g, '');
            const trimmed = rawLine.trim();

            if (inCodeBlock) {
              if (trimmed.startsWith(codeFence)) {
                closeCodeBlock();
                return;
              }
              html += `${escapeHtml(line)}\n`;
              return;
            }

            const fenceMatch = trimmed.match(/^`{3,}/);
            if (fenceMatch) {
              closeParagraph();
              closeList();
              inCodeBlock = true;
              codeFence = fenceMatch[0];
              html += '<pre><code>';
              return;
            }

            if (!trimmed) {
              closeParagraph();
              closeList();
              return;
            }

            const hrMatch = trimmed.match(/^([-*_])\1{2,}$/);
            if (hrMatch) {
              closeParagraph();
              closeList();
              html += '<hr />';
              return;
            }

            const headingMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
            if (headingMatch) {
              closeParagraph();
              closeList();
              const level = Math.min(6, headingMatch[1].length);
              html += `<h${level}>${renderInlineMarkdown(headingMatch[2])}</h${level}>`;
              return;
            }

            const unorderedMatch = trimmed.match(/^[-*+]\s+(.*)$/);
            if (unorderedMatch) {
              closeParagraph();
              if (listType !== 'ul') {
                closeList();
                html += '<ul>';
                listType = 'ul';
              }
              html += `<li>${renderInlineMarkdown(unorderedMatch[1])}</li>`;
              return;
            }

            const orderedMatch = trimmed.match(/^\d+\.\s+(.*)$/);
            if (orderedMatch) {
              closeParagraph();
              if (listType !== 'ol') {
                closeList();
                html += '<ol>';
                listType = 'ol';
              }
              html += `<li>${renderInlineMarkdown(orderedMatch[1])}</li>`;
              return;
            }

            if (!inParagraph) {
              closeList();
              html += '<p>';
              inParagraph = true;
              html += renderInlineMarkdown(trimmed);
            } else {
              html += `<br />${renderInlineMarkdown(trimmed)}`;
            }
          });

          closeCodeBlock();
          closeParagraph();
          closeList();
          return html;
        }

        function buildAssetViewerMeta(type, metadata) {
          const parts = [];
          const typeLabel = t(`viewer.types.${type}`) || type.toUpperCase();
          if (typeLabel) {
            parts.push(typeLabel);
          }
          const size = metadata?.size;
          if (typeof size === 'number' && Number.isFinite(size) && size >= 0) {
            parts.push(formatBytes(size));
          }
          return parts.join('  ');
        }

        function setAssetViewerMeta(meta) {
          const element = dom.viewer?.meta;
          if (!element) {
            return;
          }
          if (meta && meta.trim()) {
            element.textContent = `[${meta}]`;
            element.classList.remove('hidden');
          } else {
            element.textContent = '';
            element.classList.add('hidden');
          }
        }

        function setAssetViewerStatus(message) {
          const element = dom.viewer?.status;
          if (!element) {
            return;
          }
          if (message && message.trim()) {
            element.textContent = message;
            element.classList.remove('hidden');
          } else {
            element.textContent = '';
            element.classList.add('hidden');
          }
        }

        async function fetchAssetMetadata(url) {
          if (typeof url !== 'string' || !url) {
            return null;
          }
          try {
            const response = await fetch(url, { method: 'HEAD' });
            if (!response.ok) {
              return null;
            }
            const lengthHeader = response.headers.get('content-length');
            const size = lengthHeader ? Number.parseInt(lengthHeader, 10) : null;
            const contentType = response.headers.get('content-type') || '';
            return {
              size: Number.isFinite(size) && size !== null && size >= 0 ? size : null,
              contentType,
            };
          } catch (error) {
            console.warn('Failed to fetch asset metadata', error);
            return null;
          }
        }

        function resolveAssetViewerType(path, definition) {
          if (typeof path !== 'string' || !path) {
            return null;
          }
          const lowerPath = path.toLowerCase();
          const sanitized = lowerPath.split(/[?#]/, 1)[0];
          const extension = sanitized.includes('.')
            ? sanitized.slice(sanitized.lastIndexOf('.') + 1)
            : '';
          if (extension === 'pdf') {
            return 'pdf';
          }
          if (['txt', 'text'].includes(extension)) {
            return 'text';
          }
          if (['md', 'markdown', 'mdown', 'mkd'].includes(extension)) {
            return 'markdown';
          }
          const assetType = typeof definition?.type === 'string' ? definition.type : '';
          if (!extension && ['transcript', 'notes'].includes(assetType)) {
            return 'text';
          }
          return null;
        }

        function isAssetViewable(definition, value) {
          return Boolean(resolveAssetViewerType(value, definition));
        }

        function closeAssetViewer({ restoreFocus = true } = {}) {
          const viewer = dom.viewer;
          const previousActive = state.viewer.previousActive;
          state.viewer.loadId += 1;
          state.viewer.active = false;
          state.viewer.url = null;
          state.viewer.filename = '';
          state.viewer.type = null;
          state.viewer.previousActive = null;
          if (viewer?.content) {
            viewer.content.innerHTML = '';
            viewer.content.classList.remove('pdf-mode', 'text-mode', 'markdown-mode');
            viewer.content.scrollTop = 0;
            viewer.content.scrollLeft = 0;
          }
          setAssetViewerStatus('');
          setAssetViewerMeta('');
          if (viewer?.root) {
            viewer.root.classList.add('hidden');
            viewer.root.setAttribute('aria-hidden', 'true');
          }
          dialogState.viewerActive = false;
          if (
            !dialogState.active &&
            !dialogState.uploadActive &&
            !dialogState.bulkUploadActive &&
            !dialogState.bulkProcessActive &&
            !dialogState.bulkDownloadActive
          ) {
            document.body.classList.remove('dialog-open');
          }
          if (restoreFocus && previousActive) {
            previousActive.focus({ preventScroll: true });
          }
        }

        function openAssetViewer(definition, value) {
          if (
            dialogState.active ||
            dialogState.uploadActive ||
            dialogState.bulkUploadActive ||
            dialogState.bulkProcessActive ||
            dialogState.bulkDownloadActive
          ) {
            return;
          }
          const path = typeof value === 'string' ? value : '';
          if (!path) {
            return;
          }
          const type = resolveAssetViewerType(path, definition);
          if (!type) {
            showStatus(t('viewer.unsupported'), 'info');
            return;
          }
          const viewer = dom.viewer;
          if (!viewer || !viewer.root || !viewer.content) {
            showStatus(t('viewer.failed'), 'error');
            return;
          }

          closeAssetViewer({ restoreFocus: false });

          const previousActive =
            document.activeElement instanceof HTMLElement ? document.activeElement : null;
          const url = buildStorageURL(path);
          const fallbackName = definition?.type ? `${definition.type}.bin` : 'asset.bin';
          const fileName = path.split('/').pop() || fallbackName;

          state.viewer.active = true;
          state.viewer.url = url;
          state.viewer.filename = fileName;
          state.viewer.type = type;
          state.viewer.previousActive = previousActive;
          state.viewer.loadId += 1;
          const loadId = state.viewer.loadId;

          dialogState.viewerActive = true;

          viewer.title.textContent = fileName;
          viewer.download?.setAttribute('data-i18n', 'assets.actions.download');
          if (viewer.download) {
            viewer.download.textContent = t('assets.actions.download');
            viewer.download.disabled = !url;
          }
          if (viewer.close) {
            viewer.close.textContent = t('common.actions.close');
          }
          setAssetViewerMeta(buildAssetViewerMeta(type, null));
          setAssetViewerStatus(t('viewer.loading'));

          viewer.root.classList.remove('hidden');
          viewer.root.setAttribute('aria-hidden', 'false');
          viewer.content.innerHTML = '';
          viewer.content.classList.remove('pdf-mode', 'text-mode', 'markdown-mode');
          viewer.content.scrollTop = 0;
          viewer.content.scrollLeft = 0;
          document.body.classList.add('dialog-open');

          window.requestAnimationFrame(() => {
            const focusTarget = viewer.window || viewer.close || viewer.download;
            focusTarget?.focus?.({ preventScroll: true });
          });

          fetchAssetMetadata(url)
            .then((metadata) => {
              if (state.viewer.loadId !== loadId) {
                return;
              }
              const metaText = buildAssetViewerMeta(type, metadata);
              if (metaText) {
                setAssetViewerMeta(metaText);
              }
            })
            .catch(() => {
              // Ignore metadata failures.
            });

          if (type === 'pdf') {
            const frame = document.createElement('iframe');
            frame.src = url;
            frame.title = fileName;
            frame.setAttribute('loading', 'lazy');
            frame.addEventListener('load', () => {
              if (state.viewer.loadId === loadId) {
                setAssetViewerStatus('');
              }
            });
            frame.addEventListener('error', () => {
              if (state.viewer.loadId === loadId) {
                setAssetViewerStatus(t('viewer.failed'));
              }
            });
            viewer.content.appendChild(frame);
            viewer.content.classList.add('pdf-mode');
            return;
          }

          (async () => {
            try {
              const response = await fetch(url, { cache: 'no-store' });
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }
              const text = await response.text();
              if (state.viewer.loadId !== loadId) {
                return;
              }
              if (type === 'text') {
                const pre = document.createElement('pre');
                pre.textContent = text;
                viewer.content.appendChild(pre);
                viewer.content.classList.add('text-mode');
              } else {
                const wrapper = document.createElement('div');
                wrapper.className = 'asset-viewer-markdown';
                wrapper.innerHTML = convertMarkdownToHtml(text);
                viewer.content.appendChild(wrapper);
                viewer.content.classList.add('markdown-mode');
              }
              setAssetViewerStatus('');
            } catch (error) {
              if (state.viewer.loadId !== loadId) {
                return;
              }
              console.warn('Unable to load asset preview', error);
              setAssetViewerStatus(t('viewer.failed'));
            }
          })();
        }

        function buildStorageURL(path) {
          if (!path) {
            return '#';
          }
          const encodedPath = path
            .split('/')
            .map((segment) => encodeURIComponent(segment))
            .join('/');
          const url = `/storage/${encodedPath}`;
          if (state.cloudConnection.enabled && state.cloudConnection.connected && shouldRouteToCloud(url)) {
            return resolveCloudServerUrl(url);
          }
          return resolveAppUrl(url);
        }

        function buildStorageListUrl(path) {
          if (!path) {
            return '/api/storage/list';
          }
          const params = new URLSearchParams();
          params.set('path', path);
          return `/api/storage/list?${params.toString()}`;
        }

        async function uploadWithProgress(url, options = {}) {
          const resolvedUrl = resolveAppUrl(url);
          const method = typeof options.method === 'string' ? options.method.toUpperCase() : 'POST';
          const headers = options.headers && typeof options.headers === 'object' ? options.headers : {};
          const body = options.body ?? null;
          const onProgress = typeof options.onProgress === 'function' ? options.onProgress : null;

          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open(method, resolvedUrl);
            xhr.responseType = 'json';

            Object.entries(headers).forEach(([key, value]) => {
              if (typeof key === 'string' && typeof value === 'string') {
                xhr.setRequestHeader(key, value);
              }
            });

            xhr.upload.addEventListener('progress', (event) => {
              if (!onProgress) {
                return;
              }
              if (event.lengthComputable && event.total > 0) {
                onProgress(event.loaded / event.total);
              }
            });

            xhr.addEventListener('load', () => {
              if (onProgress) {
                onProgress(1);
              }
              if (xhr.status >= 200 && xhr.status < 300) {
                const responseBody = xhr.response ?? null;
                resolve(responseBody);
                return;
              }
              let detail = `${xhr.status} ${xhr.statusText || ''}`.trim();
              const responseBody = xhr.response ?? null;
              if (responseBody && typeof responseBody === 'object' && responseBody.detail) {
                detail = responseBody.detail;
              } else if (!responseBody && xhr.responseText) {
                try {
                  const parsed = JSON.parse(xhr.responseText);
                  if (parsed && parsed.detail) {
                    detail = parsed.detail;
                  }
                } catch (error) {
                  // Ignore parse errors.
                }
              }
              if (!detail) {
                detail = 'Upload failed.';
              }
              reject(new Error(detail));
            });

            xhr.addEventListener('error', () => {
              reject(new Error('Network error during upload.'));
            });

            xhr.addEventListener('abort', () => {
              reject(new Error('Upload was aborted.'));
            });

            try {
              xhr.send(body);
            } catch (error) {
              reject(error instanceof Error ? error : new Error('Unable to start upload.'));
            }
          });
        }

        async function request(url, options = {}) {
          const shouldUseCloud =
            state.cloudConnection.enabled && shouldRouteToCloud(url);
          const useCloud =
            shouldUseCloud &&
            (!isProcessingEndpoint(url) ||
              state.cloudConnection.processingTarget === 'cloud');
          if (useCloud && !state.cloudConnection.connected) {
            const ok = await testCloudConnection({ silent: true });
            if (!ok) {
              throw new Error(t('settings.cloudConnection.errors.disconnected'));
            }
          }
          const resolvedUrl = useCloud ? resolveCloudServerUrl(url) : resolveAppUrl(url);
          try {
            const response = await fetch(resolvedUrl, options);
            if (!response.ok) {
              let detail = `${response.status} ${response.statusText}`;
              try {
                const payload = await response.json();
                if (payload && payload.detail) {
                  detail = payload.detail;
                }
              } catch (error) {
                // Ignore JSON parsing errors.
              }
              throw new Error(detail);
            }
            if (response.status === 204) {
              return null;
            }
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
              return await response.json();
            }
            return null;
          } catch (error) {
            if (useCloud) {
              await handleCloudConnectionDisconnect(error);
            }
            throw error;
          }
        }

        async function createSlidePreview(lectureId, file, options = {}) {
          if (!lectureId) {
            return null;
          }
          const formData = new FormData();
          const source =
            typeof options.source === 'string' && options.source
              ? options.source.trim().toLowerCase()
              : 'upload';
          if (source === 'existing') {
            formData.append('source', 'existing');
          } else {
            if (!(file instanceof Blob)) {
              return null;
            }
            formData.append('file', file);
          }
          const payload = await request(
            `/api/lectures/${lectureId}/slides/previews`,
            { method: 'POST', body: formData },
          );
          if (!payload || !payload.preview_id || !payload.preview_url) {
            return null;
          }
          const previewUrl = payload.preview_url;
          const resolvedPreviewUrl =
            state.cloudConnection.enabled &&
            state.cloudConnection.connected &&
            shouldRouteToCloud(previewUrl)
              ? resolveCloudServerUrl(previewUrl)
              : resolveAppUrl(previewUrl);
          const providedName =
            (typeof payload.filename === 'string' && payload.filename) ||
            (file && typeof file.name === 'string' && file.name) ||
            'slides.pdf';
          return {
            id: payload.preview_id,
            url: resolvedPreviewUrl,
            filename: providedName,
            pageCount:
              typeof payload.page_count === 'number' && Number.isFinite(payload.page_count)
                ? Math.max(0, Math.round(payload.page_count))
                : null,
          };
        }

        async function deleteSlidePreview(lectureId, previewId) {
          if (!lectureId || !previewId) {
            return;
          }
          try {
            await request(
              `/api/lectures/${lectureId}/slides/previews/${encodeURIComponent(previewId)}`,
              { method: 'DELETE' },
            );
          } catch (error) {
            console.warn('Failed to remove slide preview', error);
          }
        }

        async function loadGpuWhisperStatus() {
          try {
            const payload = await request('/api/settings/whisper-gpu/status');
            const status = payload?.status || {};
            updateGpuWhisperUI(status);
          } catch (error) {
            updateGpuWhisperUI({
              supported: false,
              checked: true,
              message: error instanceof Error ? error.message : String(error),
              unavailable: false,
            });
          }
        }

        async function fetchTranscriptionProgress(lectureId) {
          if (!lectureId) {
            return null;
          }
          try {
            const payload = await request(
              `/api/lectures/${lectureId}/transcription-progress`,
            );
            return payload?.progress || null;
          } catch (error) {
            return null;
          }
        }

        async function fetchProcessingProgress(lectureId) {
          if (!lectureId) {
            return null;
          }
          try {
            const payload = await request(
              `/api/lectures/${lectureId}/processing-progress`,
            );
            return payload?.progress || null;
          } catch (error) {
            return null;
          }
        }

        function stopTranscriptionProgress({ preserveMessage = false } = {}) {
          if (state.transcriptionProgressTimer !== null) {
            window.clearInterval(state.transcriptionProgressTimer);
          }
          state.transcriptionProgressTimer = null;
          state.transcriptionProgressLectureId = null;
          if (!preserveMessage) {
            state.lastProgressMessage = '';
            state.lastProgressRatio = null;
          }
        }

        function stopProcessingProgress({ preserveMessage = false } = {}) {
          if (state.processingProgressTimer !== null) {
            window.clearInterval(state.processingProgressTimer);
          }
          state.processingProgressTimer = null;
          state.processingProgressLectureId = null;
          if (!preserveMessage) {
            state.lastProgressMessage = '';
            state.lastProgressRatio = null;
          }
        }

        async function handleProgressUpdate(progress, context = {}) {
          if (!progress) {
            return;
          }
          const source = context?.source || 'transcription';
          const lectureId = context?.lectureId || null;
          const message = progress.message || '';
          const variant = progress.error ? 'error' : 'info';
          const finished = Boolean(progress.finished);
          const ratio =
            typeof progress.ratio === 'number' && Number.isFinite(progress.ratio)
              ? Math.max(0, Math.min(progress.ratio, 1))
              : null;
          const shouldUpdate =
            message !== state.lastProgressMessage || ratio !== state.lastProgressRatio;
          const progressTaskId = progress?.task?.task_id;
          const consoleKey =
            typeof progressTaskId === 'string' && progressTaskId
              ? progressTaskId
              : Number.isFinite(lectureId)
              ? `${source}:${lectureId}`
              : null;
          if (shouldUpdate) {
            const displayMessage = message || state.lastProgressMessage || t('status.processing');
            showStatus(displayMessage, variant, {
              progressRatio: ratio,
              persist: !finished,
              consoleKey: consoleKey || undefined,
            });
            state.lastProgressMessage = message;
            state.lastProgressRatio = ratio;
          }
          if (finished) {
            if (source === 'processing') {
              stopProcessingProgress({ preserveMessage: true });
              if (lectureId) {
                try {
                  await refreshData();
                  if (state.selectedLectureId === lectureId) {
                    await selectLecture(lectureId);
                  }
                } catch (error) {
                  const detail =
                    error instanceof Error && error.message
                      ? error.message
                      : t('status.storageLoadFailed');
                  showStatus(detail, 'error');
                }
              }
            } else {
              stopTranscriptionProgress({ preserveMessage: true });
            }
          }
            await refreshTasks({ silent: true });
        }

        function startTranscriptionProgress(lectureId) {
          stopTranscriptionProgress();
          if (!lectureId) {
            return;
          }
          state.transcriptionProgressLectureId = lectureId;
          let polling = false;
          const poll = async () => {
            if (polling) {
              return;
            }
            polling = true;
            try {
              const progress = await fetchTranscriptionProgress(lectureId);
              if (progress) {
                await handleProgressUpdate(progress, { source: 'transcription', lectureId });
              }
            } finally {
              polling = false;
            }
          };
          void poll();
          state.transcriptionProgressTimer = window.setInterval(() => {
            void poll();
          }, 1200);
        }

        function startProcessingProgress(lectureId) {
          stopProcessingProgress();
          if (!lectureId) {
            return;
          }
          state.processingProgressLectureId = lectureId;
          let polling = false;
          const poll = async () => {
            if (polling) {
              return;
            }
            polling = true;
            try {
              const progress = await fetchProcessingProgress(lectureId);
              if (progress) {
                await handleProgressUpdate(progress, { source: 'processing', lectureId });
              }
            } finally {
              polling = false;
            }
          };
          void poll();
          state.processingProgressTimer = window.setInterval(() => {
            void poll();
          }, 900);
        }

        function clearDetailPanel() {
          dom.summary.textContent = t('details.summaryPlaceholder');
          dom.summary.classList.add('placeholder');
          if (dom.editForm) {
            dom.editForm.reset();
          }
          dom.assetSection.hidden = true;
          dom.assetList.innerHTML = '';
          setTranscribeControls(null, null, null);
          setTranscribeButtonDisabled(true);
          state.selectedLectureDetail = null;
          updateEditControlsAvailability();
        }

        function updateEditControlsAvailability() {
          const hasSelection = Boolean(state.selectedLectureId);
          const allowEditing = state.editMode && hasSelection;
          dom.editForm.hidden = !allowEditing;
          dom.deleteButton.hidden = !allowEditing;
        }

        function updateEditModeUI() {
          const isActive = state.editMode;
          if (dom.editToggle) {
            dom.editToggle.textContent = isActive
              ? t('topBar.exitEdit')
              : t('topBar.enableEdit');
            dom.editToggle.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            dom.editToggle.classList.toggle('active', isActive);
          }
          if (dom.editBanner) {
            dom.editBanner.hidden = !isActive;
          }
          renderCurriculum();
          updateEditControlsAvailability();
        }

        function updateViewDirection(targetView) {
          const previousIndex = VIEW_SEQUENCE.indexOf(state.activeView);
          const nextIndex = VIEW_SEQUENCE.indexOf(targetView);
          let direction = state.viewDirection || 1;
          if (previousIndex !== -1 && nextIndex !== -1) {
            if (nextIndex > previousIndex) {
              direction = 1;
            } else if (nextIndex < previousIndex) {
              direction = -1;
            }
          }
          state.viewDirection = direction;
          if (dom.viewStack) {
            dom.viewStack.style.setProperty('--view-direction', String(direction));
            dom.viewStack.dataset.direction = direction === 1 ? 'forward' : 'backward';
          }
        }

        function setActiveView(view) {
          if (!dom.views[view]) {
            return;
          }
          updateViewDirection(view);
          state.activeView = view;
          dom.viewButtons.forEach((button) => {
            const isActive = button.dataset.view === view;
            button.classList.toggle('active', isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
          if (dom.sidebarOverview) {
            dom.sidebarOverview.hidden = view !== 'settings';
          }
          const effectsLevel = document.body?.dataset?.effects || DEFAULT_VISUAL_EFFECTS;
          const useTransitions = effectsLevel !== 'none';
          Object.entries(dom.views).forEach(([key, element]) => {
            if (!element) {
              return;
            }
            const isTarget = key === view;
            if (isTarget) {
              element.classList.remove('active');
              element.classList.remove('leaving');
              element.hidden = false;
              element.setAttribute('aria-hidden', 'false');
              element.scrollTop = 0;
              if (useTransitions) {
                requestAnimationFrame(() => {
                  element.classList.add('active');
                });
              } else {
                element.classList.add('active');
              }
            } else if (!element.hidden && element.classList.contains('active')) {
              if (useTransitions) {
                element.classList.remove('active');
                element.classList.add('leaving');
                element.setAttribute('aria-hidden', 'true');
                const finalize = (event) => {
                  if (event.propertyName !== 'opacity') {
                    return;
                  }
                  if (element.classList.contains('active')) {
                    return;
                  }
                  element.hidden = true;
                  element.classList.remove('leaving');
                };
                element.addEventListener('transitionend', finalize, { once: true });
                window.setTimeout(() => {
                  if (!element.hidden && !element.classList.contains('active')) {
                    element.hidden = true;
                    element.classList.remove('leaving');
                  }
                }, 600);
              } else {
                element.classList.remove('active');
                element.classList.remove('leaving');
                element.hidden = true;
                element.setAttribute('aria-hidden', 'true');
              }
            } else {
              element.classList.remove('active');
              element.classList.remove('leaving');
              element.hidden = true;
              element.setAttribute('aria-hidden', 'true');
            }
          });
          if (view === 'storage') {
            const browserState = getStorageBrowserState();
            if (
              (!state.storage.initialized && !state.storage.loading) ||
              (!browserState.initialized && !browserState.loading)
            ) {
              void refreshStorage({ includeOverview: true, force: true });
            } else {
              renderStorage();
            }
            stopTaskPolling();
          } else if (view === 'tasks') {
            updateTaskLectureOptions();
            void refreshTasks({ force: true });
            startTaskPolling();
          } else {
            stopTaskPolling();
          }
        }

        function updateStats() {
          const stats = state.stats;
          const entries = [
            [t('stats.classes'), stats.class_count],
            [t('stats.modules'), stats.module_count],
            [t('stats.lectures'), stats.lecture_count],
            [t('stats.transcripts'), stats.transcript_count],
            [t('stats.slideDecks'), stats.slide_count],
            [t('stats.audio'), stats.audio_count],
            [t('stats.processedAudio'), stats.processed_audio_count],
            [t('stats.notes'), stats.notes_count],
            [t('stats.slideArchives'), stats.slide_image_count],
          ];
          dom.stats.innerHTML = '';
          entries.forEach(([label, value]) => {
            const block = document.createElement('div');
            const term = document.createElement('dt');
            term.textContent = label;
            const data = document.createElement('dd');
            data.textContent = formatNumber(value);
            block.appendChild(term);
            block.appendChild(data);
            dom.stats.appendChild(block);
          });
        }

        function getLectureOptionList() {
          const lectures = [];
          state.classes.forEach((klass) => {
            (klass.modules || []).forEach((module) => {
              (module.lectures || []).forEach((lecture) => {
                lectures.push({
                  id: lecture.id,
                  name: lecture.name,
                  className: klass.name,
                  moduleName: module.name,
                });
              });
            });
          });
          return lectures;
        }

        function formatLectureOptionLabel(item) {
          if (!item) {
            return '';
          }
          const contextParts = [];
          if (item.className) {
            contextParts.push(item.className);
          }
          if (item.moduleName) {
            contextParts.push(item.moduleName);
          }
          const contextLabel = contextParts.length ? `  ${contextParts.join('  ')}` : '';
          return `${item.name}${contextLabel}`;
        }

        function updateTaskLectureOptions() {
          if (!dom.tasks) {
            return;
          }

          const lectures = getLectureOptionList();
          const hasLectures = lectures.length > 0;

          if (dom.tasks.bulkUpload) {
            dom.tasks.bulkUpload.disabled = !hasLectures;
          }

          const { availableCount } = collectBulkProcessMeta();
          if (dom.tasks.bulkProcess) {
            dom.tasks.bulkProcess.disabled = availableCount === 0;
          }

          if (dialogState.bulkProcessActive) {
            renderBulkProcessTree();
            updateBulkProcessSummary();
            setBulkProcessStatus('');
          }

          const { availableCount: downloadCount } = collectBulkDownloadMeta();
          if (dom.tasks.bulkDownload) {
            dom.tasks.bulkDownload.disabled = downloadCount === 0;
          }
          if (dialogState.bulkDownloadActive) {
            renderBulkDownloadTree();
            updateBulkDownloadSummary();
            setBulkDownloadStatus('');
          }
        }

        function guessBulkAssetType(file) {
          if (!file) {
            return null;
          }
          const name = typeof file.name === 'string' ? file.name.toLowerCase() : '';
          const type = typeof file.type === 'string' ? file.type.toLowerCase() : '';
          const extension = name.includes('.') ? name.slice(name.lastIndexOf('.') + 1) : '';
          const audioExtensions = new Set(['wav', 'mp3', 'mp4', 'm4a', 'aac', 'flac', 'ogg', 'oga', 'opus']);
          if (type.startsWith('audio/') || type === 'video/mp4' || audioExtensions.has(extension)) {
            return 'audio';
          }
          if (type === 'application/pdf' || extension === 'pdf') {
            return 'slides';
          }
          if (type === 'text/plain' || extension === 'txt') {
            return 'transcript';
          }
          if (type.includes('markdown') || ['md', 'markdown'].includes(extension)) {
            return 'notes';
          }
          if (
            ['application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'].includes(
              type,
            ) ||
            ['doc', 'docx'].includes(extension)
          ) {
            return 'notes';
          }
          return null;
        }

        async function uploadLectureAssetWithProgress(lectureId, definition, file, onProgress) {
          if (!definition) {
            throw new Error('Unsupported asset type.');
          }
          const formData = new FormData();
          formData.append('file', file);
          const endpoint = `/api/lectures/${lectureId}/assets/${definition.type}`;
          return uploadWithProgress(endpoint, {
            method: 'POST',
            body: formData,
            onProgress: (ratio) => {
              if (typeof onProgress === 'function') {
                onProgress(Number.isFinite(ratio) ? ratio : 0);
              }
            },
          });
        }

        async function showBulkUploadStep(options) {
          return new Promise((resolve) => {
            const dialog = dom.bulkUploadDialog;
            if (
              !dialog ||
              !dialog.root ||
              dialogState.bulkUploadActive ||
              dialogState.uploadActive ||
              dialogState.active ||
              dialogState.viewerActive
            ) {
              resolve({ action: 'cancel' });
              return;
            }

            dialogState.bulkUploadActive = true;
            const previousActive =
              document.activeElement instanceof HTMLElement ? document.activeElement : null;
            let settled = false;
            let busy = false;

            const file = options?.file || null;
            const lectures = Array.isArray(options?.lectures) ? options.lectures : [];
            const total = Number.isFinite(Number(options?.total)) ? Number(options.total) : 1;
            const index = Number.isFinite(Number(options?.index)) ? Number(options.index) : 0;
            const currentNumber = Math.min(total, index + 1);
            const isLast = currentNumber === total;
            const defaultLectureId = Number(options?.defaultLectureId) || null;
            const defaultType = typeof options?.defaultType === 'string' ? options.defaultType : null;

            const availableDefinitions = uploadableAssetDefinitions.slice();

            function setStatusMessage(message, variant = '') {
              if (!dialog.status) {
                return;
              }
              dialog.status.textContent = message || '';
              dialog.status.classList.remove('success', 'error', 'info');
              if (variant) {
                dialog.status.classList.add(variant);
              }
            }

            function setBusyState(value) {
              busy = Boolean(value);
              const disabled = Boolean(value);
              const controls = [dialog.lecture, dialog.type, dialog.dispose, dialog.disposeAll, dialog.cancel, dialog.next];
              controls.forEach((control) => {
                if (control) {
                  control.disabled = disabled;
                }
              });
            }

            function cleanup(result) {
              if (settled) {
                return;
              }
              settled = true;
              dialog.next.removeEventListener('click', handleConfirm);
              if (dialog.dispose) {
                dialog.dispose.removeEventListener('click', handleDispose);
              }
              if (dialog.disposeAll) {
                dialog.disposeAll.removeEventListener('click', handleDisposeAll);
              }
              if (dialog.cancel) {
                dialog.cancel.removeEventListener('click', handleCancel);
              }
              if (dialog.backdrop) {
                dialog.backdrop.removeEventListener('click', handleCancel);
              }
              if (dialog.window) {
                dialog.window.removeEventListener('keydown', handleKeyDown);
              }
              dialog.root.classList.add('hidden');
              dialog.root.setAttribute('aria-hidden', 'true');
              setStatusMessage('', '');
              if (dialog.lecture) {
                dialog.lecture.innerHTML = '';
              }
              if (dialog.type) {
                dialog.type.innerHTML = '';
              }
              dialogState.bulkUploadActive = false;
              if (
                !dialogState.active &&
                !dialogState.uploadActive &&
                !dialogState.bulkProcessActive &&
                !dialogState.bulkDownloadActive &&
                !dialogState.viewerActive
              ) {
                document.body.classList.remove('dialog-open');
              }
              if (previousActive) {
                previousActive.focus({ preventScroll: true });
              }
              resolve(result);
            }

            function handleDispose(event) {
              event.preventDefault();
              cleanup({ action: 'dispose' });
            }

            function handleDisposeAll(event) {
              event.preventDefault();
              cleanup({ action: 'dispose_all' });
            }

            function handleCancel(event) {
              event.preventDefault();
              cleanup({ action: 'cancel' });
            }

            function handleKeyDown(event) {
              if (event.key === 'Escape') {
                event.preventDefault();
                handleCancel(event);
                return;
              }
              if (event.key === 'Enter') {
                if (document.activeElement === dialog.dispose) {
                  handleDispose(event);
                  return;
                }
                if (document.activeElement === dialog.disposeAll) {
                  handleDisposeAll(event);
                  return;
                }
                if (document.activeElement === dialog.cancel) {
                  handleCancel(event);
                  return;
                }
                handleConfirm(event);
                return;
              }
              if (event.key === 'Tab') {
                const focusable = [
                  dialog.lecture,
                  dialog.type,
                  dialog.dispose,
                  dialog.disposeAll,
                  dialog.cancel,
                  dialog.next,
                ].filter((element) => element instanceof HTMLElement && !element.disabled);
                if (!focusable.length) {
                  return;
                }
                const currentIndex = focusable.indexOf(document.activeElement);
                if (event.shiftKey) {
                  const previousIndex = currentIndex <= 0 ? focusable.length - 1 : currentIndex - 1;
                  focusable[previousIndex].focus({ preventScroll: true });
                } else {
                  const nextIndex = currentIndex === focusable.length - 1 ? 0 : currentIndex + 1;
                  focusable[nextIndex].focus({ preventScroll: true });
                }
                event.preventDefault();
              }
            }

            async function handleConfirm(event) {
              event.preventDefault();
              if (busy) {
                return;
              }
              const lectureId = Number(dialog.lecture?.value || '');
              if (!Number.isFinite(lectureId) || lectureId <= 0) {
                setStatusMessage(t('tasks.bulkUpload.selectLecture'), 'error');
                dialog.lecture?.focus({ preventScroll: true });
                return;
              }
              const assetType = dialog.type?.value || '';
              if (!assetType) {
                setStatusMessage(t('tasks.bulkUpload.selectType'), 'error');
                dialog.type?.focus({ preventScroll: true });
                return;
              }
              const definition = availableDefinitions.find((item) => item.type === assetType);
              if (!definition) {
                setStatusMessage(t('tasks.bulkUpload.noTypes'), 'error');
                return;
              }

              const displayName = file?.name || t('tasks.bulkUpload.title');
              setBusyState(true);
              setStatusMessage(t('tasks.bulkUpload.uploading', { name: displayName }), 'info');

              try {
                await uploadLectureAssetWithProgress(lectureId, definition, file, (ratio) => {
                  const percentage = Math.max(0, Math.min(100, Math.round(ratio * 100)));
                  setStatusMessage(
                    `${t('tasks.bulkUpload.uploading', { name: displayName })} (${percentage}%)`,
                    'info',
                  );
                });
                cleanup({ action: 'uploaded', lectureId, assetType: definition.type });
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                const fallback = t('tasks.bulkUpload.failure', { name: displayName });
                setStatusMessage(message || fallback, 'error');
                setBusyState(false);
              }
            }

            if (dialog.title) {
              dialog.title.textContent = t('tasks.bulkUpload.title');
            }
            if (dialog.subtitle) {
              dialog.subtitle.textContent = t('tasks.bulkUpload.fileProgress', {
                current: currentNumber,
                total,
              });
            }
            if (dialog.fileName) {
              dialog.fileName.textContent = file?.name || t('tasks.bulkUpload.title');
            }
            if (dialog.fileSize) {
              dialog.fileSize.textContent =
                typeof file?.size === 'number' && !Number.isNaN(file.size)
                  ? formatBytes(file.size)
                  : '';
            }
            if (dialog.lectureLabel) {
              dialog.lectureLabel.textContent = t('tasks.bulkUpload.lectureLabel');
            }
            if (dialog.typeLabel) {
              dialog.typeLabel.textContent = t('tasks.bulkUpload.typeLabel');
            }

            if (dialog.lecture) {
              dialog.lecture.innerHTML = '';
              const lecturePlaceholder = document.createElement('option');
              lecturePlaceholder.value = '';
              lecturePlaceholder.disabled = true;
              lecturePlaceholder.textContent = t('tasks.bulkUpload.selectLecture');
              dialog.lecture.appendChild(lecturePlaceholder);

              lectures.forEach((item) => {
                if (!item || !Number.isFinite(Number(item.id))) {
                  return;
                }
                const option = document.createElement('option');
                option.value = String(item.id);
                option.textContent = formatLectureOptionLabel(item);
                dialog.lecture.appendChild(option);
              });

              if (defaultLectureId && lectures.some((item) => Number(item.id) === defaultLectureId)) {
                dialog.lecture.value = String(defaultLectureId);
                lecturePlaceholder.selected = false;
              } else {
                lecturePlaceholder.selected = true;
              }
            }

            if (dialog.type) {
              dialog.type.innerHTML = '';
              const typePlaceholder = document.createElement('option');
              typePlaceholder.value = '';
              typePlaceholder.disabled = true;
              typePlaceholder.textContent = t('tasks.bulkUpload.selectType');
              dialog.type.appendChild(typePlaceholder);

              availableDefinitions.forEach((definition) => {
                if (!definition) {
                  return;
                }
                const option = document.createElement('option');
                option.value = definition.type;
                option.textContent = t(definition.labelKey);
                dialog.type.appendChild(option);
              });

              if (defaultType && availableDefinitions.some((definition) => definition.type === defaultType)) {
                dialog.type.value = defaultType;
                typePlaceholder.selected = false;
              } else {
                typePlaceholder.selected = true;
              }
            }

            if (dialog.dispose) {
              dialog.dispose.textContent = t('tasks.bulkUpload.skip');
              dialog.dispose.disabled = false;
              dialog.dispose.addEventListener('click', handleDispose);
            }
            if (dialog.disposeAll) {
              dialog.disposeAll.textContent = t('tasks.bulkUpload.skipAll');
              dialog.disposeAll.disabled = false;
              dialog.disposeAll.addEventListener('click', handleDisposeAll);
            }
            if (dialog.cancel) {
              dialog.cancel.textContent = t('tasks.bulkUpload.cancel');
              dialog.cancel.disabled = false;
              dialog.cancel.addEventListener('click', handleCancel);
            }
            if (dialog.next) {
              dialog.next.textContent = isLast
                ? t('tasks.bulkUpload.complete')
                : t('tasks.bulkUpload.next');
              dialog.next.disabled = false;
              dialog.next.addEventListener('click', handleConfirm);
            }
            if (dialog.backdrop) {
              dialog.backdrop.addEventListener('click', handleCancel);
            }
            if (dialog.window) {
              dialog.window.addEventListener('keydown', handleKeyDown);
            }

            dialog.root.classList.remove('hidden');
            dialog.root.setAttribute('aria-hidden', 'false');
            document.body.classList.add('dialog-open');
            setStatusMessage('', '');
            setBusyState(false);

            const initialFocusTarget = (() => {
              if (dialog.lecture && dialog.lecture.value) {
                if (dialog.type && dialog.type.value) {
                  return dialog.next;
                }
                return dialog.type;
              }
              return dialog.lecture;
            })();

            window.requestAnimationFrame(() => {
              if (initialFocusTarget instanceof HTMLElement) {
                initialFocusTarget.focus({ preventScroll: true });
              }
            });
          });
        }

        async function startBulkUploadQueue(files) {
          if (
            dialogState.bulkUploadActive ||
            dialogState.uploadActive ||
            dialogState.bulkDownloadActive
          ) {
            return;
          }
          const queue = Array.isArray(files)
            ? files.filter((file) => file && typeof file.name === 'string')
            : [];
          if (!queue.length) {
            return;
          }

          const lectures = getLectureOptionList();
          if (!lectures.length) {
            showStatus(t('tasks.bulkUpload.noLectures'), 'info');
            return;
          }
          if (!uploadableAssetDefinitions.length) {
            showStatus(t('tasks.bulkUpload.noTypes'), 'error');
            return;
          }

          let uploaded = 0;
          let skipped = 0;
          let abort = false;

          for (let index = 0; index < queue.length; index += 1) {
            if (abort) {
              break;
            }
            const file = queue[index];
            if (!file) {
              continue;
            }
            const lectureOptions = getLectureOptionList();
            if (!lectureOptions.length) {
              showStatus(t('tasks.bulkUpload.noLectures'), 'info');
              break;
            }

            const guessedType = guessBulkAssetType(file) || state.bulkUpload.lastType;
            const stepResult = await showBulkUploadStep({
              file,
              index,
              total: queue.length,
              lectures: lectureOptions,
              defaultLectureId: state.bulkUpload.lastLectureId,
              defaultType: guessedType,
            });

            if (!stepResult) {
              break;
            }

            if (stepResult.action === 'uploaded') {
              uploaded += 1;
              if (Number.isFinite(Number(stepResult.lectureId))) {
                state.bulkUpload.lastLectureId = Number(stepResult.lectureId);
              }
              if (typeof stepResult.assetType === 'string' && stepResult.assetType) {
                state.bulkUpload.lastType = stepResult.assetType;
              }
              const successMessage = t('tasks.bulkUpload.success', { name: file.name });
              showStatus(successMessage, 'success');
            } else if (stepResult.action === 'dispose') {
              skipped += 1;
              showStatus(t('tasks.bulkUpload.disposed', { name: file.name }), 'info');
            } else if (stepResult.action === 'dispose_all') {
              skipped += queue.length - index;
              abort = true;
            } else if (stepResult.action === 'cancel') {
              abort = true;
            }
          }

          if (uploaded > 0) {
            await refreshData();
          }

          if (uploaded > 0 || skipped > 0) {
            const summary = t('tasks.bulkUpload.finished', { uploaded, skipped });
            const variant = uploaded > 0 ? 'success' : 'info';
            showStatus(summary, variant);
          }
        }

        async function handleBulkUploadInput(event) {
          const input = event?.target;
          const files = input?.files ? Array.from(input.files) : [];
          if (input) {
            input.value = '';
          }
          if (!files.length) {
            return;
          }
          await startBulkUploadQueue(files);
        }

        function updateModuleOptions() {
          const modules = [];
          state.classes.forEach((klass) => {
            (klass.modules || []).forEach((module) => {
              modules.push({
                id: module.id,
                label: `${klass.name}  ${module.name}`,
              });
            });
          });
          modules.sort((a, b) => a.label.localeCompare(b.label));

          dom.createModule.innerHTML = '';
          dom.editModule.innerHTML = '';

          const createPlaceholder = document.createElement('option');
          createPlaceholder.value = '';
          createPlaceholder.textContent = modules.length
            ? t('dropdowns.selectModule')
            : t('dropdowns.noModules');
          createPlaceholder.disabled = modules.length === 0;
          createPlaceholder.selected = true;
          dom.createModule.appendChild(createPlaceholder);

          modules.forEach((module) => {
            const option = document.createElement('option');
            option.value = String(module.id);
            option.textContent = module.label;
            dom.createModule.appendChild(option.cloneNode(true));
            dom.editModule.appendChild(option);
          });

          dom.createModule.disabled = modules.length === 0;
          dom.createSubmit.disabled = modules.length === 0;
        }

        function matchQuery(text, query) {
          return typeof text === 'string' && text.toLowerCase().includes(query);
        }

        function computeFilteredClasses() {
          const query = state.query.trim().toLowerCase();
          if (!query) {
            return state.classes.map((klass) => ({
              class: klass,
              modules: (klass.modules || []).map((module) => ({
                module,
                lectures: module.lectures || [],
              })),
            }));
          }

          const filtered = [];
          state.classes.forEach((klass) => {
            const classMatch = matchQuery(klass.name, query) || matchQuery(klass.description, query);
            const modules = [];
            (klass.modules || []).forEach((module) => {
              const moduleMatch =
                classMatch || matchQuery(module.name, query) || matchQuery(module.description, query);
              let lectures = module.lectures || [];
              if (!moduleMatch) {
                lectures = (module.lectures || []).filter(
                  (lecture) =>
                    matchQuery(lecture.name, query) || matchQuery(lecture.description, query),
                );
              }
              if (moduleMatch && lectures.length === 0) {
                lectures = module.lectures || [];
              }
              if (lectures.length > 0) {
                modules.push({ module, lectures });
              }
            });
            if (modules.length > 0) {
              filtered.push({ class: klass, modules });
            }
          });
          return filtered;
        }

        function highlightSelected() {
          state.buttonMap.forEach((button, lectureId) => {
            if (lectureId === state.selectedLectureId) {
              button.classList.add('active');
              button.setAttribute('aria-current', 'true');
            } else {
              button.classList.remove('active');
              button.removeAttribute('aria-current');
            }
          });
        }

        function findModuleEntry(moduleId) {
          for (const classEntry of state.classes) {
            const modules = classEntry.modules || [];
            for (const moduleEntry of modules) {
              if (moduleEntry && moduleEntry.id === moduleId) {
                if (!Array.isArray(moduleEntry.lectures)) {
                  moduleEntry.lectures = [];
                }
                return { classEntry, moduleEntry };
              }
            }
          }
          return null;
        }

        function findLectureLocation(lectureId) {
          for (const classEntry of state.classes) {
            const modules = classEntry.modules || [];
            for (const moduleEntry of modules) {
              const lectures = moduleEntry.lectures || [];
              for (let index = 0; index < lectures.length; index += 1) {
                if (lectures[index].id === lectureId) {
                  return { classEntry, moduleEntry, index };
                }
              }
            }
          }
          return null;
        }

        function ensureLectureExpansion(lectureId) {
          if (!lectureId) {
            return false;
          }
          const location = findLectureLocation(lectureId);
          if (!location) {
            return false;
          }
          let changed = false;
          const classId = location.classEntry?.id != null ? String(location.classEntry.id) : null;
          if (classId) {
            if (state.expandedClasses.get(classId) !== true) {
              state.expandedClasses.set(classId, true);
              changed = true;
            }
          }
          const moduleId = location.moduleEntry?.id != null ? String(location.moduleEntry.id) : null;
          if (classId && moduleId) {
            const moduleKey = `${classId}:${moduleId}`;
            if (state.expandedModules.get(moduleKey) !== true) {
              state.expandedModules.set(moduleKey, true);
              changed = true;
            }
          }
          return changed;
        }

        function clearDragIndicators() {
          if (!dom.curriculum) {
            return;
          }
          dom.curriculum
            .querySelectorAll('.drop-before, .drop-after')
            .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          dom.curriculum
            .querySelectorAll('.syllabus-lectures.drop-target')
            .forEach((element) => element.classList.remove('drop-target'));
        }

        function createIconButton(label, icon, ...classNames) {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = ['icon-button', ...classNames.filter(Boolean)].join(' ');
          button.setAttribute('aria-label', label);
          button.title = label;

          const iconSpan = document.createElement('span');
          iconSpan.className = 'icon';
          iconSpan.setAttribute('aria-hidden', 'true');
          iconSpan.textContent = icon;
          button.appendChild(iconSpan);

          const srLabel = document.createElement('span');
          srLabel.className = 'sr-only';
          srLabel.textContent = label;
          button.appendChild(srLabel);

          return button;
        }

        function calculateLectureDropPosition(container, moduleId, pointerY) {
          const moduleInfo = findModuleEntry(moduleId);
          if (!moduleInfo) {
            return { index: null, indicator: null, position: null };
          }

          const lectures = moduleInfo.moduleEntry.lectures || [];
          let index = lectures.length;
          let indicator = null;
          let position = null;

          for (let lectureIndex = 0; lectureIndex < lectures.length; lectureIndex += 1) {
            const lecture = lectures[lectureIndex];
            if (!lecture || lecture.id === state.draggingLectureId) {
              continue;
            }

            const element = container.querySelector(
              `.syllabus-lecture[data-lecture-id="${lecture.id}"]`,
            );
            if (!element) {
              continue;
            }

            const rect = element.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            if (typeof pointerY === 'number' && Number.isFinite(pointerY) && pointerY < midpoint) {
              index = lectureIndex;
              indicator = element;
              position = 'before';
              return { index, indicator, position };
            }

            index = lectureIndex + 1;
            indicator = element;
            position = 'after';
          }

          return { index, indicator: indicator ?? null, position };
        }

        function startLectureDrag(event, lecture, moduleId) {
          if (!state.editMode) {
            event.preventDefault();
            return;
          }
          state.draggingLectureId = lecture.id;
          state.draggingSourceModuleId = moduleId;
          state.draggedElement = event.currentTarget || null;
          if (event.dataTransfer) {
            event.dataTransfer.effectAllowed = 'move';
            try {
              event.dataTransfer.setData('text/plain', String(lecture.id));
            } catch (error) {
              // Ignore data transfer errors in unsupported browsers.
            }
          }
          if (state.draggedElement) {
            state.draggedElement.classList.add('dragging');
          }
        }

        function clearLectureDrag(event) {
          const element = (event && event.currentTarget) || state.draggedElement;
          if (element) {
            element.classList.remove('dragging');
          }
          state.draggingLectureId = null;
          state.draggingSourceModuleId = null;
          state.draggedElement = null;
          clearDragIndicators();
        }

        function handleLectureDragOver(event) {
          if (!state.editMode || !state.draggingLectureId) {
            return;
          }
          event.preventDefault();
          if (event.dataTransfer) {
            event.dataTransfer.dropEffect = 'move';
          }
          const container = event.currentTarget;
          if (!container || !container.classList) {
            return;
          }
          container.classList.add('drop-target');
          container
            .querySelectorAll('.drop-before, .drop-after')
            .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          const moduleId = Number(container.dataset.moduleId);
          if (!Number.isFinite(moduleId)) {
            return;
          }
          const { indicator, position } = calculateLectureDropPosition(
            container,
            moduleId,
            event.clientY,
          );
          if (!indicator || !position) {
            return;
          }
          indicator.classList.add(position === 'before' ? 'drop-before' : 'drop-after');
        }

        function handleLectureDragLeave(event) {
          const container = event.currentTarget;
          if (!container) {
            return;
          }
          const related = event.relatedTarget;
          if (!related || (!container.contains(related) && related !== container)) {
            container.classList.remove('drop-target');
            container
              .querySelectorAll('.drop-before, .drop-after')
              .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          }
        }

        async function handleLectureDrop(event, targetModuleId) {
          if (!state.editMode || !state.draggingLectureId) {
            return;
          }
          event.preventDefault();
          const container = event.currentTarget;
          if (container) {
            container.classList.remove('drop-target');
            container
              .querySelectorAll('.drop-before, .drop-after')
              .forEach((element) => element.classList.remove('drop-before', 'drop-after'));
          }
          let targetIndex = null;
          if (container) {
            const { index } = calculateLectureDropPosition(container, targetModuleId, event.clientY);
            if (typeof index === 'number' && Number.isFinite(index)) {
              targetIndex = index;
            }
          }
          await performLectureReorder(state.draggingLectureId, targetModuleId, targetIndex);
        }

        async function performLectureReorder(lectureId, targetModuleId, targetIndex) {
          const sourceInfo = findLectureLocation(lectureId);
          const targetInfo = findModuleEntry(targetModuleId);
          if (!sourceInfo || !targetInfo) {
            clearDragIndicators();
            return;
          }

          const sourceModuleId = sourceInfo.moduleEntry.id;
          if (!Array.isArray(sourceInfo.moduleEntry.lectures)) {
            sourceInfo.moduleEntry.lectures = [];
          }
          if (!Array.isArray(targetInfo.moduleEntry.lectures)) {
            targetInfo.moduleEntry.lectures = [];
          }
          const sourceLectures = sourceInfo.moduleEntry.lectures;
          const targetLectures = targetInfo.moduleEntry.lectures;

          let insertionIndex =
            typeof targetIndex === 'number' && Number.isFinite(targetIndex)
              ? targetIndex
              : targetLectures.length;

          if (sourceModuleId === targetModuleId) {
            if (insertionIndex > sourceInfo.index) {
              insertionIndex -= 1;
            }
            if (insertionIndex === sourceInfo.index) {
              clearDragIndicators();
              return;
            }
          }

          const lectureRecord = sourceLectures[sourceInfo.index];
          sourceLectures.splice(sourceInfo.index, 1);

          if (insertionIndex < 0 || insertionIndex > targetLectures.length) {
            insertionIndex = targetLectures.length;
          }

          lectureRecord.module_id = targetModuleId;
          targetLectures.splice(insertionIndex, 0, lectureRecord);

          if (state.draggedElement) {
            state.draggedElement.classList.remove('dragging');
          }

          const modulesToUpdate = new Map();
          modulesToUpdate.set(sourceModuleId, sourceInfo.moduleEntry);
          modulesToUpdate.set(targetModuleId, targetInfo.moduleEntry);

          sourceInfo.moduleEntry.lecture_count = sourceLectures.length;
          targetInfo.moduleEntry.lecture_count = targetLectures.length;

          state.draggingLectureId = null;
          state.draggingSourceModuleId = null;
          state.draggedElement = null;

          renderCurriculum();

          const payload = {
            modules: Array.from(modulesToUpdate.values()).map((moduleEntry) => ({
              module_id: moduleEntry.id,
              lecture_ids: (moduleEntry.lectures || []).map((item) => item.id),
            })),
          };

          try {
            await request('/api/lectures/reorder', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            await refreshData();
            showStatus(t('status.lectureReordered'), 'success');
          } catch (error) {
            showStatus(error.message, 'error');
            await refreshData();
          }
        }

        function normalizeIdentifier(value) {
          if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
            return value;
          }
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (/^\d+$/.test(trimmed)) {
              const parsed = Number.parseInt(trimmed, 10);
              if (Number.isFinite(parsed) && parsed > 0) {
                return parsed;
              }
            }
          }
          return null;
        }

        function createCurriculumEditorIdMap() {
          return {
            class: new Map(),
            module: new Map(),
            lecture: new Map(),
          };
        }

        function resolveCurriculumEditorIdentifier(type, identifier) {
          if (identifier === null) {
            return null;
          }
          const map = state.curriculumEditorIdMap?.[type];
          if (map instanceof Map && map.has(identifier)) {
            return map.get(identifier);
          }
          return null;
        }

        function createIdTag(identifier) {
          const value = normalizeIdentifier(identifier);
          if (value === null) {
            return null;
          }
          const tag = document.createElement('span');
          tag.className = 'syllabus-id-tag';
          tag.textContent = `[${value}]`;
          return tag;
        }

        function formatCurriculumLine(type, id, name) {
          const identifier = normalizeIdentifier(id);
          const normalizedName = typeof name === 'string' ? name.trim() : String(name ?? '').trim();
          const prefix = type === 'module' ? '-' : type === 'lecture' ? '--' : '';
          const segments = [];
          if (identifier !== null) {
            segments.push(`[${identifier}]`);
          }
          if (prefix) {
            segments.push(prefix);
          }
          if (normalizedName) {
            segments.push(normalizedName);
          }
          return segments.join(' ').trim();
        }

        function buildCurriculumEditorText() {
          const lines = [];
          const idMap = createCurriculumEditorIdMap();
          let nextIdentifier = 1;

          const getNextIdentifier = () => {
            const current = nextIdentifier;
            nextIdentifier += 1;
            return current;
          };

          state.classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const classIdentifier = getNextIdentifier();
            idMap.class.set(classIdentifier, normalizeIdentifier(klass.id));
            lines.push(formatCurriculumLine('class', classIdentifier, klass.name));
            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            modules.forEach((module) => {
              if (!module || typeof module !== 'object') {
                return;
              }
              const moduleIdentifier = getNextIdentifier();
              idMap.module.set(moduleIdentifier, normalizeIdentifier(module.id));
              lines.push(formatCurriculumLine('module', moduleIdentifier, module.name));
              const lectures = Array.isArray(module.lectures) ? module.lectures : [];
              lectures.forEach((lecture) => {
                if (!lecture || typeof lecture !== 'object') {
                  return;
                }
                const lectureIdentifier = getNextIdentifier();
                idMap.lecture.set(lectureIdentifier, normalizeIdentifier(lecture.id));
                lines.push(formatCurriculumLine('lecture', lectureIdentifier, lecture.name));
              });
            });
          });
          state.curriculumEditorIdMap = idMap;
          return lines.join('\n');
        }

        function ensureCurriculumEditorElement() {
          if (!dom.curriculumEditor) {
            const textarea = document.createElement('textarea');
            textarea.id = 'curriculum-editor';
            textarea.className = 'curriculum-editor-textarea';
            textarea.setAttribute('spellcheck', 'false');
            textarea.setAttribute('autocapitalize', 'none');
            textarea.autocomplete = 'off';
            textarea.addEventListener('input', () => {
              textarea.dataset.dirty = 'true';
            });
            dom.curriculumEditor = textarea;
          }
          const editor = dom.curriculumEditor;
          editor.setAttribute('aria-label', t('curriculum.editorHeading'));
          if (!editor.dataset.bound) {
            editor.addEventListener('input', () => {
              editor.dataset.dirty = 'true';
            });
            editor.dataset.bound = 'true';
          }
          return editor;
        }

        function renderCurriculumEditor() {
          const host = dom.curriculumEditorHost;
          if (!host) {
            return;
          }

          if (!state.editMode) {
            host.hidden = true;
            host.innerHTML = '';
            return;
          }

          host.hidden = false;
          host.innerHTML = '';

          const container = document.createElement('div');
          container.className = 'curriculum-editor';

          const header = document.createElement('div');
          header.className = 'curriculum-editor-header';

          const heading = document.createElement('h3');
          heading.textContent = t('curriculum.editorHeading');
          header.appendChild(heading);

          const hint = document.createElement('p');
          hint.textContent = t('curriculum.editorHint');
          header.appendChild(hint);

          container.appendChild(header);

          const editor = ensureCurriculumEditorElement();
          if (editor.dataset.dirty !== 'true') {
            editor.value = buildCurriculumEditorText();
            editor.dataset.dirty = 'false';
          }
          container.appendChild(editor);

          host.appendChild(container);
        }

        function normalizeCurriculumName(value) {
          if (typeof value === 'string') {
            return value.trim().toLowerCase();
          }
          if (value == null) {
            return '';
          }
          return String(value).trim().toLowerCase();
        }

        function toFiniteNumber(value) {
          if (typeof value === 'number' && Number.isFinite(value)) {
            return value;
          }
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (!trimmed) {
              return null;
            }
            const parsed = Number(trimmed);
            if (Number.isFinite(parsed)) {
              return parsed;
            }
          }
          return null;
        }

        function createTemporaryLectureName(baseName) {
          const fallbackName = 'lecture';
          const normalized =
            typeof baseName === 'string' && baseName.trim().length > 0
              ? baseName.trim()
              : fallbackName;
          const truncated = normalized.length > 40 ? normalized.slice(0, 40) : normalized;
          const suffix = `${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`;
          return `${truncated} (temp ${suffix})`;
        }

        function buildExistingNameIndexes() {
          const classNames = new Map();
          const moduleNames = new Map();
          const lectureNames = new Map();

          state.classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const classId = Number(klass.id);
            const classKey = normalizeCurriculumName(klass.name);
            if (Number.isFinite(classId) && classKey) {
              if (!classNames.has(classKey)) {
                classNames.set(classKey, []);
              }
              classNames.get(classKey).push({ id: classId });
            }
            if (!Number.isFinite(classId)) {
              return;
            }
            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            modules.forEach((module) => {
              if (!module || typeof module !== 'object') {
                return;
              }
              const moduleId = Number(module.id);
              const moduleKey = normalizeCurriculumName(module.name);
              if (!Number.isFinite(moduleId) || !moduleKey) {
                return;
              }
              if (!moduleNames.has(classId)) {
                moduleNames.set(classId, new Map());
              }
              const moduleMap = moduleNames.get(classId);
              if (!moduleMap.has(moduleKey)) {
                moduleMap.set(moduleKey, []);
              }
              moduleMap.get(moduleKey).push({ id: moduleId });

              const lectures = Array.isArray(module.lectures) ? module.lectures : [];
              lectures.forEach((lecture) => {
                if (!lecture || typeof lecture !== 'object') {
                  return;
                }
                const lectureId = Number(lecture.id);
                const lectureKey = normalizeCurriculumName(lecture.name);
                if (!Number.isFinite(lectureId) || !lectureKey) {
                  return;
                }
                if (!lectureNames.has(moduleId)) {
                  lectureNames.set(moduleId, new Map());
                }
                const lectureMap = lectureNames.get(moduleId);
                if (!lectureMap.has(lectureKey)) {
                  lectureMap.set(lectureKey, []);
                }
                lectureMap.get(lectureKey).push({ id: lectureId });
              });
            });
          });

          return { classNames, moduleNames, lectureNames };
        }

        function selectUniqueAvailableCandidate(candidates, usedSet) {
          if (!Array.isArray(candidates) || candidates.length === 0) {
            return null;
          }
          const available = candidates.filter((candidate) =>
            Number.isFinite(candidate?.id) && !usedSet.has(candidate.id),
          );
          if (available.length === 1) {
            return available[0];
          }
          return null;
        }

        function assignCurriculumIdentifiersByName(parsedClasses) {
          if (!Array.isArray(parsedClasses) || parsedClasses.length === 0) {
            return;
          }
          const indexes = buildExistingNameIndexes();
          const matchedClasses = new Set();

          parsedClasses.forEach((classNode) => {
            if (!classNode || typeof classNode !== 'object') {
              return;
            }
            const classId = Number(classNode.id);
            if (Number.isFinite(classId)) {
              matchedClasses.add(classId);
            } else {
              const key = normalizeCurriculumName(classNode.name);
              const candidates = key ? indexes.classNames.get(key) : null;
              const match = candidates ? selectUniqueAvailableCandidate(candidates, matchedClasses) : null;
              if (match) {
                classNode.id = match.id;
                matchedClasses.add(match.id);
              }
            }

            const resolvedClassId = Number(classNode.id);
            const moduleMap = Number.isFinite(resolvedClassId)
              ? indexes.moduleNames.get(resolvedClassId)
              : null;
            const matchedModules = new Set();
            const modules = Array.isArray(classNode.modules) ? classNode.modules : [];
            modules.forEach((moduleNode) => {
              if (!moduleNode || typeof moduleNode !== 'object') {
                return;
              }
              const moduleId = Number(moduleNode.id);
              if (Number.isFinite(moduleId)) {
                matchedModules.add(moduleId);
              } else if (moduleMap instanceof Map) {
                const key = normalizeCurriculumName(moduleNode.name);
                const candidates = key ? moduleMap.get(key) : null;
                const match = candidates
                  ? selectUniqueAvailableCandidate(candidates, matchedModules)
                  : null;
                if (match) {
                  moduleNode.id = match.id;
                  matchedModules.add(match.id);
                }
              }

              const resolvedModuleId = Number(moduleNode.id);
              const lectureMap = Number.isFinite(resolvedModuleId)
                ? indexes.lectureNames.get(resolvedModuleId)
                : null;
              const matchedLectures = new Set();
              const lectures = Array.isArray(moduleNode.lectures) ? moduleNode.lectures : [];
              lectures.forEach((lectureNode) => {
                if (!lectureNode || typeof lectureNode !== 'object') {
                  return;
                }
                const lectureId = Number(lectureNode.id);
                if (Number.isFinite(lectureId)) {
                  matchedLectures.add(lectureId);
                  return;
                }
                if (!(lectureMap instanceof Map)) {
                  return;
                }
                const key = normalizeCurriculumName(lectureNode.name);
                const candidates = key ? lectureMap.get(key) : null;
                const match = candidates
                  ? selectUniqueAvailableCandidate(candidates, matchedLectures)
                  : null;
                if (match) {
                  lectureNode.id = match.id;
                  matchedLectures.add(match.id);
                }
              });
            });
          });
        }

        function parseCurriculumEditorValue(value) {
          const text = typeof value === 'string' ? value : String(value ?? '');
          const lines = text.split(/\r?\n/);
          const classes = [];
          const errors = [];

          let currentClass = null;
          let currentModule = null;

          const seenDisplayIds = {
            class: new Set(),
            module: new Set(),
            lecture: new Set(),
          };

          const seenResolvedIds = {
            class: new Set(),
            module: new Set(),
            lecture: new Set(),
          };

          const duplicateKeys = {
            class: 'duplicateClass',
            module: 'duplicateModule',
            lecture: 'duplicateLecture',
          };

          const lineError = (lineNumber, key, params = {}) =>
            t('curriculum.editorLineError', {
              line: lineNumber,
              message: t(`curriculum.editorErrors.${key}`, params),
            });

          for (let index = 0; index < lines.length; index += 1) {
            const rawLine = lines[index] ?? '';
            const trimmedLine = rawLine.trim();
            if (!trimmedLine) {
              continue;
            }

            let working = trimmedLine;
            let identifier = null;
            const idMatch = working.match(/^\[(\d+)\]\s*/);
            if (idMatch) {
              identifier = Number(idMatch[1]);
              working = working.slice(idMatch[0].length);
            }

            let type = 'class';
            if (working.startsWith('--')) {
              type = 'lecture';
              working = working.slice(2).trim();
            } else if (working.startsWith('-')) {
              type = 'module';
              working = working.slice(1).trim();
            } else {
              working = working.trim();
            }

            const name = working.trim();
            const lineNumber = index + 1;
            const duplicateKey = duplicateKeys[type];
            const resolvedId = resolveCurriculumEditorIdentifier(type, identifier);
            const displaySet = seenDisplayIds[type];
            const resolvedSet = seenResolvedIds[type];

            if (!name) {
              errors.push(lineError(lineNumber, 'nameRequired'));
              continue;
            }

            if (type === 'class') {
              if (identifier !== null) {
                if (displaySet.has(identifier)) {
                  errors.push(lineError(lineNumber, duplicateKey, { id: identifier }));
                  continue;
                }
                displaySet.add(identifier);
              }
              if (resolvedId !== null) {
                if (resolvedSet.has(resolvedId)) {
                  errors.push(lineError(lineNumber, duplicateKey, { id: resolvedId }));
                  continue;
                }
                resolvedSet.add(resolvedId);
              }
              const classNode = { id: resolvedId, name, line: lineNumber, modules: [] };
              classes.push(classNode);
              currentClass = classNode;
              currentModule = null;
            } else if (type === 'module') {
              if (!currentClass) {
                errors.push(lineError(lineNumber, 'missingClass'));
                continue;
              }
              if (identifier !== null) {
                if (displaySet.has(identifier)) {
                  errors.push(lineError(lineNumber, duplicateKey, { id: identifier }));
                  continue;
                }
                displaySet.add(identifier);
              }
              if (resolvedId !== null) {
                if (resolvedSet.has(resolvedId)) {
                  errors.push(lineError(lineNumber, duplicateKey, { id: resolvedId }));
                  continue;
                }
                resolvedSet.add(resolvedId);
              }
              const moduleNode = { id: resolvedId, name, line: lineNumber, lectures: [] };
              currentClass.modules.push(moduleNode);
              currentModule = moduleNode;
            } else {
              if (!currentModule) {
                errors.push(lineError(lineNumber, 'missingModule'));
                continue;
              }
              if (identifier !== null) {
                if (displaySet.has(identifier)) {
                  errors.push(lineError(lineNumber, duplicateKey, { id: identifier }));
                  continue;
                }
                displaySet.add(identifier);
              }
              if (resolvedId !== null) {
                if (resolvedSet.has(resolvedId)) {
                  errors.push(lineError(lineNumber, duplicateKey, { id: resolvedId }));
                  continue;
                }
                resolvedSet.add(resolvedId);
              }
              const lectureNode = { id: resolvedId, name, line: lineNumber };
              currentModule.lectures.push(lectureNode);
            }
          }

          return { classes, errors };
        }

        function getCurriculumMaps() {
          const classMap = new Map();
          const moduleMap = new Map();
          const lectureMap = new Map();

          state.classes.forEach((klass) => {
            if (!klass || typeof klass !== 'object') {
              return;
            }
            const classId = Number(klass.id);
            if (Number.isFinite(classId)) {
              classMap.set(classId, klass);
            }
            const modules = Array.isArray(klass.modules) ? klass.modules : [];
            modules.forEach((module) => {
              if (!module || typeof module !== 'object') {
                return;
              }
              const moduleId = Number(module.id);
              if (Number.isFinite(moduleId)) {
                moduleMap.set(moduleId, { module, classId: classId });
              }
              const lectures = Array.isArray(module.lectures) ? module.lectures : [];
              lectures.forEach((lecture) => {
                if (!lecture || typeof lecture !== 'object') {
                  return;
                }
                const lectureId = Number(lecture.id);
                if (Number.isFinite(lectureId)) {
                  lectureMap.set(lectureId, {
                    lecture,
                    moduleId: moduleId,
                    classId: classId,
                  });
                }
              });
            });
          });

          return { classMap, moduleMap, lectureMap };
        }

        function validateCurriculumStructure(parsedClasses) {
          const { classMap, moduleMap, lectureMap } = getCurriculumMaps();
          const errors = [];

          parsedClasses.forEach((classNode) => {
            if (classNode.id !== null && !classMap.has(classNode.id)) {
              errors.push(
                t('curriculum.editorLineError', {
                  line: classNode.line,
                  message: t('curriculum.editorErrors.unknownClass', { id: classNode.id }),
                }),
              );
            }
            classNode.modules.forEach((moduleNode) => {
              if (moduleNode.id !== null && !moduleMap.has(moduleNode.id)) {
                errors.push(
                  t('curriculum.editorLineError', {
                    line: moduleNode.line,
                    message: t('curriculum.editorErrors.unknownModule', { id: moduleNode.id }),
                  }),
                );
              }
              moduleNode.lectures.forEach((lectureNode) => {
                if (lectureNode.id !== null && !lectureMap.has(lectureNode.id)) {
                  errors.push(
                    t('curriculum.editorLineError', {
                      line: lectureNode.line,
                      message: t('curriculum.editorErrors.unknownLecture', {
                        id: lectureNode.id,
                      }),
                    }),
                  );
                }
              });
            });
          });

          return { errors, maps: { classMap, moduleMap, lectureMap } };
        }

        async function applyCurriculumChanges(parsedClasses, existingMaps) {
          const maps = existingMaps ?? getCurriculumMaps();
          const classMap = maps.classMap;
          const moduleMap = maps.moduleMap;
          const lectureMap = maps.lectureMap;

          const lectureNameState = new Map();
          lectureMap.forEach((info, lectureId) => {
            if (!info || typeof info !== 'object') {
              return;
            }
            const moduleId = toFiniteNumber(info.moduleId);
            const lectureName = info.lecture?.name;
            if (moduleId == null || typeof lectureName !== 'string' || !lectureName) {
              return;
            }
            if (!lectureNameState.has(moduleId)) {
              lectureNameState.set(moduleId, new Map());
            }
            lectureNameState.get(moduleId).set(lectureName, lectureId);
          });

          const lectureChangePlan = new Map();
          parsedClasses.forEach((classNode) => {
            if (!classNode || typeof classNode !== 'object') {
              return;
            }
            const modules = Array.isArray(classNode.modules) ? classNode.modules : [];
            modules.forEach((moduleNode) => {
              if (!moduleNode || typeof moduleNode !== 'object') {
                return;
              }
              const targetModuleId = toFiniteNumber(moduleNode.id);
              const lectures = Array.isArray(moduleNode.lectures) ? moduleNode.lectures : [];
              lectures.forEach((lectureNode) => {
                if (!lectureNode || typeof lectureNode !== 'object') {
                  return;
                }
                const lectureId = toFiniteNumber(lectureNode.id);
                if (lectureId == null) {
                  return;
                }
                const existing = lectureMap.get(lectureId);
                const currentModuleId = toFiniteNumber(existing?.moduleId);
                const currentName = existing?.lecture?.name ?? '';
                const targetName = lectureNode.name;
                const moduleChanged = currentModuleId !== targetModuleId;
                const nameChanged = currentName !== targetName;
                lectureChangePlan.set(lectureId, {
                  moduleId: targetModuleId,
                  name: targetName,
                  willChange: moduleChanged || nameChanged,
                });
              });
            });
          });

          const removeLectureName = (moduleId, name, lectureId) => {
            if (moduleId == null || typeof name !== 'string' || !name) {
              return;
            }
            const map = lectureNameState.get(moduleId);
            if (map && map.get(name) === lectureId) {
              map.delete(name);
            }
          };

          const assignLectureName = (moduleId, name, lectureId) => {
            if (moduleId == null || typeof name !== 'string' || !name) {
              return;
            }
            let map = lectureNameState.get(moduleId);
            if (!map) {
              map = new Map();
              lectureNameState.set(moduleId, map);
            }
            map.set(name, lectureId);
          };

          const findLectureConflict = (moduleId, name, lectureId) => {
            if (moduleId == null || typeof name !== 'string' || !name) {
              return null;
            }
            const map = lectureNameState.get(moduleId);
            if (!map) {
              return null;
            }
            const conflictingId = map.get(name);
            if (!Number.isFinite(conflictingId) || conflictingId === lectureId) {
              return null;
            }
            return lectureMap.get(conflictingId) ?? null;
          };

          const lectureIsPlannedToChange = (lectureId) => {
            const plan = lectureChangePlan.get(lectureId);
            return Boolean(plan && plan.willChange);
          };

          const updateLectureNameState = (
            info,
            moduleId,
            name,
            previousModuleOverride,
            previousNameOverride,
          ) => {
            const existingId = toFiniteNumber(info?.lecture?.id);
            if (existingId == null) {
              return;
            }
            const previousModuleId =
              previousModuleOverride ?? toFiniteNumber(info?.moduleId);
            const previousName = previousNameOverride ?? info?.lecture?.name;
            removeLectureName(previousModuleId, previousName, existingId);
            assignLectureName(moduleId, name, existingId);
          };

          const ensureLectureNameAvailable = async (moduleId, lectureId, targetName) => {
            if (moduleId == null || typeof targetName !== 'string' || !targetName) {
              return;
            }
            const conflict = findLectureConflict(moduleId, targetName, lectureId);
            if (!conflict) {
              return;
            }
            const conflictingId = toFiniteNumber(conflict?.lecture?.id);
            if (conflictingId == null) {
              return;
            }
            if (!lectureIsPlannedToChange(conflictingId)) {
              throw new Error(t('status.curriculumSaveFailed'));
            }
            const placeholderName = createTemporaryLectureName(conflict?.lecture?.name);
            await request(`/api/lectures/${conflictingId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: placeholderName }),
            });
            updateLectureNameState(conflict, moduleId, placeholderName);
            if (conflict) {
              conflict.moduleId = moduleId;
              if (conflict.lecture) {
                conflict.lecture.name = placeholderName;
              }
            }
          };

          const parsedClassIds = new Set();
          const parsedModuleIds = new Set();
          const parsedLectureIds = new Set();

          parsedClasses.forEach((classNode) => {
            if (classNode.id !== null) {
              parsedClassIds.add(classNode.id);
            }
            classNode.modules.forEach((moduleNode) => {
              if (moduleNode.id !== null) {
                parsedModuleIds.add(moduleNode.id);
              }
              moduleNode.lectures.forEach((lectureNode) => {
                if (lectureNode.id !== null) {
                  parsedLectureIds.add(lectureNode.id);
                }
              });
            });
          });

          const classesToDelete = [];
          classMap.forEach((_, classId) => {
            if (!parsedClassIds.has(classId)) {
              classesToDelete.push(classId);
            }
          });

          const classesToDeleteSet = new Set(classesToDelete);
          const modulesToDelete = [];
          moduleMap.forEach((info, moduleId) => {
            if (!parsedModuleIds.has(moduleId) && !classesToDeleteSet.has(info.classId)) {
              modulesToDelete.push(moduleId);
            }
          });
          const modulesToDeleteSet = new Set(modulesToDelete);

          const lecturesToDelete = [];
          lectureMap.forEach((info, lectureId) => {
            if (
              !parsedLectureIds.has(lectureId) &&
              !modulesToDeleteSet.has(info.moduleId) &&
              !classesToDeleteSet.has(info.classId)
            ) {
              lecturesToDelete.push(lectureId);
            }
          });

          for (const lectureId of lecturesToDelete) {
            await request(`/api/lectures/${lectureId}`, { method: 'DELETE' });
            const removed = lectureMap.get(lectureId);
            if (removed) {
              const removedModuleId = toFiniteNumber(removed.moduleId);
              const removedName = removed.lecture?.name;
              removeLectureName(removedModuleId, removedName, lectureId);
              lectureMap.delete(lectureId);
            }
          }
          for (const moduleId of modulesToDelete) {
            await request(`/api/modules/${moduleId}`, { method: 'DELETE' });
            lectureNameState.delete(moduleId);
            moduleMap.delete(moduleId);
          }
          for (const classId of classesToDelete) {
            await request(`/api/classes/${classId}`, { method: 'DELETE' });
            classMap.delete(classId);
          }

          for (const classNode of parsedClasses) {
            if (classNode.id === null) {
              const payload = await request('/api/classes', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: classNode.name }),
              });
              const newId = payload?.class?.id;
              if (!Number.isFinite(newId)) {
                throw new Error(t('status.curriculumSaveFailed'));
              }
              classNode.id = Number(newId);
            } else {
              const existing = classMap.get(classNode.id);
              if (existing && existing.name !== classNode.name) {
                await request(`/api/classes/${classNode.id}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ name: classNode.name }),
                });
              }
            }
          }

          const moduleOrders = new Map();
          const lectureOrders = new Map();

          for (const classNode of parsedClasses) {
            const classId = classNode.id;
            if (!Number.isFinite(classId)) {
              throw new Error(t('status.curriculumSaveFailed'));
            }
            const moduleOrder = [];

            for (const moduleNode of classNode.modules) {
              if (moduleNode.id === null) {
                const payload = await request('/api/modules', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ class_id: classId, name: moduleNode.name }),
                });
                const newId = payload?.module?.id;
                if (!Number.isFinite(newId)) {
                  throw new Error(t('status.curriculumSaveFailed'));
                }
                moduleNode.id = Number(newId);
              } else {
                const existingModule = moduleMap.get(moduleNode.id);
                if (existingModule) {
                  const updates = {};
                  if (existingModule.module?.name !== moduleNode.name) {
                    updates.name = moduleNode.name;
                  }
                  if (existingModule.classId !== classId) {
                    updates.class_id = classId;
                  }
                  if (Object.keys(updates).length > 0) {
                    await request(`/api/modules/${moduleNode.id}`, {
                      method: 'PUT',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(updates),
                    });
                    if (Object.prototype.hasOwnProperty.call(updates, 'class_id')) {
                      existingModule.classId = classId;
                    }
                    if (existingModule.module) {
                      if (Object.prototype.hasOwnProperty.call(updates, 'name')) {
                        existingModule.module.name = moduleNode.name;
                      }
                      if (Object.prototype.hasOwnProperty.call(updates, 'class_id')) {
                        existingModule.module.class_id = classId;
                      }
                    }
                  }
                }
              }

              const moduleId = moduleNode.id;
              if (!Number.isFinite(moduleId)) {
                throw new Error(t('status.curriculumSaveFailed'));
              }
              moduleOrder.push(moduleId);

              const lectureOrder = [];
              for (const lectureNode of moduleNode.lectures) {
                if (lectureNode.id === null) {
                  const lectureName =
                    typeof lectureNode.name === 'string'
                      ? lectureNode.name
                      : String(lectureNode.name ?? '').trim();
                  if (lectureName) {
                    await ensureLectureNameAvailable(moduleId, null, lectureName);
                  }
                  const payload = await request('/api/lectures', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      module_id: moduleId,
                      name: lectureName,
                      description: '',
                    }),
                  });
                  const newId = payload?.lecture?.id;
                  if (!Number.isFinite(newId)) {
                    throw new Error(t('status.curriculumSaveFailed'));
                  }
                  lectureNode.id = Number(newId);
                  lectureMap.set(lectureNode.id, {
                    lecture: {
                      id: lectureNode.id,
                      name: lectureName,
                      module_id: moduleId,
                    },
                    moduleId: moduleId,
                    classId: classId,
                  });
                  assignLectureName(moduleId, lectureName, lectureNode.id);
                } else {
                  const existingLecture = lectureMap.get(lectureNode.id);
                  if (existingLecture) {
                    const updates = {};
                    const lectureId = Number(lectureNode.id);
                    const currentModuleId = toFiniteNumber(existingLecture.moduleId);
                    const currentName = existingLecture.lecture?.name ?? '';
                    const desiredName = lectureNode.name;
                    const requiresConflictCheck =
                      currentModuleId !== moduleId || currentName !== desiredName;
                    if (requiresConflictCheck) {
                      await ensureLectureNameAvailable(moduleId, lectureId, desiredName);
                    }
                    if (currentName !== desiredName) {
                      updates.name = lectureNode.name;
                    }
                    if (currentModuleId !== moduleId) {
                      updates.module_id = moduleId;
                    }
                    if (Object.keys(updates).length > 0) {
                      await request(`/api/lectures/${lectureNode.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updates),
                      });
                      if (Object.prototype.hasOwnProperty.call(updates, 'module_id')) {
                        existingLecture.moduleId = moduleId;
                      }
                      if (existingLecture.lecture) {
                        if (Object.prototype.hasOwnProperty.call(updates, 'name')) {
                          existingLecture.lecture.name = lectureNode.name;
                        }
                        if (Object.prototype.hasOwnProperty.call(updates, 'module_id')) {
                          existingLecture.lecture.module_id = moduleId;
                        }
                        if (
                          Object.prototype.hasOwnProperty.call(updates, 'name') ||
                          Object.prototype.hasOwnProperty.call(updates, 'module_id')
                        ) {
                          updateLectureNameState(
                            existingLecture,
                            moduleId,
                            lectureNode.name,
                            currentModuleId,
                            currentName,
                          );
                        }
                      }
                    }
                  }
                }
                if (!Number.isFinite(lectureNode.id)) {
                  throw new Error(t('status.curriculumSaveFailed'));
                }
                lectureOrder.push(lectureNode.id);
              }
              lectureOrders.set(moduleId, lectureOrder);
            }

            moduleOrders.set(classId, moduleOrder);
          }

          const classOrder = parsedClasses.map((classNode) => classNode.id);
          if (classOrder.length > 0) {
            await request('/api/classes/reorder', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ class_ids: classOrder }),
            });
          }

          const modulePayload = Array.from(moduleOrders.entries())
            .filter(([, modules]) => modules.length > 0)
            .map(([classId, modules]) => ({ class_id: classId, module_ids: modules }));
          if (modulePayload.length > 0) {
            await request('/api/modules/reorder', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ classes: modulePayload }),
            });
          }

          const lecturePayload = Array.from(lectureOrders.entries())
            .filter(([, lectures]) => lectures.length > 0)
            .map(([moduleId, lectures]) => ({ module_id: moduleId, lecture_ids: lectures }));
          if (lecturePayload.length > 0) {
            await request('/api/lectures/reorder', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ modules: lecturePayload }),
            });
          }
        }

        async function saveCurriculumFromEditor() {
          const editor = dom.curriculumEditor;
          const editorValue = editor ? editor.value : '';
          const parsed = parseCurriculumEditorValue(editorValue);
          if (parsed.errors.length > 0) {
            showStatus(parsed.errors[0], 'error');
            if (editor) {
              editor.focus();
            }
            return false;
          }

          assignCurriculumIdentifiersByName(parsed.classes);

          const validation = validateCurriculumStructure(parsed.classes);
          if (validation.errors.length > 0) {
            showStatus(validation.errors[0], 'error');
            if (editor) {
              editor.focus();
            }
            return false;
          }

          try {
            if (editor) {
              editor.dataset.dirty = 'false';
            }
            await applyCurriculumChanges(parsed.classes, validation.maps);
            await refreshData();
            showStatus(t('status.curriculumSaved'), 'success');
            return true;
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error ?? '');
            showStatus(message || t('status.curriculumSaveFailed'), 'error');
            return false;
          }
        }

        function renderCurriculum() {
          state.buttonMap.clear();
          dom.curriculum.innerHTML = '';

          const filtered = computeFilteredClasses();

          if (filtered.length === 0) {
            const message = document.createElement('div');
            message.className = 'placeholder';
            message.textContent = state.classes.length
              ? t('placeholders.noLecturesFilter')
              : t('placeholders.noClasses');
            dom.curriculum.appendChild(message);
            renderCurriculumEditor();
            return;
          }

          const syllabus = document.createElement('div');
          syllabus.className = 'syllabus';

          filtered.forEach((entry) => {
            const classDetails = document.createElement('details');
            classDetails.className = 'syllabus-class';
            const classId = entry.class?.id != null ? String(entry.class.id) : null;
            const hasSelection = entry.modules.some((moduleEntry) =>
              (moduleEntry.lectures || []).some(
                (lecture) => lecture.id === state.selectedLectureId,
              ),
            );
            let expandClass = Boolean(hasSelection);
            if (classId) {
              const storedValue = state.expandedClasses.get(classId);
              if (typeof storedValue === 'boolean') {
                expandClass = storedValue;
              }
              if (hasSelection) {
                expandClass = true;
                state.expandedClasses.set(classId, true);
              }
              classDetails.dataset.classId = classId;
              classDetails.addEventListener('toggle', () => {
                state.expandedClasses.set(classId, classDetails.open);
              });
            }
            classDetails.open = expandClass;

            const summary = document.createElement('summary');
            summary.className = 'syllabus-summary';

            const summaryText = document.createElement('div');
            summaryText.className = 'syllabus-summary-text';

            const classHeader = document.createElement('div');
            classHeader.className = 'syllabus-summary-header';

            const title = document.createElement('span');
            title.className = 'syllabus-title';
            title.textContent = entry.class.name;
            classHeader.appendChild(title);
            summaryText.appendChild(classHeader);

            const moduleCount = entry.modules.length;
            const lectureCount = entry.modules.reduce(
              (total, moduleEntry) => total + (moduleEntry.lectures?.length || 0),
              0,
            );
            const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            const meta = document.createElement('span');
            meta.className = 'syllabus-meta';
            meta.textContent = t('curriculum.classMeta', {
              moduleCount,
              moduleWord,
              lectureCount,
              lectureWord,
            });
            summaryText.appendChild(meta);

            summary.appendChild(summaryText);

            if (state.editMode) {
              const actions = document.createElement('div');
              actions.className = 'syllabus-actions';

              const addModuleButton = createIconButton(t('curriculum.addModule'), '+');
              addModuleButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                handleAddModule(entry.class);
              });
              actions.appendChild(addModuleButton);

              const deleteClassButton = createIconButton(t('common.actions.delete'), '', 'danger');
              deleteClassButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                handleDeleteClass(entry);
              });
              actions.appendChild(deleteClassButton);

              summary.appendChild(actions);
            }

            classDetails.appendChild(summary);

            const content = document.createElement('div');
            content.className = 'syllabus-content';

            if (!entry.modules.length) {
              const emptyModules = document.createElement('div');
              emptyModules.className = 'placeholder';
              emptyModules.textContent = t('placeholders.noModules');
              content.appendChild(emptyModules);
            } else {
              const modulesContainer = document.createElement('div');
              modulesContainer.className = 'syllabus-modules';

              entry.modules.forEach((moduleEntry) => {
                const moduleDetails = document.createElement('details');
                moduleDetails.className = 'syllabus-module';
                const moduleHasSelection = (moduleEntry.lectures || []).some(
                  (lecture) => lecture.id === state.selectedLectureId,
                );
                const moduleId = moduleEntry.module?.id != null ? String(moduleEntry.module.id) : null;
                let expandModule = Boolean(moduleHasSelection);
                if (classId && moduleId) {
                  const moduleKey = `${classId}:${moduleId}`;
                  const storedModuleValue = state.expandedModules.get(moduleKey);
                  if (typeof storedModuleValue === 'boolean') {
                    expandModule = storedModuleValue;
                  }
                  if (moduleHasSelection) {
                    expandModule = true;
                    state.expandedModules.set(moduleKey, true);
                  }
                  moduleDetails.dataset.classId = classId;
                  moduleDetails.dataset.moduleId = moduleId;
                  moduleDetails.addEventListener('toggle', () => {
                    state.expandedModules.set(moduleKey, moduleDetails.open);
                  });
                }
                moduleDetails.open = expandModule;

                const moduleSummary = document.createElement('summary');
                moduleSummary.className = 'syllabus-summary';

                const moduleSummaryText = document.createElement('div');
                moduleSummaryText.className = 'syllabus-summary-text';

                const moduleHeader = document.createElement('div');
                moduleHeader.className = 'syllabus-summary-header';

                const moduleTitle = document.createElement('span');
                moduleTitle.className = 'syllabus-title';
                moduleTitle.textContent = moduleEntry.module.name;
                moduleHeader.appendChild(moduleTitle);
                moduleSummaryText.appendChild(moduleHeader);

                const moduleLectureCount = moduleEntry.lectures.length;
                const moduleLectureWord = pluralize(
                  currentLanguage,
                  'counts.lecture',
                  moduleLectureCount,
                );
                const moduleMeta = document.createElement('span');
                moduleMeta.className = 'syllabus-meta';
                moduleMeta.textContent = t('curriculum.moduleMeta', {
                  lectureCount: moduleLectureCount,
                  lectureWord: moduleLectureWord,
                });
                moduleSummaryText.appendChild(moduleMeta);

                moduleSummary.appendChild(moduleSummaryText);

                if (state.editMode) {
                  const moduleActions = document.createElement('div');
                  moduleActions.className = 'syllabus-actions';

                  const deleteModuleButton = createIconButton(
                    t('common.actions.delete'),
                    '',
                    'danger',
                  );
                  deleteModuleButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    handleDeleteModule(moduleEntry, entry.class);
                  });
                  moduleActions.appendChild(deleteModuleButton);

                  moduleSummary.appendChild(moduleActions);
                }

                moduleDetails.appendChild(moduleSummary);

                const moduleContent = document.createElement('div');
                moduleContent.className = 'syllabus-content';

                const lectureList = document.createElement('ul');
                lectureList.className = 'syllabus-lectures';
                lectureList.dataset.moduleId = String(moduleEntry.module.id);

                if (!moduleEntry.lectures.length) {
                  lectureList.classList.add('empty');
                  const emptyLectures = document.createElement('li');
                  emptyLectures.className = 'placeholder';
                  emptyLectures.textContent = t('placeholders.noLectures');
                  emptyLectures.setAttribute('aria-hidden', 'true');
                  lectureList.appendChild(emptyLectures);
                } else {
                  moduleEntry.lectures.forEach((lecture) => {
                    const lectureItem = document.createElement('li');
                    lectureItem.className = 'syllabus-lecture';
                    lectureItem.dataset.lectureId = String(lecture.id);

                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'lecture-button';
                    const lectureTitle = document.createElement('span');
                    lectureTitle.className = 'lecture-title';
                    lectureTitle.textContent = lecture.name;
                    button.appendChild(lectureTitle);
                    button.addEventListener('click', (event) => {
                      event.preventDefault();
                      selectLecture(lecture.id);
                    });
                    lectureItem.appendChild(button);
                    state.buttonMap.set(lecture.id, button);

                    if (state.editMode) {
                      lectureItem.draggable = true;
                      lectureItem.addEventListener('dragstart', (event) => {
                        startLectureDrag(event, lecture, moduleEntry.module.id);
                      });
                      lectureItem.addEventListener('dragend', clearLectureDrag);

                      const deleteLectureButton = createIconButton(
                        t('common.actions.delete'),
                        '',
                        'danger',
                      );
                      deleteLectureButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        handleDeleteLecture(lecture, moduleEntry.module, entry.class);
                      });
                      lectureItem.appendChild(deleteLectureButton);
                    }

                    lectureList.appendChild(lectureItem);
                  });
                }

                if (state.editMode) {
                  const dropHandler = (event) => handleLectureDrop(event, moduleEntry.module.id);
                  lectureList.addEventListener('dragover', handleLectureDragOver);
                  lectureList.addEventListener('dragleave', handleLectureDragLeave);
                  lectureList.addEventListener('drop', dropHandler);
                }

                moduleContent.appendChild(lectureList);

                moduleDetails.appendChild(moduleContent);
                modulesContainer.appendChild(moduleDetails);
              });

              content.appendChild(modulesContainer);
            }

            classDetails.appendChild(content);
            syllabus.appendChild(classDetails);
          });

          dom.curriculum.appendChild(syllabus);
          renderCurriculumEditor();
          highlightSelected();
        }

        function pruneExpansionState() {
          const classIds = new Set(
            state.classes.map((klass) => (klass?.id != null ? String(klass.id) : null)).filter(Boolean),
          );
          state.expandedClasses.forEach((_, key) => {
            if (!classIds.has(key)) {
              state.expandedClasses.delete(key);
            }
          });

          const moduleKeys = new Set();
          state.classes.forEach((klass) => {
            const classId = klass?.id != null ? String(klass.id) : null;
            if (!classId) {
              return;
            }
            (klass.modules || []).forEach((module) => {
              if (module?.id == null) {
                return;
              }
              moduleKeys.add(`${classId}:${module.id}`);
            });
          });
          state.expandedModules.forEach((_, key) => {
            if (!moduleKeys.has(key)) {
              state.expandedModules.delete(key);
            }
          });
        }

        function requireEditMode(message = t('status.requireEdit')) {
          if (!state.editMode) {
            showStatus(message, 'info');
            return false;
          }
          return true;
        }

        async function handleAddClass() {
          if (!requireEditMode()) {
            return;
          }
          const name = await promptDialog({
            title: t('dialogs.createClass.title'),
            message: t('dialogs.createClass.message'),
            confirmText: t('common.actions.create'),
            placeholder: t('dialogs.createClass.placeholder'),
            required: true,
          });
          if (!name || !name.trim()) {
            return;
          }
          try {
            await request('/api/classes', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: name.trim() }),
            });
            showStatus(t('status.classCreated'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleAddModule(classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const name = await promptDialog({
            title: t('dialogs.createModule.title'),
            message: t('dialogs.createModule.message', { className: classRecord.name }),
            confirmText: t('common.actions.create'),
            placeholder: t('dialogs.createModule.placeholder'),
            required: true,
          });
          if (!name || !name.trim()) {
            return;
          }
          try {
            await request('/api/modules', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                class_id: classRecord.id,
                name: name.trim(),
              }),
            });
            showStatus(t('status.moduleCreated'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleDeleteClass(classEntry) {
          if (!requireEditMode()) {
            return;
          }
          const moduleCount = classEntry.modules.length;
          const lectureCount = classEntry.modules.reduce(
            (total, moduleEntry) => total + (moduleEntry.lectures?.length || 0),
            0,
          );
          const moduleWord = pluralize(currentLanguage, 'counts.module', moduleCount);
          const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
          let message = t('dialogs.deleteClass.message', { className: classEntry.class.name });
          if (moduleCount || lectureCount) {
            message += `\n\n${t('dialogs.deleteClass.summary', {
              moduleCount,
              moduleWord,
              lectureCount,
              lectureWord,
            })}`;
          }
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteClass.title'),
            message,
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteClass.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            await request(`/api/classes/${classEntry.class.id}`, { method: 'DELETE' });
            if (state.selectedLectureId) {
              const removed = classEntry.modules.some((moduleEntry) =>
                (moduleEntry.lectures || []).some(
                  (lecture) => lecture.id === state.selectedLectureId,
                ),
              );
              if (removed) {
                state.selectedLectureId = null;
                clearDetailPanel();
              }
            }
            showStatus(t('status.classRemoved'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleDeleteModule(moduleEntry, classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const lectureCount = moduleEntry.lectures.length;
          const classContext = classRecord
            ? t('dialogs.deleteModule.classContext', { className: classRecord.name })
            : '';
          let message = t('dialogs.deleteModule.message', {
            moduleName: moduleEntry.module.name,
            classContext,
          });
          if (lectureCount) {
            const lectureWord = pluralize(currentLanguage, 'counts.lecture', lectureCount);
            message += `\n\n${t('dialogs.deleteModule.summary', {
              lectureCount,
              lectureWord,
            })}`;
          }
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteModule.title'),
            message,
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteModule.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            await request(`/api/modules/${moduleEntry.module.id}`, { method: 'DELETE' });
            if (state.selectedLectureId) {
              const removed = (moduleEntry.lectures || []).some(
                (lecture) => lecture.id === state.selectedLectureId,
              );
              if (removed) {
                state.selectedLectureId = null;
                clearDetailPanel();
              }
            }
            showStatus(t('status.moduleRemoved'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleAddLecture(moduleRecord, classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const contextParts = classRecord
            ? [classRecord.name, moduleRecord.name]
            : [moduleRecord.name];
          const namePrompt = contextParts.join('  ');
          const name = await promptDialog({
            title: t('dialogs.createLecture.title'),
            message: t('dialogs.createLecture.message', { context: namePrompt }),
            confirmText: t('common.actions.create'),
            placeholder: t('dialogs.createLecture.placeholder'),
            required: true,
          });
          if (!name || !name.trim()) {
            return;
          }
          const description =
            (await promptDialog({
              title: t('dialogs.lectureDescription.title'),
              message: t('dialogs.descriptionOptional'),
              confirmText: t('common.actions.save'),
              cancelText: t('common.actions.skip'),
              placeholder: t('dialogs.lectureDescription.placeholder'),
            })) ?? '';
          try {
            const payload = await request('/api/lectures', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                module_id: moduleRecord.id,
                name: name.trim(),
                description: description.trim(),
              }),
            });
            showStatus(t('status.lectureCreated'), 'success');
            await refreshData();
            const newLectureId = payload?.lecture?.id;
            if (newLectureId) {
              await selectLecture(newLectureId);
            }
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleDeleteLecture(lecture, moduleRecord, classRecord) {
          if (!requireEditMode()) {
            return;
          }
          const contextParts = [lecture.name];
          if (moduleRecord) {
            contextParts.push(moduleRecord.name);
          }
          if (classRecord) {
            contextParts.push(classRecord.name);
          }
          const context = contextParts.join('  ');
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteLecture.title'),
            message: t('dialogs.deleteLecture.message', { context }),
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteLecture.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          try {
            await request(`/api/lectures/${lecture.id}`, { method: 'DELETE' });
            if (state.selectedLectureId === lecture.id) {
              state.selectedLectureId = null;
              clearDetailPanel();
            }
            showStatus(t('status.lectureRemoved'), 'success');
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        function applyAppearance(displayMode, theme, effects) {
          const mode = normalizeDisplayMode(displayMode, theme);
          const palette = normalizeTheme(theme);
          const effectLevel = normalizeVisualEffects(effects);
          document.body.dataset.displayMode = mode;
          document.body.dataset.theme = palette;
          document.body.dataset.effects = effectLevel;
        }

        function previewAppearance() {
          const modeSource = dom.settingsDisplayMode
            ? dom.settingsDisplayMode.value
            : document.body.dataset.displayMode || DEFAULT_DISPLAY_MODE;
          const themeSource = dom.settingsTheme
            ? dom.settingsTheme.value
            : document.body.dataset.theme || DEFAULT_THEME;
          const effectsSource = dom.settingsVisualEffects
            ? dom.settingsVisualEffects.value
            : document.body.dataset.effects || DEFAULT_VISUAL_EFFECTS;
          applyAppearance(modeSource, themeSource, effectsSource);
        }

        async function loadSettings() {
          try {
            const payload = await request('/api/settings');
            const settings = payload?.settings;
            if (!settings) {
              return;
            }
            syncSettingsForm(settings);
            if (settings.cloud_connection_enabled && settings.cloud_auto_connect) {
              await testCloudConnection({ silent: true });
            }
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        function renderAssets(lecture) {
          dom.assetList.innerHTML = '';
          setTranscribeControls(null, null, null);
          const rawAudioFiles = Array.isArray(lecture.raw_audio_files)
            ? lecture.raw_audio_files
            : [];
          const rawSlideFiles = Array.isArray(lecture.raw_slide_files)
            ? lecture.raw_slide_files
            : [];

          function createAssetFileList(files, definition) {
            if (!Array.isArray(files) || !files.length) {
              return null;
            }
            const list = document.createElement('ul');
            list.className = 'asset-sublist';
            files.forEach((entry, index) => {
              if (!entry || typeof entry.path !== 'string') {
                return;
              }
              const item = document.createElement('li');
              item.className = 'asset-sublist-item';
              const title = document.createElement('strong');
              title.textContent = entry.name || `File ${index + 1}`;
              item.appendChild(title);
              if (typeof entry.size === 'number' && Number.isFinite(entry.size) && entry.size >= 0) {
                const sizeElement = document.createElement('span');
                sizeElement.className = 'asset-sublist-meta';
                sizeElement.textContent = formatBytes(entry.size);
                item.appendChild(sizeElement);
              }
              const actions = document.createElement('div');
              actions.className = 'asset-sublist-actions';
              const viewButton = document.createElement('button');
              viewButton.type = 'button';
              viewButton.textContent = t('assets.actions.view');
              viewButton.addEventListener('click', () => {
                openAssetViewer(definition, entry.path);
              });
              actions.appendChild(viewButton);
              const downloadButton = document.createElement('button');
              downloadButton.type = 'button';
              downloadButton.textContent = t('assets.actions.download');
              downloadButton.addEventListener('click', () => {
                const downloadUrl = buildStorageURL(entry.path);
                const fallbackName = entry.name || `${definition.type || 'asset'}.bin`;
                const anchor = document.createElement('a');
                anchor.href = downloadUrl;
                anchor.download = fallbackName;
                anchor.rel = 'noopener';
                anchor.style.display = 'none';
                document.body.appendChild(anchor);
                anchor.click();
                anchor.remove();
              });
              actions.appendChild(downloadButton);
              item.appendChild(actions);
              list.appendChild(item);
            });
            return list;
          }

          assetDefinitions.forEach((definition) => {
            const value = lecture[definition.key];
            if (
              definition.type === 'processed_audio' &&
              (!value || value === lecture.audio_path)
            ) {
              return;
            }
            const rawFiles =
              definition.type === 'audio'
                ? rawAudioFiles
                : definition.type === 'slides'
                ? rawSlideFiles
                : [];
            const item = document.createElement('li');
            item.className = 'asset-item';
            const header = document.createElement('div');
            header.className = 'asset-header';
            header.textContent = t(definition.labelKey);
            item.appendChild(header);

            const status = document.createElement('div');
            status.className = 'asset-status';
            let statusText = t('assets.status.notLinked');
            let statusNote = null;
            let isPdfSlide = false;
            const firstRawPath = rawFiles.length ? rawFiles[0]?.path : null;
            const effectiveValue = value || firstRawPath || null;
            if (value) {
              const fileName = value.split('/').pop();
              if (definition.type === 'slides') {
                isPdfSlide = typeof value === 'string' && value.toLowerCase().endsWith('.pdf');
                statusText = t('assets.status.slidesUploaded', { name: fileName });
                if (!isPdfSlide) {
                  statusNote = t('assets.status.slidesStoredOnly');
                }
              } else if (definition.type === 'slide_bundle') {
                statusText = t('assets.status.archiveCreated', { name: fileName });
              } else if (definition.type === 'processed_audio') {
                statusText = t('assets.status.mastered', { name: fileName });
              } else {
                statusText = t('assets.status.linked', { name: fileName });
              }
            } else if (definition.type === 'audio' && rawFiles.length) {
              statusText = t('assets.status.audioPending', { count: rawFiles.length });
            } else if (definition.type === 'slides' && rawFiles.length) {
              statusText = t('assets.status.slidesPending', { count: rawFiles.length });
              isPdfSlide = true;
            } else if (definition.type === 'slides') {
              statusText = t('assets.status.slidesHint');
            } else if (definition.type === 'slide_bundle') {
              statusText = t('assets.status.noSlideImages');
            }
            status.textContent = statusText;
            if (statusNote) {
              const noteElement = document.createElement('span');
              noteElement.className = 'asset-status-note';
              noteElement.textContent = statusNote;
              status.appendChild(noteElement);
            }
            item.appendChild(status);

            const actions = document.createElement('div');
            actions.className = 'asset-actions';

            let transcribeButton = null;
            let modelLabel = null;
            let modelSelect = null;
            let gpuOption = null;

            if (definition.accept) {
              const uploadButton = document.createElement('button');
              uploadButton.type = 'button';
              uploadButton.className = 'secondary';
              uploadButton.textContent = t('assets.actions.upload');
              uploadButton.addEventListener('click', () => {
                handleAssetUpload(definition);
              });
              actions.appendChild(uploadButton);
            }

            if (definition.type === 'audio') {
              transcribeButton = document.createElement('button');
              transcribeButton.type = 'button';
              transcribeButton.className = 'secondary';
              transcribeButton.setAttribute('data-i18n', 'assets.transcribe');
              transcribeButton.textContent = t('assets.transcribe');
              const hasProcessedAudio = Boolean(lecture.processed_audio_path);
              const hasAudioSource = Boolean(value) || hasProcessedAudio || rawFiles.length > 0;
              transcribeButton.disabled = !hasAudioSource;
              actions.appendChild(transcribeButton);

              modelLabel = document.createElement('label');
              modelLabel.className = 'inline';
              modelLabel.textContent = t('assets.modelLabel');
              modelLabel.setAttribute('for', 'transcribe-model');
              modelLabel.style.marginLeft = 'auto';

              modelSelect = document.createElement('select');
              modelSelect.id = 'transcribe-model';
              const modelChoices = ['tiny', 'base', 'small', 'medium', 'large', 'gpu'];
              modelChoices.forEach((choice) => {
                const option = document.createElement('option');
                option.value = choice;
                option.setAttribute('data-i18n', `assets.model.${choice}`);
                option.textContent = t(`assets.model.${choice}`);
                if (choice === GPU_MODEL) {
                  option.classList.add('gpu-only');
                  option.disabled = true;
                  gpuOption = option;
                }
                modelSelect.appendChild(option);
              });
              const requestedModel = normalizeWhisperModel(
                state.settings?.whisper_model_requested || state.settings?.whisper_model,
              );
              modelSelect.value = requestedModel;
              modelLabel.appendChild(modelSelect);
            }

            const viewTarget = effectiveValue;
            const viewable = Boolean(viewTarget && isAssetViewable(definition, viewTarget));
            if (viewable) {
              const viewButton = document.createElement('button');
              viewButton.type = 'button';
              viewButton.className = 'secondary';
              viewButton.textContent = t('assets.actions.view');
              viewButton.disabled = !viewTarget;
              viewButton.addEventListener('click', () => {
                if (!viewTarget) {
                  return;
                }
                openAssetViewer(definition, viewTarget);
              });
              actions.appendChild(viewButton);
            }

            const downloadButton = document.createElement('button');
            downloadButton.type = 'button';
            downloadButton.className = 'secondary';
            downloadButton.textContent = t('assets.actions.download');
            downloadButton.disabled = !viewTarget;
            downloadButton.addEventListener('click', () => {
              if (!viewTarget) {
                return;
              }
              const downloadUrl = buildStorageURL(viewTarget);
              const rawEntry = rawFiles.find((entry) => entry?.path === viewTarget) || rawFiles[0];
              const fallbackName =
                (typeof value === 'string' && value.split('/').pop()) ||
                rawEntry?.name ||
                `${definition.type || 'asset'}.bin`;
              const anchor = document.createElement('a');
              anchor.href = downloadUrl;
              anchor.download = fallbackName;
              anchor.rel = 'noopener';
              anchor.style.display = 'none';
              document.body.appendChild(anchor);
              anchor.click();
              anchor.remove();
            });

            if (definition.type === 'slides') {
              const isProcessing = state.processingProgressLectureId === lecture.id;
              const hasSlideSource = Boolean(viewTarget);
              if (hasSlideSource) {
                const processSlidesButton = document.createElement('button');
                processSlidesButton.type = 'button';
                processSlidesButton.className = 'secondary';
                processSlidesButton.setAttribute('data-i18n', 'assets.actions.processSlides');
                processSlidesButton.textContent = t('assets.actions.processSlides');
                processSlidesButton.disabled = !hasSlideSource || isProcessing;
                processSlidesButton.addEventListener('click', () => {
                  handleSlideProcessing(definition);
                });
                actions.appendChild(processSlidesButton);
              }
              isPdfSlide = isPdfSlide || rawFiles.length > 0;
            }

            actions.appendChild(downloadButton);

            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.className = 'danger';
            removeButton.textContent = t('assets.actions.remove');
            const hasAsset = Boolean(value) || rawFiles.length > 0;
            removeButton.disabled = !hasAsset;
            removeButton.addEventListener('click', () => {
              if (!hasAsset) {
                return;
              }
              handleAssetRemoval(definition);
            });
            actions.appendChild(removeButton);

            if (definition.type === 'audio' && modelLabel && modelSelect) {
              actions.appendChild(modelLabel);
              setTranscribeControls(transcribeButton, modelSelect, gpuOption);
              const hasProcessedAudio = Boolean(lecture.processed_audio_path);
              const hasAudioSource = Boolean(value) || hasProcessedAudio || rawFiles.length > 0;
              setTranscribeButtonDisabled(!hasAudioSource);
            }

            item.appendChild(actions);

            if (definition.type === 'audio') {
              const sublist = createAssetFileList(rawAudioFiles, definition);
              if (sublist) {
                item.appendChild(sublist);
              }
            } else if (definition.type === 'slides') {
              const sublist = createAssetFileList(rawSlideFiles, definition);
              if (sublist) {
                item.appendChild(sublist);
              }
            }

            dom.assetList.appendChild(item);
          });
        }

        function renderSummary(detail) {
          const lecture = detail.lecture;
          const module = detail.module;
          const classRecord = detail.class;

          dom.summary.classList.remove('placeholder');
          dom.summary.innerHTML = '';

          const title = document.createElement('h3');
          title.textContent = lecture.name;
          dom.summary.appendChild(title);

          const context = document.createElement('div');
          context.className = 'asset-status';
          context.textContent = `${classRecord.name}  ${module.name}`;
          dom.summary.appendChild(context);

          const description = document.createElement('p');
          description.textContent = lecture.description || t('details.noDescription');
          dom.summary.appendChild(description);
        }

        async function refreshData() {
          try {
            const payload = await request('/api/classes');
            state.classes = payload?.classes || [];
            state.stats = payload?.stats || {};
            pruneExpansionState();
            state.storage.initialized = false;
            state.storage.overview = null;
            state.storage.usage = null;
            state.storage.detail = null;
            state.storage.repairing = false;
            state.storage.repairSummary = null;
            const storageBrowser = getStorageBrowserState();
            storageBrowser.initialized = false;
            storageBrowser.entries = [];
            storageBrowser.path = '';
            storageBrowser.parent = null;
            storageBrowser.error = null;
            storageBrowser.deleting.clear();
            updateStats();
            updateModuleOptions();
            renderCurriculum();

            if (state.selectedLectureId) {
              const exists = state.classes.some((klass) =>
                (klass.modules || []).some((module) =>
                  (module.lectures || []).some((lecture) => lecture.id === state.selectedLectureId),
                ),
              );
              if (!exists) {
                state.selectedLectureId = null;
                clearDetailPanel();
              }
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error ?? '');
            showStatus(message, 'error');
            if (dom.curriculum) {
              dom.curriculum.innerHTML = '';
              const placeholder = document.createElement('div');
              placeholder.className = 'placeholder';
              placeholder.textContent = message || t('status.curriculumLoadFailed');
              dom.curriculum.appendChild(placeholder);
            }
          }
          updateTaskLectureOptions();
        }

        async function selectLecture(lectureId) {
          state.selectedLectureId = lectureId;
          state.selectedLectureDetail = null;
          const expanded = ensureLectureExpansion(lectureId);
          if (expanded) {
            renderCurriculum();
          }
          highlightSelected();
          setActiveView('details');
          try {
            const detail = await request(`/api/lectures/${lectureId}`);
            if (!detail) {
              return;
            }
            state.selectedLectureDetail = detail;
            renderSummary(detail);
            dom.assetSection.hidden = false;

            dom.editName.value = detail.lecture.name;
            dom.editDescription.value = detail.lecture.description || '';
            dom.editModule.value = String(detail.lecture.module_id);

            updateEditControlsAvailability();

            if (state.editMode) {
              dom.editName.focus();
            }

            const rawAudioFiles = Array.isArray(detail.lecture.raw_audio_files)
              ? detail.lecture.raw_audio_files
              : [];
            const hasAudioSource = Boolean(detail.lecture.audio_path || detail.lecture.processed_audio_path);
            setTranscribeButtonDisabled(!hasAudioSource && rawAudioFiles.length === 0);

            renderAssets(detail.lecture);
          } catch (error) {
            state.selectedLectureDetail = null;
            showStatus(error.message, 'error');
          }
        }

        async function handleAssetRemoval(definition) {
          if (!definition || !state.selectedLectureId) {
            return;
          }

          const kind = definition.type;
          if (!kind) {
            return;
          }

          const lectureId = state.selectedLectureId;
          const assetLabel = t(definition.labelKey);
          const confirmed = await confirmDialog({
            title: t('dialogs.removeAsset.title', { asset: assetLabel }),
            message: t('dialogs.removeAsset.message', { asset: assetLabel }),
            confirmText: t('dialogs.removeAsset.confirm'),
            cancelText: t('dialog.cancel'),
            variant: 'danger',
          });

          if (!confirmed) {
            return;
          }

          try {
            await request(`/api/lectures/${lectureId}/assets/${kind}`, { method: 'DELETE' });
            showStatus(t('status.assetRemoved'), 'success');
            await refreshData();
            await selectLecture(lectureId);
          } catch (error) {
            showStatus(error.message, 'error');
          }
        }

        async function handleAssetUpload(definition) {
          if (!definition || !state.selectedLectureId) {
            return;
          }

          const lectureId = state.selectedLectureId;
          const kind = definition.type;
          const assetLabel = t(definition.labelKey);
          let audioProcessingStarted = false;

          const allowAudioBackground =
            kind === 'audio' && state.settings?.audio_mastering_enabled !== false;
          const allowBackgroundProcessing = allowAudioBackground;
          const enableProcessingStage = allowBackgroundProcessing;
          const processingLabel =
            kind === 'audio' ? t('dialogs.upload.processingAudio') : undefined;
          const backgroundProcessingLabel =
            kind === 'audio' ? t('dialogs.upload.backgroundProcessing') : undefined;

            const dialogResult = await showUploadDialog({
              accept: definition.accept || '',
              title: t('dialogs.upload.assetTitle', { asset: assetLabel }),
              description: t('dialogs.upload.assetDescription'),
              prompt: t('dialogs.upload.prompt'),
              help: t('dialogs.upload.help'),
              browseLabel: t('dialogs.upload.browse'),
              clearLabel: t('dialogs.upload.clear'),
              uploadLabel: t('dialogs.upload.action'),
              multiple: kind === 'audio' || kind === 'slides',
              processing: processingLabel,
              processingAction: t('dialogs.upload.processingAction'),
              allowBackgroundProcessing,
              enableProcessingStage,
              backgroundProcessing: backgroundProcessingLabel,
            onFileSelected: null,
            onUpload: async (file, helpers) => {
              const formData = new FormData();
              let endpoint = `/api/lectures/${lectureId}/assets/${kind}`;
              formData.append('file', file);

              if (kind === 'audio') {
                stopTranscriptionProgress();
                stopProcessingProgress();
                state.lastProgressMessage = '';
                state.lastProgressRatio = null;
                if (allowAudioBackground) {
                  startProcessingProgress(lectureId);
                  audioProcessingStarted = true;
                } else {
                  audioProcessingStarted = false;
                }
              }

              try {
                const response = await uploadWithProgress(endpoint, {
                  method: 'POST',
                  body: formData,
                  onProgress: (ratio) => {
                    helpers?.reportProgress?.(ratio);
                  },
                });
                return response;
              } catch (error) {
                if (kind === 'audio' && audioProcessingStarted) {
                  stopProcessingProgress();
                  audioProcessingStarted = false;
                }
                throw error;
              }
            },
          });

          const backgroundProcessingActive = Boolean(
            (dialogResult && dialogResult.processing) ||
              (dialogResult && dialogResult.result && dialogResult.result.processing)
          );

          if (!dialogResult || (!dialogResult.uploaded && !backgroundProcessingActive)) {
            if (kind === 'audio' && audioProcessingStarted) {
              stopProcessingProgress();
              audioProcessingStarted = false;
            }
            return;
          }

          if (!dialogResult.confirmed) {
            if (!backgroundProcessingActive) {
              await refreshData();
              await selectLecture(lectureId);
              if (kind === 'audio' && audioProcessingStarted) {
                stopProcessingProgress({ preserveMessage: true });
                audioProcessingStarted = false;
              }
            }
            return;
          }

          const successMessage =
            kind === 'slides' ? t('status.slidesUploaded') : t('status.assetUploaded');
          if (kind === 'audio') {
            if (allowAudioBackground) {
              showStatus(t('status.audioProcessingQueued'), 'info', { persist: true });
            } else {
              showStatus(successMessage, 'success');
            }
          } else {
            showStatus(successMessage, 'success');
          }
          await refreshData();
          await selectLecture(lectureId);
          if (kind === 'audio' && audioProcessingStarted && !backgroundProcessingActive) {
            stopProcessingProgress({ preserveMessage: true });
            audioProcessingStarted = false;
          }
        }

        function appendProcessingLectureMetadata(formData, detail) {
          if (!(formData instanceof FormData) || !detail) {
            return;
          }
          if (!state.cloudConnection.enabled || state.cloudConnection.processingTarget !== 'local') {
            return;
          }
          const lecture = detail?.lecture;
          const module = detail?.module;
          const classRecord = detail?.class;
          if (!lecture || !module || !classRecord) {
            return;
          }
          if (Number.isFinite(classRecord.id)) {
            formData.append('class_id', String(classRecord.id));
          }
          if (typeof classRecord.name === 'string') {
            formData.append('class_name', classRecord.name);
          }
          if (typeof classRecord.description === 'string') {
            formData.append('class_description', classRecord.description);
          }
          if (Number.isFinite(module.id)) {
            formData.append('module_id', String(module.id));
          }
          if (typeof module.name === 'string') {
            formData.append('module_name', module.name);
          }
          if (typeof module.description === 'string') {
            formData.append('module_description', module.description);
          }
          if (typeof lecture.name === 'string') {
            formData.append('lecture_name', lecture.name);
          }
          if (typeof lecture.description === 'string') {
            formData.append('lecture_description', lecture.description);
          }
          if (typeof lecture.audio_path === 'string') {
            formData.append('audio_path', lecture.audio_path);
          }
          if (typeof lecture.processed_audio_path === 'string') {
            formData.append('processed_audio_path', lecture.processed_audio_path);
          }
          if (typeof lecture.slide_path === 'string') {
            formData.append('slide_path', lecture.slide_path);
          }
          if (typeof lecture.transcript_path === 'string') {
            formData.append('transcript_path', lecture.transcript_path);
          }
          if (typeof lecture.notes_path === 'string') {
            formData.append('notes_path', lecture.notes_path);
          }
          if (typeof lecture.slide_image_dir === 'string') {
            formData.append('slide_image_dir', lecture.slide_image_dir);
          }
        }

        async function handleSlideProcessing(definition) {
          if (!definition || definition.type !== 'slides' || !state.selectedLectureId) {
            return;
          }

          const lectureId = state.selectedLectureId;
          const detail = state.selectedLectureDetail;
          const slidePath = detail?.lecture?.slide_path;
          const rawSlides = Array.isArray(detail?.lecture?.raw_slide_files)
            ? detail.lecture.raw_slide_files
            : [];
          if (!slidePath && rawSlides.length === 0) {
            showStatus(t('status.slidesUploadRequired'), 'info');
            return;
          }

          let preview = null;
          try {
            preview = await createSlidePreview(lectureId, null, { source: 'existing' });
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message, 'error');
            return;
          }

          if (!preview) {
            showStatus(t('status.slidePreviewFailed'), 'error');
            return;
          }

          const previewSource = {
            url: preview.url,
            withCredentials: true,
            previewId: preview.id,
            lectureId,
            pageCount:
              typeof preview.pageCount === 'number' && Number.isFinite(preview.pageCount)
                ? Math.max(0, Math.round(preview.pageCount))
                : null,
          };

          let selection;
          try {
            selection = await showSlideRangeDialog(previewSource);
          } catch (error) {
            await deleteSlidePreview(lectureId, preview.id);
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message, 'error');
            return;
          }
          if (!selection || !selection.confirmed) {
            await deleteSlidePreview(lectureId, preview.id);
            return;
          }

          const formData = new FormData();
          formData.append('use_existing', 'true');
          if (typeof selection.pageStart === 'number' && Number.isFinite(selection.pageStart)) {
            formData.append('page_start', String(selection.pageStart));
          }
          if (typeof selection.pageEnd === 'number' && Number.isFinite(selection.pageEnd)) {
            formData.append('page_end', String(selection.pageEnd));
          }
          appendProcessingLectureMetadata(formData, detail);
          try {
            await deleteSlidePreview(lectureId, preview.id);
          } catch (error) {
            console.warn('Failed to remove slide preview before processing', error);
          }

          stopProcessingProgress();
          state.lastProgressMessage = '';
          state.lastProgressRatio = null;
          startProcessingProgress(lectureId);
          showStatus(t('status.processingSlides'), 'info', { persist: true });

          try {
            await request(`/api/lectures/${lectureId}/process-slides`, {
              method: 'POST',
              body: formData,
            });
            showStatus(t('status.slidesProcessed'), 'success');
            await refreshData();
            await selectLecture(lectureId);
          } catch (error) {
            stopProcessingProgress();
            const message = error instanceof Error ? error.message : String(error);
            showStatus(message, 'error');
          }
        }

        if (dom.storage && dom.storage.refresh) {
          dom.storage.refresh.addEventListener('click', () => {
            void refreshStorage({ includeOverview: true, force: true });
          });
        }

        if (dom.storage && dom.storage.browser && dom.storage.browser.navRoot) {
          dom.storage.browser.navRoot.addEventListener('click', () => {
            void refreshStorage({ includeOverview: false, path: '', force: true });
          });
        }

        if (dom.storage && dom.storage.browser && dom.storage.browser.navUp) {
          dom.storage.browser.navUp.addEventListener('click', () => {
            const browserState = getStorageBrowserState();
            if (browserState.parent === null) {
              return;
            }
            const parentPath = browserState.parent || '';
            void refreshStorage({ includeOverview: false, path: parentPath, force: true });
          });
        }

        if (dom.storage && dom.storage.browser && dom.storage.browser.tableBody) {
          dom.storage.browser.tableBody.addEventListener('click', (event) => {
            void handleStorageBrowserAction(event);
          });
          dom.storage.browser.tableBody.addEventListener('change', (event) => {
            handleStorageSelectionChange(event);
          });
        }

        if (dom.storage && dom.storage.browser && dom.storage.browser.selectAll) {
          dom.storage.browser.selectAll.addEventListener('change', (event) => {
            handleStorageSelectAll(event);
          });
        }

        if (dom.storage && dom.storage.downloadSelected) {
          dom.storage.downloadSelected.addEventListener('click', () => {
            void handleStorageDownloadSelected();
          });
        }

        if (dom.storage && dom.storage.repair) {
          dom.storage.repair.addEventListener('click', () => {
            void handleStorageRepair();
          });
        }

        if (dom.storage && dom.storage.purge) {
          dom.storage.purge.addEventListener('click', () => {
            handlePurgeProcessedAudio();
          });
        }

        if (dom.tasks && dom.tasks.refresh) {
          dom.tasks.refresh.addEventListener('click', () => {
            void refreshTasks({ force: true });
          });
        }

        if (dom.tasks && dom.tasks.clearDone) {
          dom.tasks.clearDone.addEventListener('click', () => {
            void clearCompletedTasks();
          });
        }

        if (dom.tasks && dom.tasks.list) {
          dom.tasks.list.addEventListener('click', (event) => {
            void handleTaskAction(event);
          });
        }

        if (dom.tasks && dom.tasks.bulkProcess) {
          dom.tasks.bulkProcess.addEventListener('click', () => {
            openBulkProcessDialog();
          });
        }

        if (dom.tasks && dom.tasks.bulkDownload) {
          dom.tasks.bulkDownload.addEventListener('click', () => {
            openBulkDownloadDialog();
          });
        }

        if (dom.tasks && dom.tasks.bulkUpload && dom.tasks.bulkInput) {
          dom.tasks.bulkUpload.addEventListener('click', () => {
            dom.tasks.bulkInput.click();
          });
        }

        if (dom.tasks && dom.tasks.bulkInput) {
          dom.tasks.bulkInput.addEventListener('change', (event) => {
            void handleBulkUploadInput(event);
          });
        }

        updateTaskLectureOptions();


        dom.viewButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const view = button.dataset.view;
            if (!view) {
              return;
            }
            setActiveView(view);
            if (view === 'create') {
              dom.createModule.focus();
            } else if (view === 'details' && state.editMode && state.selectedLectureId) {
              dom.editName.focus();
            }
          });
        });

        if (dom.editToggle) {
          dom.editToggle.addEventListener('click', async () => {
            if (state.editMode) {
              dom.editToggle.disabled = true;
              try {
                const saved = await saveCurriculumFromEditor();
                if (!saved) {
                  return;
                }
                state.editMode = false;
                updateEditModeUI();
              } finally {
                dom.editToggle.disabled = false;
              }
              return;
            }

            if (dom.curriculumEditor) {
              dom.curriculumEditor.dataset.dirty = 'false';
            }
            state.editMode = true;
            updateEditModeUI();
            const editor = dom.curriculumEditor;
            if (editor) {
              const length = editor.value.length;
              editor.setSelectionRange(length, length);
              editor.focus();
            }
          });
        }

        dom.search.addEventListener('input', (event) => {
          state.query = event.target.value;
          renderCurriculum();
        });

        dom.editForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (!state.editMode) {
            showStatus(t('status.requireEditLecture'), 'info');
            return;
          }
          if (!state.selectedLectureId) {
            return;
          }
          const payload = {
            name: dom.editName.value.trim(),
            description: dom.editDescription.value.trim(),
          };
          const moduleValue = dom.editModule.value;
          if (moduleValue) {
            payload.module_id = Number(moduleValue);
          }
          if (!payload.name) {
            showStatus(t('status.lectureTitleRequired'), 'error');
            return;
          }
          try {
            await request(`/api/lectures/${state.selectedLectureId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            showStatus(t('status.lectureUpdated'), 'success');
            await refreshData();
            await selectLecture(state.selectedLectureId);
          } catch (error) {
            showStatus(error.message, 'error');
          }
        });

        dom.deleteButton.addEventListener('click', async () => {
          if (!state.selectedLectureId || !state.editMode) {
            return;
          }
          const lectureName = dom.editName.value.trim() || dom.editName.placeholder || '';
          const confirmed = await confirmDialog({
            title: t('dialogs.deleteLecture.title'),
            message: t('dialogs.deleteLecture.message', { context: lectureName }),
            confirmText: t('common.actions.delete'),
            cancelText: t('dialogs.deleteLecture.cancel'),
            variant: 'danger',
          });
          if (!confirmed) {
            return;
          }
          const secondCheck = await confirmDialog({
            title: t('dialogs.confirmDeletion.title'),
            message: t('dialogs.confirmDeletion.message'),
            confirmText: t('dialogs.confirmDeletion.confirm'),
            cancelText: t('dialog.cancel'),
            variant: 'danger',
          });
          if (!secondCheck) {
            return;
          }
          try {
            await request(`/api/lectures/${state.selectedLectureId}`, { method: 'DELETE' });
            showStatus(t('status.lectureRemoved'), 'success');
            state.selectedLectureId = null;
            clearDetailPanel();
            await refreshData();
          } catch (error) {
            showStatus(error.message, 'error');
          }
        });

        dom.createForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          const moduleId = Number(dom.createModule.value);
          const name = dom.createName.value.trim();
          const description = dom.createDescription.value.trim();
          if (!moduleId || !name) {
            showStatus(t('status.createLectureRequirements'), 'error');
            return;
          }
          try {
            const payload = await request('/api/lectures', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ module_id: moduleId, name, description }),
            });
            dom.createForm.reset();
            showStatus(t('status.lectureCreated'), 'success');
            await refreshData();
            const newLectureId = payload?.lecture?.id;
            if (newLectureId) {
              await selectLecture(newLectureId);
            }
          } catch (error) {
            showStatus(error.message, 'error');
          }
        });

        async function handleTranscribeClick(event) {
          event?.preventDefault?.();
          if (!state.selectedLectureId) {
            return;
          }

          const lectureId = state.selectedLectureId;
          const selectedModel = getTranscribeModelValue();
          const button = getTranscribeButton();

          if (button) {
            button.disabled = true;
          }

          showStatus(t('status.transcriptionPreparing'), 'info', { persist: true });
          startTranscriptionProgress(lectureId);
          try {
            const payload = await request(`/api/lectures/${lectureId}/transcribe`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ model: selectedModel }),
            });
            stopTranscriptionProgress();
            const fallbackModel = payload?.fallback_model;
            if (fallbackModel) {
              const fallbackReason =
                typeof payload?.fallback_reason === 'string'
                  ? payload.fallback_reason
                  : t('status.gpuNotAvailable');
              await showDialog({
                title: t('dialogs.gpuWhisper.title'),
                message: `${fallbackReason} ${t('status.gpuFallback', { model: fallbackModel })}`,
                confirmText: t('common.actions.ok'),
                cancelText: t('common.actions.close'),
                variant: 'danger',
              });
              setTranscribeModelValue(fallbackModel);
              if (dom.settingsWhisperModel) {
                dom.settingsWhisperModel.value = fallbackModel;
              }
              if (state.settings) {
                state.settings.whisper_model = fallbackModel;
                state.settings.whisper_model_requested = fallbackModel;
              }
              await loadGpuWhisperStatus();
            } else if (selectedModel === GPU_MODEL) {
              await loadGpuWhisperStatus();
            }
            showStatus(t('status.transcriptionCompleted'), 'success', { progressRatio: 1 });
            await refreshData();
            await selectLecture(lectureId);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            stopTranscriptionProgress();
            const progress = await fetchTranscriptionProgress(state.selectedLectureId);
            if (progress && progress.message) {
              showStatus(progress.message, progress.error ? 'error' : 'info', {
                progressRatio: progress.ratio,
                persist: !progress.finished,
              });
            } else {
              showStatus(message, 'error');
            }
          } finally {
            if (button) {
              button.disabled = false;
            }
          }
        }

        if (dom.settingsWhisperGpuTest) {
          dom.settingsWhisperGpuTest.addEventListener('click', async () => {
            if (state.gpuWhisper.unavailable) {
              return;
            }
            dom.settingsWhisperGpuTest.disabled = true;
            showStatus(t('status.gpuChecking'), 'info');
            try {
              const payload = await request('/api/settings/whisper-gpu/test', {
                method: 'POST',
              });
              const status = payload?.status || {};
              updateGpuWhisperUI(status);
              if (status.supported) {
                showStatus(t('status.gpuConfirmed'), 'success');
                if (state.settings?.whisper_model_requested === GPU_MODEL) {
                  if (dom.settingsWhisperModel) {
                    dom.settingsWhisperModel.value = GPU_MODEL;
                  }
                  setTranscribeModelValue(GPU_MODEL);
                  state.settings.whisper_model = GPU_MODEL;
                }
              } else {
                const failureMessage =
                  typeof status.message === 'string' && status.message
                    ? status.message
                    : t('status.gpuUnsupported');
                await showDialog({
                  title: t('dialogs.gpuWhisper.title'),
                  message: failureMessage,
                  confirmText: t('common.actions.ok'),
                  cancelText: t('common.actions.close'),
                  variant: 'danger',
                });
                showStatus(failureMessage, 'error');
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              showStatus(message, 'error');
            } finally {
              dom.settingsWhisperGpuTest.disabled = state.gpuWhisper.unavailable;
            }
          });
        }

        if (dom.settingsCloudConnectionTest) {
          dom.settingsCloudConnectionTest.addEventListener('click', async () => {
            await testCloudConnection({ refresh: true });
          });
        }

        if (dom.settingsUpdateRun) {
          dom.settingsUpdateRun.addEventListener('click', () => {
            void triggerSystemUpdate();
          });
        }

        if (dom.settingsUpdateRefresh) {
          dom.settingsUpdateRefresh.addEventListener('click', async () => {
            if (dom.settingsUpdateRefresh.disabled) {
              return;
            }
            dom.settingsUpdateRefresh.disabled = true;
            try {
              await fetchSystemUpdateStatus();
            } finally {
              dom.settingsUpdateRefresh.disabled = state.systemUpdate.running;
            }
          });
        }

        if (dom.settingsExport) {
          dom.settingsExport.addEventListener('click', async () => {
            dom.settingsExport.disabled = true;
            showStatus(t('status.exporting'), 'info');
            try {
              const payload = await request('/api/settings/export', { method: 'POST' });
              const archive = payload?.archive;
              if (!archive || !archive.path) {
                throw new Error(t('status.exportFailed'));
              }
              const link = document.createElement('a');
              link.href = buildStorageURL(archive.path);
              link.download = archive.filename || 'lecture-tools-export.zip';
              document.body.appendChild(link);
              link.click();
              link.remove();
              showStatus(t('status.exportReady'), 'success');
            } catch (error) {
              showStatus(error.message, 'error');
            } finally {
              dom.settingsExport.disabled = false;
            }
          });
        }

        if (dom.settingsImport) {
          dom.settingsImport.addEventListener('click', async () => {
            if (dom.settingsImport.disabled) {
              return;
            }

            const dialogResult = await showUploadDialog({
              accept: '.zip',
              title: t('dialogs.upload.archiveTitle'),
              description: t('dialogs.upload.archiveDescription'),
              prompt: t('dialogs.upload.prompt'),
              help: t('dialogs.upload.help'),
              browseLabel: t('dialogs.upload.browse'),
              clearLabel: t('dialogs.upload.clear'),
              uploadLabel: t('dialogs.upload.action'),
              onUpload: async (file, helpers) => {
                const formData = new FormData();
                formData.append('file', file);
                if (dom.settingsImportMode) {
                  formData.append('mode', dom.settingsImportMode.value || 'merge');
                }
                dom.settingsImport.disabled = true;
                if (dom.settingsExport) {
                  dom.settingsExport.disabled = true;
                }
                showStatus(t('status.importing'), 'info');
                try {
                  const response = await uploadWithProgress('/api/settings/import', {
                    method: 'POST',
                    body: formData,
                    onProgress: (ratio) => {
                      helpers?.reportProgress?.(ratio);
                    },
                  });
                  return response;
                } finally {
                  dom.settingsImport.disabled = false;
                  if (dom.settingsExport) {
                    dom.settingsExport.disabled = false;
                  }
                }
              },
            });

            if (!dialogResult || !dialogResult.uploaded || !dialogResult.confirmed) {
              return;
            }

            try {
              const payload = dialogResult.result;
              const summary = payload?.import;
              if (summary) {
                const count = Number(summary.lectures || 0);
                if (count > 0) {
                  showStatus(t('status.importSuccess', { count }), 'success');
                } else {
                  showStatus(t('status.importNoChanges'), 'success');
                }
              } else {
                showStatus(t('status.importSuccess', { count: 0 }), 'success');
              }
              await refreshData();
            } catch (error) {
              showStatus(error instanceof Error ? error.message : String(error), 'error');
            }
          });
        }

        if (dom.settingsExitApp) {
          dom.settingsExitApp.addEventListener('click', async () => {
            const { confirmed } = await showDialog({
              title: t('dialogs.exitApp.title'),
              message: t('dialogs.exitApp.message'),
              confirmText: t('common.actions.exit'),
              cancelText: t('dialog.cancel'),
              variant: 'danger',
            });
            if (!confirmed) {
              return;
            }

            dom.settingsExitApp.disabled = true;
            showStatus(t('status.shuttingDown'), 'info');

            try {
              await request('/api/system/shutdown', { method: 'POST' });
              window.setTimeout(() => {
                try {
                  window.close();
                } catch (error) {
                  // Ignore inability to close the window.
                }
                try {
                  window.location.replace('about:blank');
                } catch (error) {
                  // Ignore navigation failures.
                }
              }, 300);
            } catch (error) {
              dom.settingsExitApp.disabled = false;
              const message = error instanceof Error ? error.message : String(error);
              showStatus(message, 'error');
            }
          });
        }

        if (dom.settingsLanguage) {
          dom.settingsLanguage.addEventListener('change', (event) => {
            const value = normalizeLanguage(event.target.value);
            applyTranslations(value);
            renderStorage();
            updateEditModeUI();
          });
        }

        if (dom.settingsDisplayMode) {
          dom.settingsDisplayMode.addEventListener('change', () => {
            previewAppearance();
          });
        }

        if (dom.settingsTheme) {
          dom.settingsTheme.addEventListener('change', () => {
            previewAppearance();
          });
        }

        if (dom.settingsVisualEffects) {
          dom.settingsVisualEffects.addEventListener('change', () => {
            previewAppearance();
          });
        }

        if (dom.settingsCloudConnectionEnabled) {
          dom.settingsCloudConnectionEnabled.addEventListener('change', async (event) => {
            state.cloudConnection.enabled = Boolean(event.target.checked);
            if (!state.cloudConnection.enabled) {
              state.cloudConnection.connected = false;
              updateCloudConnectionStatus('disabled');
              await refreshCloudConnectionData();
              return;
            }
            updateCloudConnectionStatus(state.cloudConnection.connected ? 'connected' : 'idle');
            await testCloudConnection({ refresh: true });
          });
        }

        if (dom.settingsCloudServerUrl) {
          dom.settingsCloudServerUrl.addEventListener('change', (event) => {
            const normalized = normalizeCloudServerUrl(event.target.value);
            state.cloudConnection.url = normalized;
            event.target.value = normalized;
            state.cloudConnection.connected = false;
            updateCloudConnectionStatus(state.cloudConnection.enabled ? 'idle' : 'disabled');
          });
        }

        if (dom.settingsCloudAutoConnect) {
          dom.settingsCloudAutoConnect.addEventListener('change', (event) => {
            state.cloudConnection.autoConnect = Boolean(event.target.checked);
          });
        }

        if (dom.settingsCloudProcessingTarget) {
          dom.settingsCloudProcessingTarget.addEventListener('change', (event) => {
            const value = typeof event.target.value === 'string' ? event.target.value : 'cloud';
            state.cloudConnection.processingTarget = value === 'local' ? 'local' : 'cloud';
          });
        }

        if (dom.settingsForm) {
          dom.settingsForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const displayModeValue = normalizeDisplayMode(
              dom.settingsDisplayMode ? dom.settingsDisplayMode.value : DEFAULT_DISPLAY_MODE,
              dom.settingsTheme ? dom.settingsTheme.value : DEFAULT_THEME,
            );
            const themeValue = normalizeTheme(dom.settingsTheme.value);
            const effectsValue = normalizeVisualEffects(
              dom.settingsVisualEffects ? dom.settingsVisualEffects.value : DEFAULT_VISUAL_EFFECTS,
            );
            const languageValue = normalizeLanguage(dom.settingsLanguage.value);
            const modelValue = normalizeWhisperModel(dom.settingsWhisperModel.value);
            const computeValue = dom.settingsWhisperCompute.value.trim() || 'int8';
            const beamValue = Math.max(
              1,
              Math.min(10, Number(dom.settingsWhisperBeam.value) || 5),
            );
            const dpiValue = Number(normalizeSlideDpi(dom.settingsSlideDpi.value));
            const slideForceOcr = dom.settingsSlideForceOcr
              ? Boolean(dom.settingsSlideForceOcr.checked)
              : false;
            const masteringEnabled = dom.settingsAudioMastering
              ? Boolean(dom.settingsAudioMastering.checked)
              : true;
            const debugEnabled = dom.settingsDebugEnabled
              ? Boolean(dom.settingsDebugEnabled.checked)
              : false;
            const cloudConnectionEnabled = dom.settingsCloudConnectionEnabled
              ? Boolean(dom.settingsCloudConnectionEnabled.checked)
              : false;
            const cloudServerUrl = dom.settingsCloudServerUrl
              ? normalizeCloudServerUrl(dom.settingsCloudServerUrl.value)
              : DEFAULT_CLOUD_SERVER_URL;
            const cloudAutoConnect = dom.settingsCloudAutoConnect
              ? Boolean(dom.settingsCloudAutoConnect.checked)
              : false;
            const cloudProcessingTarget = dom.settingsCloudProcessingTarget
              ? dom.settingsCloudProcessingTarget.value
              : 'cloud';
            const updatePasswordValue = dom.settingsUpdatePassword
              ? dom.settingsUpdatePassword.value
              : '';
            const updatePasswordClear = dom.settingsUpdatePasswordClear
              ? dom.settingsUpdatePasswordClear.checked
              : false;
            let updatePasswordPayload = null;
            if (updatePasswordValue && updatePasswordValue.trim() !== '') {
              updatePasswordPayload = updatePasswordValue;
            } else if (updatePasswordClear) {
              updatePasswordPayload = '';
            }

            try {
              const payload = {
                display_mode: displayModeValue,
                theme: themeValue,
                visual_effects: effectsValue,
                language: languageValue,
                whisper_model: modelValue,
                whisper_compute_type: computeValue,
                whisper_beam_size: beamValue,
                slide_dpi: dpiValue,
                slide_force_ocr: slideForceOcr,
                audio_mastering_enabled: masteringEnabled,
                debug_enabled: debugEnabled,
                cloud_connection_enabled: cloudConnectionEnabled,
                cloud_server_url: cloudServerUrl,
                cloud_auto_connect: cloudAutoConnect,
                cloud_processing_target: cloudProcessingTarget,
              };
              if (updatePasswordPayload !== null) {
                payload.update_sudo_password = updatePasswordPayload;
              }
              const response = await request('/api/settings', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
              });
              const fallbackUpdatePasswordSet =
                updatePasswordPayload === null
                  ? Boolean(state.settings?.update_sudo_password_set)
                  : updatePasswordPayload !== '';
              const updatedSettings = response?.settings ?? {
                display_mode: displayModeValue,
                theme: themeValue,
                visual_effects: effectsValue,
                language: languageValue,
                whisper_model: modelValue,
                whisper_compute_type: computeValue,
                whisper_beam_size: beamValue,
                slide_dpi: dpiValue,
                slide_force_ocr: slideForceOcr,
                audio_mastering_enabled: masteringEnabled,
                debug_enabled: debugEnabled,
                cloud_connection_enabled: cloudConnectionEnabled,
                cloud_server_url: cloudServerUrl,
                cloud_auto_connect: cloudAutoConnect,
                cloud_processing_target: cloudProcessingTarget,
                update_sudo_password_set: fallbackUpdatePasswordSet,
              };
              syncSettingsForm(updatedSettings);
              if (modelValue === GPU_MODEL) {
                await loadGpuWhisperStatus();
              }
              showStatus(t('status.settingsSaved'), 'success');
            } catch (error) {
              showStatus(error.message, 'error');
            }
          });
        }
        window.addEventListener('beforeunload', () => {
          stopDebugPolling();
          void cancelCloudProcessingTasks({ force: true });
        });
        setActiveView(state.activeView);
        updateEditModeUI();
        clearDetailPanel();
        applyAppearance(DEFAULT_DISPLAY_MODE, DEFAULT_THEME, DEFAULT_VISUAL_EFFECTS);
        await loadGpuWhisperStatus();
        await loadSettings();
        await fetchSystemUpdateStatus();
        await refreshData();
      })();
    </script>
  </body>
</html>
